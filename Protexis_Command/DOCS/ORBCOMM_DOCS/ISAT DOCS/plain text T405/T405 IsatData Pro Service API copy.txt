IsatData Pro Service API Reference (FW 4.x) T405, Version 03 Sep 2020 © ORBCOMM¨ LEGAL NOTICE This documentation is owned by ORBCOMM¨ and protected by applicable copyright laws and international treaty provisions. Other copyrighted names used are the property of their respective owners. Therefore, you must treat this documentation like any other copyrighted material. This publication, or any part thereof, may not be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording, storage in an information retrieval system, or otherwise, without prior written permission by ORBCOMM, Inc. 395 W Passaic Street, Suite 325, Rochelle Park, NJ 07662 USA Phone 703-433-6325. The information in this document is for information purposes only and contains technical information and descriptions of the ORBCOMM product(s) and is subject to change without notice. No warranty or representation, express or implied, is made with respect to its contents. TRADEMARK NOTICE The ORBCOMM name and the ORBCOMM logo are registered trademarks of ORBCOMM. INMARSAT, the Inmarsat logo and IsatData Pro are trademarks of Inmarsat used under license by SkyWave (an ORBCOMM company). Inmarsat is not responsible for the operation and regulatory compliance of the products and services referred to in this document that connect to the Inmarsat system. The Bluetooth¨ word mark and logos are registered trademarks owned by the Bluetooth SIG, Inc. and any use of such marks by ORBCOMM is under license. Other trademarks and trade names are those of their respective owners. Other trademarks, trade names, and logos are those of their respective owners. EXPORT CONTROL STATEMENT The contents of this document, in whole or in part, shall not be exported from the United States, which export shall include, but not be limited to, transmittal to any non-U.S. citizen wherever said person is located, except in accordance with all United States laws and regulations relating to exports and to all administrative acts of the U.S. Government pursuant to such laws and regulations. Diversion, re-export or transshipment of the contents of this document, in whole or in part, contrary to U.S. law is also strictly prohibited. CONTACT INFORMATION Visit ORBCOMM Online www.ORBCOMM.com Contact Customer Support support@skywave.com +1.613.836.2222 Headquarters 395 W Passaic Street, Suite 325 Rochelle Park, NJ 07662 USA Tel: +1-703-433-6300 Fax: 1-703-433-6400 Email: sales@orbcomm.com TABLE OF CONTENTS Legal Notice Trademark Notice Export Control Statement Contact Information Contact Customer Support TABLE OF CONTENTS List of Figures List of Tables Preface Purpose Notation Reference 1 Introduction 2 Terminal Software Architecture 3 Lua Firmware Extensions 3.1 Global Functions 3.1.1 Base64 Library 3.1.1.1 decode() 3.1.1.2 encode() 3.1.2 bit32 Library 3.1.2.1 arshift() 3.1.2.2 band() 3.1.2.3 bnot() 3.1.2.4 bor() 3.1.2.5 btest() 3.1.2.6 bxor() 3.1.2.7 lrotate() 3.1.2.8 lshift() 3.1.2.9 rrotate() 3.1.2.10 rshift() 3.1.3 Debugging 3.1.3.1 trace() 3.1.3.2 tracef() 3.1.4 Pickle Library 3.1.4.1 dump 3.1.4.2 dumps 2 2 2 3 3 4 27 28 30 30 30 30 31 32 34 34 34 34 34 35 35 35 36 36 36 37 37 37 38 38 39 39 39 40 40 40 3.1.4.3 load 40 3.1.4.4 loads 41 3.1.5 Serial Output 41 3.1.5.1 print() 41 3.1.5.2 printf() 42 3.2 System Table 42 3.2.1 bitmask 42 3.2.1.1 Bitmask Handle Methods 42 3.2.1.2 create() 45 3.2.2 buffer 46 3.2.2.1 Buffer Handle Methods 46 3.2.2.2 create() 52 3.2.3 crc16() 52 3.2.4 createTable() 53 3.2.5 csum16() 53 3.2.6 csum16w() 54 3.2.7 fs 54 3.2.7.1 ATTR_DIRECTORY 54 3.2.7.2 ATTR_READ_ONLY 55 3.2.7.3 basename() 55 3.2.7.4 chdir() 55 3.2.7.5 copy() 56 3.2.7.6 dir() 56 3.2.7.7 expand() 57 3.2.7.8 getcwd() 58 3.2.7.9 info() 58 3.2.7.10 isdir() 59 3.2.7.11 md5() 59 3.2.7.12 mkdir() 59 3.2.7.13 numvols() 60 3.2.7.14 rmdir() 60 3.2.7.15 truncate() 60 3.2.7.16 volinfo() 61 3.2.8 heapInfo 61 3.2.9 info 62 3.2.9.1 info.bluetooth 63 3.2.10 J1587 66 3.2.10.1 J1587 event 66 3.2.10.2 J1587 Handle Methods 66 3.2.10.3 open() 72 3.2.11 J1939 Lua Firmware Extensions 72 3.2.11.1 captureOff() 73 3.2.11.2 captureOn() 73 3.2.11.3 J1939 Handle Methods 74 3.2.11.4 open() 82 3.2.12 J1979 (Terminals with CAN bus) 83 3.2.12.1 detect 83 3.2.12.2 open 84 3.2.12.3 J1979 Handle Methods 85 3.2.12.4 J1979 Event 86 3.2.13 LED Operation 88 3.2.13.1 flash() 88 3.2.13.2 off() 88 3.2.13.3 on() 89 3.2.13.4 Constants 89 3.2.14 math 89 3.2.14.1 convertcoord() 89 3.2.14.2 geodistance() 90 3.2.14.3 packint() 90 3.2.14.4 uadd() 91 3.2.14.5 uge() 91 3.2.14.6 ugt() 92 3.2.14.7 ule() 92 3.2.14.8 ult() 92 3.2.14.9 usub() 93 3.2.14.10 unpackint() 93 3.2.15 Modbus 94 3.2.15.1 Supported Interfaces 94 3.2.15.2 RS232 94 3.2.15.3 RS485 94 3.2.15.4 PARITY_NONE 94 3.2.15.5 PARITY_EVEN 94 3.2.15.6 PARITY_ODD 94 3.2.15.7 MODE_RTU 94 3.2.15.8 MODE_ASCII 94 3.2.15.9 open() 94 3.2.15.10 open_tcp() 95 3.2.15.11 Modbus Handle Methods 96 3.2.15.12 Response Event 105 3.2.16 onewire 106 3.2.16.1 connect() 106 3.2.16.2 crc8() 107 3.2.16.3 crc16() 108 3.2.16.4 Onewire Handle Methods 110 3.2.17 Stopwatch 122 3.2.17.1 create() 122 3.2.17.2 Stopwatch Handle Methods 122 3.2.18 timer 125 3.2.18.1 MAX_TIMEOUT 125 3.2.18.2 MIN_TIMEOUT 125 3.2.18.3 create() 125 3.2.18.4 Timer Handle Methods 125 3.2.18.5 Firmware Events 126 3.2.19 Uptime 127 3.2.19.1 framework() 127 3.2.19.2 idle() 127 3.2.19.3 powersave() 128 3.2.19.4 terminal() 128 3.2.20 watchdog 129 3.2.20.1 clearmaxtime() 129 3.2.20.2 getmaxtime() 129 3.2.20.3 kick() 130 4 Lua Infrastructure 131 4.1 Globals 131 4.1.1 LSF_VERSION 131 4.1.2 LSF_REVISION 131 4.1.3 LSF_BUILD_DATE 131 4.1.4 LSF_BUILD_TIME 131 4.1.5 LSF_GENERATION 131 4.1.6 LSF_API_LEVEL 131 4.1.7 SKYWAVE_PACKAGE_VERSION 131 4.1.8 zlib Library 131 4.1.8.1 compress() 131 4.1.8.2 decompress() 133 4.1.8.3 deflate() 133 4.1.8.4 Deflate Handle Methods 134 4.1.8.5 inflate() 136 4.1.8.6 Inflate Handle Methods 137 4.1.8.7 Memory Considerations 138 4.1.9 Xymodem library 138 4.1.9.1 XYMRC_* 138 4.1.9.2 XYMP_* 138 4.1.9.3 receive() 139 4.1.9.4 receiveX() 139 4.1.9.5 transmit() 140 4.1.9.6 transmitX() 140 4.1.9.7 getError() 140 4.2 Scheduler 141 4.2.1 Scheduler Module Functions 141 4.2.1.1 allThreads() 141 4.2.1.2 createEventQ() 141 4.2.1.3 delay() 142 4.2.1.4 getThread() 143 4.2.1.5 post() 143 4.2.1.6 spawn() 144 4.2.1.7 terminate() 145 4.2.1.8 waitQ() 146 4.2.2 Thread Handle Methods 147 4.2.2.1 addTerminationHandler() 147 4.2.2.2 destroy() 148 4.2.2.3 dispatches() 148 4.2.2.4 maxExecutionTime() 149 4.2.2.5 name() 149 4.2.2.6 removeTerminationHandler() 150 4.2.2.7 status() 150 4.2.2.8 terminate() 151 4.2.2.9 thread() 152 4.2.2.10 totalExecutionTime() 152 4.2.3 Event Queue Methods 152 4.2.3.1 clear() 153 4.2.3.2 count() 153 4.2.3.3 destroy() 153 4.2.3.4 event() 154 4.2.3.5 events() 155 4.2.3.6 lastEvent() 155 4.2.3.7 lastEventTime() 155 4.2.3.8 name() 156 4.2.3.9 size() 157 4.2.3.10 source() 157 4.2.3.11 wait() 158 4.3 Service Manager 158 4.3.1 dataPath() 159 4.3.2 decodeMsg() 159 4.3.3 disableService() 160 4.3.4 encodeMsg() 160 4.3.5 getDisabledServices() 161 4.3.6 getInfo() 161 4.3.7 getList() 161 4.3.8 getMsgDef() 162 4.3.9 getProp() 163 4.3.10 getPropDef() 163 4.3.11 getPropList() 164 4.3.12 loadCode() 164 4.3.13 resetProps() 165 4.3.14 restart() 165 4.3.15 revertProps() 166 4.3.16 saveProps() 166 4.3.17 setProp() 167 4.3.18 setProps() 167 4.3.19 validateSin() 168 4.3.20 verifyProp() 168 4.4 Message Library 169 4.4.1 Direction 169 4.4.2 DirectionStr 169 4.4.3 Types 169 4.4.4 TypesStr 170 4.5 Property Library 170 4.5.1 Storage 170 4.5.2 StorageStr 171 4.6 Utilities 171 4.6.1 clone() 171 4.6.2 dumpvar() 171 4.6.3 makeEnum() 174 4.6.4 tdumpvar() 175 4.6.5 toHex() 175 5 Core Services 177 5.1 Types 177 5.2 System (SIN 16) 178 5.2.1 Properties 178 5.2.2 To-Mobile Messages 180 5.2.2.1 getTerminalInfo (SIN 16, MIN 1) 180 5.2.2.2 getTerminalStatus (SIN 16, MIN 2) 180 5.2.2.3 getServiceList (SIN 16, MIN 3) 180 5.2.2.4 getServiceInfo (SIN 16, MIN 4) 180 5.2.2.5 restartService (SIN 16, MIN 5) 181 5.2.2.6 resetTerminal (SIN 16, MIN 6) 181 5.2.2.7 getTerminalMetrics (SIN 16, MIN 7) 181 5.2.2.8 getProperties (SIN 16, MIN 8) 181 5.2.2.9 setProperties (SIN 16, MIN 9) 181 5.2.2.10 resetProperties (SIN 16, MIN 10) 181 5.2.2.11 saveProperties (SIN 16, MIN 11) 181 5.2.2.12 revertProperties (SIN 16, MIN 12) 182 5.2.2.13 restartFramework (SIN 16, MIN 13) 182 5.2.2.14 setPassword (SIN 16, MIN 14) 182 5.2.2.15 disableService (SIN 16, MIN 15) 182 5.2.2.16 setEnabledServices (SIN 16, MIN 16) 182 5.2.2.17 Reserved (SIN 16, MIN 17) 182 5.2.2.18 Reserved (SIN 16, MIN 18) 182 5.2.3 From-Mobile Messages 182 5.2.3.1 terminalInfo (SIN 16, MIN 1) 183 5.2.3.2 terminalStatus (SIN 16, MIN 2) 184 5.2.3.3 serviceList (SIN 16, MIN 3) 185 5.2.3.4 serviceInfo (SIN 16, MIN 4) 185 5.2.3.5 propertyValues (SIN 16, MIN 5) 186 5.2.3.6 termReset (SIN 16, MIN 6) 186 5.2.3.7 terminalRegistration (SIN 16, MIN 8) 186 5.2.3.8 setPasswordResult (SIN 16, MIN 9) 187 5.2.3.9 disableServiceResult (SIN 16, MIN 10) 187 5.2.3.10 newTimeSync 188 5.2.4 Constants 188 5.2.4.1 shutdownCause 188 5.2.4.2 shutdownCauseStr 189 5.2.4.3 shutdownReason 189 5.2.4.4 shutdownReasonStr 189 5.2.5 Functions 190 5.2.5.1 ledFlash() 190 5.2.5.2 reset() 190 5.2.5.3 restart() 190 5.2.5.4 shutdown() 191 5.2.6 Posted Events 192 5.2.6.1 Shutdown 192 5.2.6.2 Terminal Registered 192 5.2.6.3 Time Synchronization 193 5.3 Power (SIN 17) 193 5.3.1 Properties 193 5.3.2 To-Mobile Messages 195 5.3.2.1 powerOff (SIN 17, MIN 1) 195 5.3.3 From-Mobile Messages 195 5.3.3.1 extPowerAlarm (SIN 17, MIN 1) 195 5.3.3.2 powerOnAlarm (SIN 17, MIN 2) 196 5.3.3.3 powerOffResult (SIN 17, MIN 3) 196 5.3.3.4 reserved (SIN 17, MIN 4) 196 5.3.4 Constants 196 5.3.4.1 PowerOnReason 196 5.3.4.2 PowerOnReasonStr 197 5.3.4.3 ExtPowerState 197 5.3.4.4 ExtPowerStateStr 197 5.3.5 Functions 198 5.3.5.1 powerOff() 198 5.3.6 Posted Events 198 5.3.6.1 External Power Alarm 198 5.3.7 Firmware Events 199 5.3.7.1 External Power 199 5.3.7.2 Shutdown Pending 199 5.4 Message (SIN 18) 199 5.4.1 Multiple Transports (ST 9100) 200 5.4.2 Properties 200 5.4.3 To-Mobile Messages 203 5.4.3.1 getStatus (SIN 18, MIN 1) 203 5.4.3.2 cancel (SIN 18, MIN 2) 203 5.4.3.3 getInstance(SIN 18, MIN 5) 204 5.4.3.4 deleteInstance (SIN 18, MIN 6) 204 5.4.3.5 getKeys (SIN 18, MIN 7) 204 5.4.3.6 setOverrideInstance (SIN 18, MIN 10) 204 5.4.3.7 setOverrides (SIN 18, MIN 11) 204 5.4.3.8 getOverriddenMins (SIN 18, MIN 12) 206 5.4.3.9 getOverrides (SIN 18, MIN 13) 206 5.4.3.10 deleteOverrides (SIN 18, MIN 14) 206 5.4.3.11 deleteAllOverrides (SIN 18, MIN 15) 206 5.4.4 From-Mobile Messages 206 5.4.4.1 custom (SIN 18, MIN 1) 207 5.4.4.2 msgStatus (SIN 18, MIN 2) 207 5.4.4.3 msgInvalid (SIN 18, MIN 3) 208 5.4.4.4 msgError (SIN 18, MIN 4) 208 5.4.4.5 instance (SIN 18, MIN 5) 209 5.4.4.6 deleteResult (SIN 18, MIN 6) 209 5.4.4.7 keys (SIN 18, MIN 7) 209 5.4.4.8 overriddenMins (SIN 18, MIN 12) 209 5.4.4.9 overriddes (SIN 18, MIN 13) 209 5.4.5 Constants 210 5.4.5.1 MsgDuplicate 210 5.4.5.2 MsgDuplicateStr 211 5.4.5.3 MsgStatus 211 5.4.5.4 MsgStatusStr 211 5.4.6 Functions 212 5.4.6.1 allInstances() 212 5.4.6.2 deleteInstance() 212 5.4.6.3 getInstance() 213 5.4.6.4 getOverrides() 213 5.4.6.5 getKeys() 214 5.4.6.6 invalidSinHandler() 214 5.4.6.7 register() 215 5.4.6.8 setInstance() 215 5.4.7 Message Handle Methods 216 5.4.7.1 cancel() 216 5.4.7.2 getList() 216 5.4.7.3 msgError() 217 5.4.7.4 reply() 217 5.4.7.5 send() 219 5.4.7.6 sendRaw() 220 5.4.8 Posted Events 221 5.4.8.1 All Overrides Deleted 221 5.4.8.2 Instance Added 222 5.4.8.3 Instance Cleared 222 5.4.8.4 Instance Deleted 222 5.4.8.5 Message Status 223 5.4.8.6 Message Service Ready 223 5.4.8.7 New Decoded Message 224 5.4.8.8 New Raw Message 224 5.4.8.9 Overrides Changed 224 5.4.8.10 Overrides Deleted 225 5.4.8.11 Queue Blockage 225 5.5 Report (SIN 19) 226 5.5.1 Properties 226 5.5.2 To-Mobile Messages 228 5.5.2.1 generateReport (SIN 19, MIN 1) 229 5.5.3 From-Mobile Messages 229 5.5.3.1 simpleReport (SIN 19, MIN 1) 229 5.5.3.2 fullReport (SIN 19, MIN 2) 230 5.5.3.3 eioReport (SIN 19, MIN 3) 230 5.5.3.4 noEIO (SIN 19, MIN 4) 231 5.5.4 Functions 231 5.5.4.1 sendReport() 231 5.5.5 Posted Events 231 5.6 Position (SIN 20) 232 5.6.1 Properties 232 5.6.2 To-Mobile Messages 237 5.6.2.1 getPosition (SIN 20, MIN 1) 237 5.6.2.2 getLastPos (SIN 20, MIN 2) 237 5.6.2.3 getSources (SIN 20, MIN 3) 238 5.6.3 From-Mobile Messages 238 5.6.3.1 position (SIN 20, MIN 1) 238 5.6.3.2 sources (SIN 20, MIN 2) 239 5.6.3.3 accelStart (SIN 20, MIN 3) 239 5.6.3.4 accelStop (SIN 20, MIN 4) 239 5.6.4 Constants 240 5.6.4.1 FixTypes 240 5.6.4.2 FixTypeStr 241 5.6.4.3 GpsSource 241 5.6.4.4 GpsSourceStr 241 5.6.4.5 HarshDrvStopReason 241 5.6.4.6 HarshDrvStopReasonStr 242 5.6.5 Functions 242 5.6.5.1 requestFix() 242 5.6.6 Posted Events 243 5.6.6.1 Accident Start 243 5.6.6.2 Accident Stop 243 5.6.6.3 Antenna Cut 244 5.6.6.4 GPS Jamming 245 5.6.6.5 Harsh Acceleration Start 245 5.6.6.6 Harsh Acceleration Stop 246 5.6.6.7 Harsh Braking Start 247 5.6.6.8 Harsh Braking Stop 247 5.6.6.9 Harsh Cornering Start 248 5.6.6.10 Harsh Cornering Stop 249 5.6.6.11 Position Data Updated 250 5.7 Geofence (SIN 21) 250 5.7.1 Properties 251 5.7.2 To-Mobile Messages 253 5.7.2.1 setCircle (SIN 21, MIN 1) 253 5.7.2.2 setPolygon (SIN 21, MIN 2) 253 5.7.2.3 enableFence (SIN 21, MIN 3) 254 5.7.2.4 updateAlarmCond (SIN 21, MIN 4) 254 5.7.2.5 getStatus (SIN 21, MIN 5) 254 5.7.2.6 getAllStatus (SIN 21, MIN 6) 254 5.7.2.7 setRectangle (SIN 21, MIN 7) 254 5.7.2.8 removeTags (SIN 21, MIN 8) 255 5.7.2.9 setTags (SIN 21, MIN 9) 255 5.7.2.10 getTags (SIN 21, MIN 10) 256 5.7.2.11 getFenceDef (SIN 21, MIN 11) 256 5.7.3 From-Mobile Messages 256 5.7.3.1 alarm (SIN 21, MIN 1) 256 5.7.3.2 fenceStatus (SIN 21, MIN 2) 257 5.7.3.3 allFencesStatus (SIN 21, MIN 3) 257 5.7.3.4 alarms (SIN 21, MIN 4) 258 5.7.3.5 alarms2 (SIN 21, MIN 5) 258 5.7.3.6 tags (SIN 21, MIN 6) 259 5.7.3.7 fenceDef (SIN 21, MIN 7) 259 5.7.3.8 fenceCheckStatus (SIN 21, MIN 8) 260 5.7.4 Constants 260 5.7.4.1 AlarmCondition 260 5.7.4.2 AlarmConditionStr 261 5.7.4.3 FenceCheckStatus 261 5.7.4.4 FenceCheckStatusStr 261 5.7.4.5 Status 262 5.7.4.6 StatusStr 262 5.7.4.7 Type 262 5.7.4.8 TypeStr 262 5.7.5 Functions 263 5.7.5.1 enableFence() 263 5.7.5.2 getFenceDef() 263 5.7.5.3 getStatus() 265 5.7.5.4 getTags() 266 5.7.5.5 removeTags() 267 5.7.5.6 setTags() 268 5.7.6 Posted Events 269 5.7.6.1 Fence Check Done 269 5.7.6.2 Fence Crossing Alarm 269 5.7.6.3 Fence Crossing Alarm (multiple) 270 5.7.6.4 Hysteresis Check Done 270 5.8 Serial (SIN 22) 271 5.8.1 ST 6000 271 5.8.2 Properties 271 5.8.2.1 External DTE Connect/Disconnect 275 5.8.2.2 Power Management 275 5.8.3 To-Mobile Messages 276 5.8.4 From-Mobile Messages 276 5.8.4.1 DTEAlarm (SIN 22, MIN 1) 276 5.8.4.2 breakAlarm (SIN 22, MIN 2) 276 5.8.5 Functions 276 5.8.5.1 connect() 276 5.8.5.2 disconnect() 277 5.8.6 Common Handle Methods 278 5.8.6.1 cancelEvent() 278 5.8.6.2 disconnect() 278 5.8.6.3 eventOnByte() 279 5.8.6.4 eventOnFrame() 279 5.8.6.5 eventOnLine() 280 5.8.6.6 flush() 280 5.8.6.7 getByte() 281 5.8.6.8 getFrame() 281 5.8.6.9 getFrameConfig() 282 5.8.6.10 getLine() 282 5.8.6.11 getLineConfig() 283 5.8.6.12 sendBreak() 283 5.8.6.13 setBaud() 284 5.8.6.14 setFrameConfig() 284 5.8.6.15 setLineConfig() 285 5.8.6.16 source() 286 5.8.6.17 write() 287 5.8.6.18 writeframe() 288 5.8.6.19 writestr() 289 5.8.7 Posted Events 289 5.8.7.1 Break Condition 289 5.8.7.2 Byte Received 290 5.8.7.3 DTE Connection 290 5.8.7.4 Frame Received 290 5.8.7.5 Line Received 291 5.9 Log (SIN 23) 291 5.9.1 Properties 292 5.9.2 To-Mobile Messages 294 5.9.2.1 setDataLogFilter (SIN 23, MIN 1) 295 5.9.2.2 setDebugLogFilter (SIN 23, MIN 2) 295 5.9.2.3 getDataLogCount (SIN 23, MIN 3) 295 5.9.2.4 getDebugLogCount (SIN 23, MIN 4) 296 5.9.2.5 getDataLogEntries (SIN 23, MIN 5) 296 5.9.2.6 getDebugLogEntries (SIN 23, MIN 6) 296 5.9.2.7 clearLogs (SIN 23, MIN 7) 296 5.9.2.8 setUploadDataLogFilter (SIN 23, MIN 8) 296 5.9.2.9 setUploadDebugLogFilter (SIN 23, MIN 9) 297 5.9.2.10 getUploadDataLogCount (SIN 23, MIN 10) 297 5.9.2.11 getUploadDebugLogCount (SIN 23, MIN 11) 298 5.9.2.12 setDebugLogFilter2 (SIN 23, MIN 12) 298 5.9.2.13 getDebugLogEntries2 (SIN 23, MIN 13) 298 5.9.2.14 setUploadDebugLogFilter2 (SIN 23, MIN 14) 298 5.9.3 From-Mobile Messages 299 5.9.3.1 dataLogFilter (SIN 23, MIN 1) 299 5.9.3.2 debugLogFilter (SIN 23, MIN 2) 300 5.9.3.3 dataLogCount (SIN 23, MIN 3) 300 5.9.3.4 debugLogCount (SIN 23, MIN 4) 300 5.9.3.5 dataLogEntries (SIN 23, MIN 5) 300 5.9.3.6 debugLogEntries (SIN 23, MIN 6) 301 5.9.3.7 uploadDataLogFilter (SIN 23, MIN 7) 301 5.9.3.8 uploadDebugLogFilter (SIN 23, MIN 8) 301 5.9.3.9 uploadDataLogCount (SIN 23, MIN 9) 302 5.9.3.10 uploadDebugLogCount (SIN 23, MIN 10) 302 5.9.3.11 uploadDataLogEntries (SIN 23, MIN 11) 302 5.9.3.12 uploadDebugLogEntries (SIN 23, MIN 12) 303 5.9.3.13 debugLogFilter2 (SIN 23, MIN 13) 303 5.9.3.14 debugLogEntries2 (SIN 23, MIN 14) 303 5.9.3.15 uploadDebugLogFilter2 (SIN 23, MIN 15) 304 5.9.3.16 uploadDebugLogEntries2 (SIN 23, MIN 16) 304 5.9.4 Constants 304 5.9.4.1 CRITICAL 304 5.9.4.2 ERROR 304 5.9.4.3 WARNING 304 5.9.4.4 INFO 305 5.9.4.5 Levels 305 5.9.4.6 LevelsStr 305 5.9.5 Functions 305 5.9.5.1 addDebug() 305 5.9.5.2 addDebugf() 306 5.9.5.3 clearLogs() 306 5.9.5.4 createFilter() 307 5.9.5.5 getUploadLogCount() 308 5.9.5.6 setUploadFilter() 309 5.9.6 Handle Methods 310 5.9.6.1 close() 310 5.9.6.2 getCount() 310 5.9.6.3 getNext() 311 5.9.7 Posted Events 312 5.10 File System (SIN 24) 312 5.10.1 Properties 312 5.10.2 To-Mobile Messages 312 5.10.2.1 write (SIN 24, MIN 1) 312 5.10.2.2 read (SIN 24, MIN 2) 313 5.10.2.3 dir (SIN 24, MIN 3) 313 5.10.2.4 stat (SIN 24, MIN 5) 313 5.10.3 From-Mobile Messages 313 5.10.3.1 writeResult (SIN 24, MIN 1) 313 5.10.3.2 readResult (SIN 24, MIN 2) 313 5.10.3.3 dirResult (SIN 24, MIN 3) 314 5.10.3.4 statResult (SIN 24, MIN 4) 314 5.10.4 Functions 314 5.10.5 Posted Events 314 5.11 External Input/Output (EIO) (SIN 25) 315 5.11.1 Properties 317 5.11.2 To-Mobile Messages 330 5.11.2.1 readPort (SIN 25, MIN 1) 330 5.11.2.2 writePort (SIN 25, MIN 2) 330 5.11.2.3 pulsePort (SIN 25, MIN 3) 331 5.11.3 From-Mobile Messages 331 5.11.3.1 portValue (SIN 25, MIN 1) 331 5.11.3.2 portAlarm (SIN 25, MIN 2) 331 5.11.4 Functions 331 5.11.4.1 getPulseCount 331 5.11.4.2 pulsePort() 332 5.11.4.3 readPort() 332 5.11.4.4 writePort() 333 5.11.5 Posted Events 333 5.11.5.1 Analog Alarm 333 5.11.5.2 Digital Alarm 334 5.11.5.3 Pulse Counter Report 334 5.11.5.4 Pulse Counter Threshold 335 5.12 Shell (SIN 26) 335 5.12.1 Properties 335 5.12.2 To-Mobile Messages 336 5.12.2.1 executeCmd (SIN 26, MIN 1) 336 5.12.2.2 executeLua (SIN 26, MIN 2) 336 5.12.2.3 executePrivilegedCmd (SIN 26, MIN 3) 336 5.12.2.4 executePrivilegedLua (SIN 26, MIN 4) 337 5.12.2.5 getAccessInfo (SIN 26, MIN 5) 337 5.12.2.6 setAccessLevel (SIN 26, MIN 6) 337 5.12.2.7 changeAccessPassword (SIN 26, MIN 7) 337 5.12.3 From-Mobile Messages 337 5.12.3.1 cmdResult (SIN 26, MIN 1) 337 5.12.3.2 accessInfo (SIN 26, MIN 2) 338 5.12.3.3 accessSetChangeResult (SIN 26, MIN 3) 338 5.12.4 Functions 338 5.12.4.1 attach() 338 5.12.4.2 detach() 338 5.12.4.3 executeCmd() 339 5.12.4.4 register() 339 5.12.4.5 unregister() 340 5.12.5 Posted Events 340 5.13 IDP (SIN 27) 341 5.13.1 Properties 341 5.13.2 To-Mobile Messages 343 5.13.2.1 getSReg (SIN 27, MIN 1) 343 5.13.2.2 setSreg (SIN 27, MIN 2) 343 5.13.2.3 getMetrics (SIN 27, MIN 3) 343 5.13.2.4 getMetrics2 (SIN 27, MIN 4) 343 5.13.3 From-Mobile Messages 343 5.13.3.1 getSRegResult (SIN 27, MIN 1) 344 5.13.3.2 setSRegResult (SIN 27, MIN 2) 344 5.13.3.3 metricsResult (SIN 27, MIN 3) 344 5.13.3.4 metricsResult2 (SIN 27, MIN 4) 344 5.13.4 Constants 344 5.13.4.1 TRANSPORT_ID 345 5.13.5 Functions 345 5.13.5.1 eventDeregister() 345 5.13.5.2 eventRegister() 345 5.13.5.3 getMetrics() 346 5.13.5.4 getNetworkId() 346 5.13.5.5 getProtocolRevision() 347 5.13.5.6 getSRegVal() 347 5.13.5.7 getTemp() 348 5.13.5.8 gps() 348 5.13.5.9 reset() 349 5.13.5.10 setSRegVal() 349 5.13.5.11 strFlags() 350 5.13.6 Posted Events 350 5.13.6.1 Event Update 350 5.13.6.2 GPS Jamming 351 5.13.6.3 Modem Comms 351 5.13.6.4 Modem Registered 351 5.13.6.5 Modem Reset 352 5.13.6.6 Satellite Status Change 352 5.13.6.7 Wake Up Interval Change 352 5.14 Reserved (SIN 28) 353 5.15 Cell (SIN 29) 353 5.15.1 Properties 353 5.15.1.1 SIM Selection 358 5.15.1.2 Network Lists 359 5.15.1.3 RSSI 359 5.15.2 To-Mobile Messages 359 5.15.2.1 listOperation (SIN 29, MIN 1) -Deprecated 360 5.15.2.2 getLists (SIN 29, MIN 2) 360 5.15.2.3 listOperation2 (SIN 29, MIN 5) 360 5.15.3 From-Mobile Messages 360 5.15.3.1 operationResult (SIN 29, MIN 1) 361 5.15.3.2 lists (SIN 29, MIN 2) 361 5.15.3.3 operationResult2 (SIN 29, MIN 5) 361 5.15.4 Constants 362 5.15.4.1 DataFormat 362 5.15.4.2 DataFormatStr 362 5.15.4.3 LinkStability 362 5.15.4.4 LinkStabilityStr 363 5.15.4.5 ListOp 363 5.15.4.6 ListOpStr 363 5.15.4.7 ListType 363 5.15.4.8 ListTypeStr 364 5.15.4.9 NetDescription 364 5.15.4.10 Status 364 5.15.4.11 NetStatusStr 364 5.15.4.12 SimStatus 365 5.15.4.13 SimStatusStr 365 5.15.4.14 WhichList 365 5.15.4.15 WhichListStr 366 5.15.5 Functions 366 5.15.5.1 Get White/Black List 366 5.15.5.2 simSwitch() 366 5.15.5.3 Send SMS Message 367 5.15.5.4 White/Black List Operation 367 5.15.6 Posted Events 368 5.15.6.1 Antenna Cut 368 5.15.6.2 APN Connected 368 5.15.6.3 IP Ready 369 5.15.6.4 Link Status 369 5.15.6.5 Network Status 369 5.15.6.6 Power Status 370 5.15.6.7 SIM Presence 370 5.15.6.8 SIM Status 371 5.15.6.9 SMS Message Received 371 5.16 Reserved (SIN 30) 372 5.17 Reserved (SIN 31) 372 5.18 Campaign (SIN 32) 372 5.18.1 Terminal Campaign States 372 5.18.2 Properties 374 5.18.3 To-Mobile Messages 374 5.18.4 From-Mobile Messages 374 5.18.5 Functions 375 5.18.6 Posted Events 375 5.19 Internet Protocol (ip) (SIN 33) 375 5.19.1 Supported Functionality 375 5.19.1.1 FTP 375 5.19.1.2 HTTP 375 5.19.1.3 SMTP 376 5.19.1.4 TCP 376 5.19.1.5 UDP 376 5.19.2 Cellular Modules 376 5.19.3 Channel Modes of Operation 377 5.19.3.1 Session 377 5.19.3.2 Transaction 377 5.19.4 Secure Connections 377 5.19.5 Gateway Synchronization 377 5.19.6 Compression 378 5.19.7 Constants 378 5.19.7.1 TRANSPORT_IP 378 5.19.7.2 Channel 378 5.19.7.3 ChannelStr 378 5.19.7.4 FtpOp 379 5.19.7.5 FtpOpStr 379 5.19.7.6 HttpOp 379 5.19.7.7 HttpOpStr 380 5.19.7.8 Routing 380 5.19.7.9 RoutingStr 380 5.19.8 Properties 381 5.19.8.1 M2M SMTP 381 5.19.8.2 Satellite Properties 381 5.19.8.3 Messaging Properties 381 5.19.9 To-Mobile Messages 383 5.19.10 From-Mobile Messages 384 5.19.11 Functions 384 5.19.11.1 channelAllocate() 384 5.19.11.2 ftp() 389 5.19.11.3 httpGet() 389 5.19.11.4 pollNow() 390 5.19.12 Channel Methods 390 5.19.12.1 close() 390 5.19.12.2 dispose() 391 5.19.12.3 info() 391 5.19.12.4 open() 392 5.19.12.5 send() 392 5.19.12.6 usingCell() 393 5.19.13 Posted Events 393 5.19.13.1 Cellular Ready 393 5.19.13.2 Channel Disposed 393 5.19.13.3 Data Received 394 5.19.13.4 Email Status 394 5.19.13.5 FTP Complete 394 5.19.13.6 HTTP Complete 395 5.19.13.7 M2M Email Received 395 5.19.13.8 Satellite Ready 396 5.19.13.9 SMTP Email Received 396 5.19.13.10 SMTP Status 397 5.19.13.11 Server Connected 397 5.19.13.12 Socket Closed 397 5.19.13.13 UDP Complete 398 5.19.13.14 Application Examples 398 5.20 Accelerometer (SIN 34) 398 5.20.1 Global Parameters 398 5.20.1.1 Gravity Range 399 5.20.1.2 Accelerometer Power Modes 399 5.20.1.3 Gravity Compensation 400 5.20.1.4 Offset Compensation 400 5.20.2 Event Detection 400 5.20.2.1 Parameter Guidelines 401 5.20.2.2 Motion Detector States 401 5.20.2.3 Detector Parameters 401 5.20.2.4 Detector State Fields 403 5.20.3 Sample Capture 403 5.20.4 Sample Retrieval 404 5.20.5 Accelerometer Orientation 405 5.20.5.1 Automatic Orientation Detection 407 5.20.5.2 Guidelines for Successful Auto-Orientation 407 5.20.5.3 Power Considerations 408 5.20.5.4 Low Power Mode 408 5.20.6 Properties 409 5.20.6.1 Sample Rates 413 5.20.7 To-Mobile Messages 415 5.20.7.1 autoOrientation (SIN 34, MIN 1) 415 5.20.7.2 getSamples (SIN 34, MIN 2) 416 5.20.8 From-Mobile Messages 416 5.20.8.1 autoOrientationStatus (SIN 34, MIN 1) 416 5.20.8.2 samples (SIN 34, MIN 2) 417 5.20.9 Functions 418 5.20.9.1 computeTilt() 418 5.20.9.2 getConfig() 418 5.20.9.3 getSample() 419 5.20.9.4 getStatus() 420 5.20.9.5 getTilt() 420 5.20.9.6 offset.clear() 421 5.20.9.7 offset.doHWCompensation() 422 5.20.9.8 offset.get() 422 5.20.9.9 offset.requestHWCompensation() 423 5.20.9.10 offset.set() 423 5.20.9.11 requestSample() 424 5.20.10 Posted Events 424 5.20.10.1 H/W Compensation Done 425 5.20.10.2 Sample 425 5.20.11 Accelerometer Event Detection 426 5.20.11.1 createDetector() 426 5.20.11.2 Detector Methods 426 5.20.11.3 Posted Events 430 5.20.12 Sample Capture Buffer 431 5.20.12.1 createSampleBuffer() 431 5.20.12.2 Sample Buffer Handle Methods 432 5.20.12.3 Posted Events 438 5.21 Bluetooth (SIN 35) 439 5.21.1 Properties 439 5.21.2 To-Mobile Messages 441 5.21.3 From-Mobile Messages 441 5.21.3.1 centralConnectAlarm (SIN 35, MIN 1) 441 5.21.3.2 serialConnectAlarm (SIN 35, MIN 2) 441 5.21.4 Global Constants 441 5.21.4.1 addrType 441 5.21.4.2 addrTypeStr 442 5.21.5 Server Constants 442 5.21.5.1 MAX_SHORT_MSG_SIZE 442 5.21.6 GAP Client Constants 442 5.21.6.1 MAX_ADV_FILTERS 442 5.21.6.2 MAX_ADV_FILTERS_PER_SCANNER 442 5.21.7 GATT Client Constants 442 5.21.7.1 MAX_PERIPHERAL_CONNECTIONS 442 5.21.7.2 MAX_SERVICES_PER_CONNECTION 442 5.21.7.3 MAX_CHARACTERISTICS_PER_SERVICE 442 5.21.7.4 propertyBits 442 5.21.8 Server Functions (Peripheral Role) 443 5.21.8.1 getDeviceLabel() 443 5.21.8.2 setDeviceLabel() 443 5.21.8.3 getBondedCentralDevices() 444 5.21.8.4 deleteBondedCentralDevice() 444 5.21.8.5 startFastAdvertising() 445 5.21.9 Short Message Functions (Peripheral Role) 446 5.21.9.1 createShortMessageHandle() 446 5.21.9.2 Message Handle Methods 446 5.21.10 GAP Client Functions (Central Role) 447 5.21.10.1 Filtering Advertisement Reports 447 5.21.10.2 createScanner() 449 5.21.10.3 Scanner Handle Methods 449 5.21.11 GATT Client Functions (Central Role) 460 5.21.11.1 allocatePeripheralConnection() 460 5.21.11.2 Connection Handle Methods 461 5.21.11.3 getConnectedPeripheralDevices() 474 5.21.11.4 getBondedPeripheralDevices() 475 5.21.11.5 deleteBondedPeripheralDevice() 475 5.21.12 GATT Client Error Codes 476 5.21.13 Posted System Events 477 5.21.13.1 RESET 477 5.21.14 Server Global Events 477 5.21.15 GAP Client Events 478 5.21.15.1 SCAN_STOPPED 478 5.21.15.2 TRIGGER 478 5.21.16 GATT Client Events 478 5.21.17 Short Message Events 479 5.21.17.1 RX_MSG 479 5.21.18 Common Bluethooth Terminology 480 5.22 Reserved (SIN 61, SIN 62, and SIN 63) 480 APPENDIX A SIN Values 481 APPENDIX B IsatData Pro Message Structure 483 APPENDIX C Posted Events Summary 487 APPENDIX D IP Service Application Examples 492 APPENDIX E Accelerometer Orientation Example 501 APPENDIX F Supported 1-Wire Families 503 APPENDIX G 1-Wire Sample Code 504 APPENDIX H 1-Wire Supported Devices 523 APPENDIX I 1-Wire Supported Strong Pull-up Device 524 APPENDIX J J1979 Introduction 525 APPENDIX K J1979 Response Message 528 APPENDIX L GATT Client Error Code 530 LIST OF FIGURES Figure 1: Terminal Software Architecture 32 Figure 2: Terminal Campaign States 373 Figure 3: ST 6000 Accelerometer Axis Ð Standard Orientation 405 Figure 4: ST 61xx Accelerometer Axis Ð Standard Orientation 405 Figure 5: ST 9100 Accelerometer Axis Ð Standard Orientation 406 Figure 6: Message Structure Syntax Diagram 484 LIST OF TABLES Table 1: Field Types Supported 178 Table 2: Property to Physical Port Connector Mapping 271 Table 3: RS-232 Port Differences 275 Table 4: External I/O Hardware Features 315 Table : External I/O Hardware Features (OEM Terminals) 316 Table 6: Port Configuration Details 316 Table 7: Terminal Campaign States Description 374 Table 8: Cellular Channel Limits 376 Table 9: Global Configuration 399 Table : Gravity Ranges 399 Table 11: Accelerometer Power Modes 399 Table 12: Event Detectors 400 Table 13: Typical SHOCK Thresholds 401 Table 14: MOTION Detector Configuration Parameters 402 Table : SHOCK Detector Configuration Parameters 402 Table 16: MOTION State Fields 403 Table 17: SHOCK State Fields 403 Table 18: Sample Installation Orientations 406 Table 19: Sleep Phase Durations 408 Table : sleepDuration Property Mapping 409 Table 21: ST 6000 and ST 6100 Sample Rates 414 Table 22: ST 6000 and ST 6100 sampleRate Property Mapping 414 Table 23: ST 9100 sampleRate Property Mapping 414 Table 24: ST 9100 Sample Rates 414 Table : Decoded Advertising / ScanResponse Data Type Fields 454 Table 26: Manufacturer Specific Data Fields 455 Table 27: ST Terminal Orientation Mapping Example (SIN 34) 501 Table 28: 11-bit OBD CAN IDs 525 Table 29: 29-bit OBD CAN IDs 526 Table : Service Request ID (same as Modes in the ODB-II specification) 526 Table 31: Example of Frequently used PIDs 526 Table 32: CAN Request Frame 527 Table 33: CAN Frame Type 527 Table 34: 11 Bit CAN ID Response Message Example (Service 09, PID 02) 528 Table 35: 29 Bit CAN ID Response Message Example (Service 01, PID 0D) 529 Table 36: Error Code Categories 530 Table 37: Error Codes 531 PREFACE Purpose This document is as an overview of the Lua code for terminals running firmware v4.x or higher, which is a key element of the embedded software that controls all of the product components. This document is for use with ST terminals, however some content in this document may not apply to all models. Terminals  ST 6100  ST 6000  Satellite-Cellular Terminals  ST 9100  Notation The epoch for ST products is midnight, January 1st, 1970. An epoch is a specific instance, date or year from which time is marked. The epoch then serves as a reference point from which time is measured. The time kept internally by software timekeeping systems is usually expressed as the number of seconds terminals have elapsed since a specified epoch. A forward message is a message sent to the terminal from the gateway (to-mobile), while a return message is one sent from the terminal (from-mobile). Items listed as reserved are for ORBCOMM use only. Reference The content of the following documents may be useful in conjunction with this guide. These documents are available from the ORBCOMM Developer Toolkit (hereafter referred to as the Toolkit) or from Customer Support. The names, numbers, and content of these documents are subject to change without notice. Always check the customer support website for the most current version of each document. [N207]  Software Over-the-Air (SOTA) User Guide  [T203]  IDP Modem Developer Guide  [T403]  AT Interface Developer Guide  [T404]  LSF Developer Guide for FW v4.x  [T406]  ST 6100 Hardware Guide  [T407]  ST 6000 Hardware Guide  [T413]  ST 9100 Hardware Guide  Refer to the embedded help file in each of the software tools for additional information. These tools are available from the Toolkit. 1 INTRODUCTION The ST products are designed to be integrated with the IsatData Pro gateway (Figure 1). The messaging system is designed to support the management of mobile or fixed assets over very wide areas. An asset fitted with one of the products can have its state and location monitored. ST products provide two-way communication for messaging to and from the asset for near real-time control. The network supports up to 6,399 byte from-mobile messages and up to 10,000 byte to-mobile messages. This document focuses on the Lua code that is a key element of the embedded software, which controls all the ST product components. The Lua code enables you to control the products. As requirements change the code can be reconfigured and redeployed. Lua coding can be simplified by using ORBCOMM software tools. 2 TERMINAL SOFTWARE ARCHITECTURE Most end-user functionality on the terminals is implemented by software constructs called services. Services are self-contained, individually addressable modules each offering well-defined functionality. This document details the various core and user services available on the terminals. Core services (Section 5) are the basic building blocks of functionality available on a terminal, most of which have network visibility. These building blocks include (but are not limited to) I/O accessibility, sending and receiving external messages via a desired communication channel, getting and reporting a position, querying status and configuration. Terminal apps are configurable device-level applications that include specific feature sets that are implemented by ORBCOMM . Contact ORBCOMM for a list of terminal apps. User services provide relatively complex or advanced functions. The terminal software allows custom application development (Lua scripting). Lua is the scripting language used because it is a proven, robust, embedded scripting language with many applications. Lua is a fast language engine with a small footprint that can easily be embedded into almost any application. The application programming interface (API) allows it to integrate with code written in other languages. Figure 1: Terminal Software Architecture The software stack may be loosely divided into three (3) fundamental layers, which are integrated together within a Lua framework: ¥ Hardware ¥ Application ¥ Network The hardware is separated from the application via a service call-able application programming interface (API). Services access hardware (for example, serial port, digital input, hardware timers) or other services through this API. Each service is implemented through a Lua application. Maximum flexibility is achieved by allowing for custom applications and services. In this model, a complex function could be created through a user programmable Lua application. Services are identified and registered through the network interface. The network interface accepts messages from services, formats these messages according to the particular network channel being used, and sends them via that channel. In the from-mobile direction, the network layer removes the channel-specific formatting and sends the from-mobile message to the appropriate service. This is accomplished through the use of terminal specific plug-ins as required. On power on or reset, basic hardware tests run and upon success, each of the core services (Section 5) is initialized and started based on their stored configuration. The Lua framework uses the available service and configuration information to register and synchronize with the network. On receipt of network acknowledgment, the transport queue is then emptied as required. In a very basic application, consider a terminal solely configured to generate a message when digital input 1 moves from low to high. On some terminals the external input/output (EIO) service may be configured (locally or remotely) to define port 1 as a digital input and to generate an alarm message on a low to high transition. The alarm destination may be specified as the transport layer that would accept the message, format it, send it, and finally notify the service of the delivery status. 3 LUA FIRMWARE EXTENSIONS 3.1 Global Functions 3.1.1 Base64 Library The base64 library is a firmware extension that supports base64 encoding/decoding of strings. 3.1.1.1 decode() Description Decodes a base64 encoded string and returns the decoded results. Syntax base64.decode(str) Parameters str Lua string containing base64 encoded data Returns string Decoded string Example Encodes ÒThis is a test messageÓ and then decodes and prints it. lua> print(base64.decode(base64.encode("This is a test message."))) This is a test message. See Also base64.encode() 3.1.1.2 encode() Description Returns the base64 encoding of a specified string. Syntax base64.encode(str) Parameters str Lua string to encode Returns string Base64 encoded string Example Displays the base 64 encoding of the string ÒHello worldÓ. shell> lua print(base64.encode("Hello world")) SGVsbG8gd29ybGQ= See Also base64.decode() 3.1.2 bit32 Library The bit32 library contains functions to perform bitwise manipulation of integers and is based on the Lua 5.2 alpha version of the library. This is included for backwards compatibility; Lua 5.3 has built-in bitwise operators. 3.1.2.1 arshift() Description Return the number value shifted disp bits to the right. Negative displacements shift to the left. The shift operation is an arithmetic shift. Vacant bits on the left are filled with copies of the higher bit of value; vacant bits on the right zeros. Displacements with absolute values higher than 31 result in zero or 0XFFFFFFFF (all original bits are shifted out). Syntax bit32.arshift(value, disp) Parameters value disp  Number to shift Displacement to shift (negative values shift left)  Returns integer  Shifted result  3.1.2.2 band()  Description  Return the bitwise and of all operands. Syntax bit32.band(É) Parameters É Numbers to and together Returns integer And of all operands 3.1.2.3 bnot() Description Return the bitwise negation of value. Syntax bit32.bnot(value) Parameters value Numbers to negate Returns integer Bitwise negation of value 3.1.2.4 bor() Description Return the bitwise or of all operands. Syntax bit32.bor(É) Parameters É Numbers to or together Returns integer Or of all operands 3.1.2.5 btest() Description Return true if the bitwise and of all operands is different from zero. Syntax bit32.btest(É) Parameters É Numbers to test Returns boolean true if bitwise and of all operands is different from zero 3.1.2.6 bxor() Description Return the bitwise exclusive or of all operands. Syntax bit32.bxor(É) Parameters É Numbers to exclusive or together Returns integer Exclusive or of all operands 3.1.2.7 lrotate() Description Returns the number value rotated disp bits to the left. Syntax bit32.lrotate(value, disp) Parameters value Number to rotate disp Displacement to rotate (negative values rotate right) Returns integer Rotated result 3.1.2.8 lshift() Description Returns the number value shifted disp bits to the left. Negative displacements shift to the right. In any direction, vacant bits are filled with zeros. Displacements with absolute values greater than 31 result in zero (all bits are shifted out). Syntax bit32.lshift(value, disp) Parameters  value  Number to shift  disp  Displacement to shift (negative values shift right)  Returns  integer  Shifted result  3.1.2.9 rrotate() Description Returns the number value rotated disp bits to the right. Syntax bit32.rrotate(value, disp) Parameters value Number to rotate disp Displacement to rotate (negative values rotate left) Returns integer Rotated result 3.1.2.10 rshift() Description Returns the number value shifted disp bits to the right. Negative displacements shift to the left. In any direction, vacant bits are filled with zeros. Displacements with absolute values greater than 31 result in zero (all bits are shifted out). Syntax bit32.rshift(value, disp) Parameters value Number to shift disp Displacement to shift (negative values shift left) Returns integer Shifted result 3.1.3 Debugging 3.1.3.1 trace() Description This command accepts arguments exactly like print(), except that instead of sending the output to the main RS-232 port, the output is sent to the firmware serial tracing facility. Syntax trace(É) Parameters É Zero or more Lua objects to print. If no arguments are specified, just a carriage return/line feed pair is output. Returns None Example Sends the output to the serial tracing channel, if it is configured. lua> trace("Current thread is: ", sched.getThread()) lua> See Also print() 3.1.3.2 tracef() Description This command accepts arguments exactly like printf(), except that instead of sending the output to the main RS-232 port, the output is sent to the firmware serial tracking facility. Syntax tracef(format, É) Parameters format String optionally containing format specifiers. É Zero or more arguments matching the format specifiers contained in the format argument. Returns None 3.1.4 Pickle Library The pickle library is used to serialize and deserialize Lua data structures. 3.1.4.1 dump Description Serializes a Lua data structure to a string, which is also written out to the given file. Syntax pickle.dump(object, filename) Parameters object filename  The Lua object to serialize The name of the file to write the serialized object to  Returns string  The serialized object  3.1.4.2 dumps  Description  Serializes a Lua data structure to a string. The string is Lua code, which can actually be loaded with loadstring (), and then subsequently run to produce the original object. Syntax pickle.dumps(object) Parameters object The Lua object to serialize Returns string The serialized object 3.1.4.3 load Description Deserializes a Lua data structure from a file. Syntax pickle.load( filename) Parameters filename The name of the file where the serialized Lua object is saved Returns object The original Lua object, or nil if the content of the file does not represent a valid Lua object 3.1.4.4 loads Description Deserializes a Lua data structure from a string. Syntax pickle.loads(serialized) Parameters serialized The string representing the serialized Lua object Returns object The original Lua object, or nil if the content of the file does not represent a valid Lua object 3.1.5 Serial Output 3.1.5.1 print() Description Receives any number of arguments and prints their values to the main serial port, if the shell is enabled. The Lua tostring() function is used on each argument to convert the arguments to strings before printing them, followed by a carriage return/line feed pair. This function is similar to the standard Lua print() function except that tab characters are NOT output between each item. Syntax print(É) Parameters É Zero or more Lua objects to print. If no arguments are specified, just a carriage return/line feed pair is output. Returns None Example lua> print("Current thread is: ", sched.getThread()) Current thread is: thread: 64050130 [lua nores chunk] See Also printf() 3.1.5.2 printf() Description Writes a sequence of data formatted as the format string argument specifies to the main serial port. After the format string argument, the function expects at least as many additional arguments as specified in the format string. Unlike print(), a trailing new-line is NOT output. The format uses the same specifiers as the standard Lua string.format(). Syntax printf(format, É) Parameters  format É  String optionally containing format specifiers. Zero or more arguments matching the format specifiers contained in the format argument.  Returns None  Example  lua> printf("%10s -0x%X\n", "abc", 123) abc -0x7B See Also print() 3.2 System Table The system table, or sys, is a Lua table that contains all functions and values exported by the application firmware. The following sections describe the top-level entries within this table. 3.2.1 bitmask 3.2.1.1 Bitmask Handle Methods 3.2.1.1.1 clear() Description Clears the specified bit. This function is a shortcut to <handle>:setval(bitnum, false). Syntax <handle>:clear(bitnum) Parameters bitnum The bit number. The function throws an error if the bit number exceeds the array size. Returns None 3.2.1.1.2 clearall() Description Clears all the bits in the array. Syntax <handle>:clearall() Parameters None Returns None 3.2.1.1.3 get() Description Get the specified bit value. Syntax <handle>:get(bitnum) Parameters bitnum The bit number. The function throws an error if the bit number exceeds the array size. Returns boolean Whether the bit is currently set (true) or cleared (false) 3.2.1.1.4 getall() Description This retrieves the entire bitmask as a string. Bit 7 of the first byte represents the first bit, bit 6 is second, and so on. Syntax <handle>:getall() Parameters None Returns string The entire bitmask 3.2.1.1.5 invert() Description Invert the specified bit. Syntax <handle>:invert(bitnum) Parameters bitnum The bit number. The function throws an error if the bit number exceeds the array size. Returns None 3.2.1.1.6 invertall() Description Invert all the bits in the array. Syntax <handle>:invertall() Parameters None Returns None 3.2.1.1.7 set() Description Set the specified bit. This function is a shortcut to <handle>:setval(bitnum, true). Syntax <handle>:set(bitnum) Parameters bitnum The bit number. The function throws an error if the bit number exceeds the array size. Returns None 3.2.1.1.8 setall() Description Sets all the bits in the array. Syntax <handle>:setall() Parameters None Returns None 3.2.1.1.9 setval() Description Set the specified bit to the given value. Syntax <handle>:setval(bitnum, val) Parameters bitnum The bit number. The function throws an error if the bit number exceeds the array size. val The value to set. Zero (0) clears the bit, any other number sets it; otherwise, true/false can also be used to set/clear the bit. Returns None 3.2.1.2 create() Description Create a bitmask that holds an array of bit values (true/false). Syntax sys.bitmask.create(sizeOrContent) Parameters  sizeOrContent This is either a number, to indicate the number of bits to be stored in the array, or a string. If the first option is used, all bits are initialized to false. If the second one is used, each byte in the string represents 8 bits, with the most significant bit used first.  Returns  handle A handle to access the bitmask functions. The bitmask elements are accessed or modified with a zero-based bit index. Examples Create a bitmask with space for 10 bits. local bitmask = sys.bitmask.create(10) Create a bitmask with 16 bits, where bits 0 and 9 are true, and all others are false. local bitmask = sys.bitmask.create(string.char(0x80, 0x40)) 3.2.2 buffer 3.2.2.1 Buffer Handle Methods 3.2.2.1.1 addBits() Description Adds the given number of bits to the buffer. Syntax <handle>:addBits(val, bits) Parameters val The least significant bits of this integer are the bits to add, up to 32; because Lua only supports signed integers. 32-bit values must be passed in as negative or hexadecimal numbers. bits The number of bits to add, up to 32 Returns boolean true if there is enough space left for the bits; false otherwise Example Add 2 bits (binary 11) to the buffer. local buffer = sys.buffer.create(100) local result = buffer:addBits(3, 2) Add 32 bits (binary 11110000000000000000000000000000) to the buffer. local buffer = sys.buffer.create(100) local result = buffer:addBits(0xF0000000, 32) Prints false, because it is trying to add 32 bits (4 bytes) to a buffer that only has space for 3 bytes. local buffer = sys.buffer.create(3) local result = buffer:addBits(0xF0000000, 32) print(result) 3.2.2.1.2 addFloat() Description This adds a single-precision floating point value to the byte stream in IEEE 754 format. Syntax <handle>:addFloat(value, lowWordFirst, littleEndian) Parameters  value  The floating point value to add to the byte stream  lowWordFirst  Whether to add the low word first (optional, default is false)  littleEndian  Whether to add the value in little-endian or big-endian format (optional, default is false)  Returns  boolean  true if there is enough space left for the data; false otherwise  3.2.2.1.3 addInt16() Description This adds a 16-bit integer value to the byte stream. Syntax <handle>:addInt16(value, isSigned, littleEndian) Parameters value The 16-bit value to add to the byte stream (-32768 to 32767 for signed, 0 to 65535 for unsigned) isSigned Whether the value is signed or not littleEndian Whether to add the value in little-endian or big-endian format (optional, default is false) Returns boolean true if there is enough space left for the data; false otherwise Example Examples for this function can be found in Section 3.2.15. 3.2.2.1.4 addInt32() Description This adds a 32-bit integer value to the byte stream. Syntax <handle>:addInt32(value, lowWordFirst, littleEndian) Parameters  value  The 32-bit value to add to the byte stream  lowWordFirst  Whether to add the low word first (optional, default is false)  littleEndian  Whether to add the value in little-endian or big-endian format (optional, default is false)  Returns  boolean  true if there is enough space left for the data; false otherwise  Example  Examples for this function can be found in Section 3.2.15. 3.2.2.1.5 addString() Description Adds the given bytes to the buffer. Syntax <handle>:addString(val) Parameters val The bytes to add to the buffer (string) Returns boolean true if there is enough space left for the bits; false otherwise Example Add 4 bytes to the buffer local buffer = sys.buffer.create(100) local result = buffer:addString(string.char(0xEE, 0xEF, 0xF0, 0xF1)) Prints false, because it is trying to add 5 bytes to a buffer that only has space for 4.5 bytes local buffer = sys.buffer.create(6) local result = buffer:addBits(0xFFF, 12) result = buffer:addString("hello") print(result) 3.2.2.1.6 clear() Description This empties the buffer so it can be reused. Syntax <handle>:clear() Parameters None Returns boolean Indicates success or failure 3.2.2.1.7 getBits() Description Gets the specified number bits from the byte stream. Syntax <handle>:getBits(bits) Parameters bits The number of bits to get, up to 32 Returns integer The retrieved bits, or nil if there are not enough bits left Example Retrieve the first 12 bits from the buffer (hexadecimal FED). local buffer = sys.buffer.create(string.char(0xFE, 0xDC)) local result = buffer:getBits(12) Retrieve the first 12 bits (hexadecimal FED), then the next 3 bits (binary 110). local buffer = sys.buffer.create(string.char(0xFE, 0xDC)) local result = buffer:getBits(12) result = buffer:getBits(3) Prints nil, because it is trying to get 17 total bits from a buffer that only contains 16. local buffer = sys.buffer.create(string.char(0xFE, 0xDC)) local result = buffer:getBits(12) result = buffer:getBits(5) print(result) 3.2.2.1.8 getFloat() Description This gets a single-precision floating point value from the byte stream in IEEE 754 format. Syntax <handle>:getFloat(lowWordFirst, littleEndian) Parameters  lowWordFirst  Whether the value is low word first (optional, default is false)  littleEndian  Whether the value is in little-endian or big-endian format (optional, default is false)  Returns  number The retrieved floating point value, or nil if there are not enough bits left  3.2.2.1.9 getInt16() Description This gets a 16-bit integer value from the byte stream. Syntax <handle>:getInt16(isSigned, littleEndian) Parameters isSigned Whether the value is signed or not littleEndian Whether the value is in little-endian or big-endian format (optional, default is false) Returns integer The retrieved 16-bit value, or nil if there are not enough bits left (-32768 to 32767 for signed, 0 to 65535 for unsigned) Example Examples for this function can be found in Section 3.2.15. 3.2.2.1.10 getInt32() Description This gets a 32-bit integer value from the byte stream. Syntax <handle>:getInt32(lowWordFirst, littleEndian) Parameters  lowWordFirst  Whether the value is low word first (optional, default is false)  littleEndian  Whether the value is in little-endian or big-endian format (optional, default is false)  Returns  integer The retrieved 32-bit value, or nil if there are not enough bits left  Example  Examples for this function can be found in Section 3.2.15. 3.2.2.1.11 getString() Description Retrieves the specified number of bytes from the buffer. Syntax <handle>:getString(len) Parameters len The number of bytes to retrieve, or nil to get the rest of the buffer Returns string The retrieved bytes, or nil if there are not enough bytes left number If getString is called with nil, returns the total bit length of the bytes Example Print hel. local buffer = sys.buffer.create("hello") print(buffer:getString(3)) Retrieve the first 4 bits (hexadecimal F) and the next two bytes, 0xED and 0xCB. local buffer = sys.buffer.create(string.char(0xFE, 0xDC, 0xBA)) local result = buffer:getBits(4) result = buffer:getString(2) Retrieve the first 4 bits (hexadecimal F) and the next two and a half bytes, 0xED, 0xCB and 0xA0. local buffer = sys.buffer.create(string.char(0xFE, 0xDC, 0xBA)) local result = buffer:getBits(4) result = buffer:getString() Create a buffer with space for up to 100 bytes, then add some bits and bytes to it, and finally retrieve the resulting byte stream. local buffer = sys.buffer.create(100) buffer:addBits(..., ...) buffer:addBits(..., ...) buffer:addString(...) buffer:addBits(..., ...) local result = buffer:getString() 3.2.2.2 create() Description This creates a bit buffer, which is useful for getting bits into or out of a byte stream. It supports two different modes of operation. ¥ Create an empty buffer by specifying the maximum size it can contain, then add bits and bytes to it, and finally retrieve the resulting byte stream at the end. ¥ Create a buffer from an existing byte stream (string), and retrieve bits and bytes out of it. Syntax sys.buffer.create(size_or_string) Parameters size_or_string If an integer, specifies the maximum size of an empty buffer in bytes, if a string, specifies the initial buffer content Returns handle A handle to access the buffer 3.2.3 crc16() Description Calculates the 16-bit CCITT CRC of the given string. Syntax sys.crc16(data, seed) Parameters data The string for which a CRC is needed seed Optional integer seed (default is 0xFFFF) Returns integer The resulting 16-bit CRC 3.2.4 createTable() Description Creates a new empty table, optionally with space preallocated for array elements (indexed with a positive integer), and nonarray elements. This preallocation is useful when the number of elements in the table is known ahead of time. Syntax sys.createTable(narray, nrec) Parameters  narray  The number of array entries in the table; defaults to 0  nrec  The number of nonarray entries in the table; defaults to 0  Returns table The new table 3.2.5 csum16() Description Calculates the 16-bit checksum value of the bytes in the given string. Syntax sys.csum16(data, sum, offset, len) Parameters data The string for which a checksum is needed sum The starting sum value (optional -default is 0). This is useful when calculating a checksum over several different strings; the checksum of a previous one can be passed in as a starting point for another. offset The offset within the string at which to start calculating the checksum (optional .default is 0). This indicates the number of bytes, at the beginning of the string, to exclude in the checksum calculation. len The number of bytes to include in the checksum calculation (optional -default is the number of bytes from offset to the end of data). If the requested number of bytes is greater than what is available, then len is decremented accordingly. Returns integer The resulting 16-bit checksum 3.2.6 csum16w() Description Calculates the 16-bit checksum value of the words in the given string. Each word must be placed in the string with the most significant byte first. If the string contains an odd number of bytes, or the specified length is an odd number, then the extra byte is assumed to be 0. Syntax sys.csum16w(data, sum, offset, len) Parameters  data  The string for which a checksum is needed  sum  The starting sum value (optional -default is 0). This is useful when calculating a checksum over several different strings; the checksum of a previous one can be passed in as a starting point for another.  offset  The offset within the string at which to start calculating the checksum (optional -default is 0). This indicates the number of bytes, at the beginning of the string, to exclude in the checksum calculation.  len  The number of bytes to include in the checksum calculation (optional -default is the number of bytes from offset to the end of data). If the requested number of bytes is greater than what is available, then len is decremented accordingly.  Returns integer The resulting 16-bit checksum integer The accumulated sum. If a checksum needs to be calculated over different strings, this value can be passed as the second argument to a subsequent csum16w() call. 3.2.7 fs The file system where LSF code can store files is limited in the amount of space available. The listv shell command displays the total space available, as well as the current usage. However, there is another limit placed on the file system that is not quite as evident. The total number of entries (directories and files) that can be created is also constrained. The file system is limited to 1661 entries. Furthermore, any entries whose name exceeds 13 characters actually count as more than 1 against this limit. The following table summarizes this. Care should be taken when choosing file names. The limit can be quickly reached on systems where there are many files with long file names. Note: Only five (5) files can be open at the same time. 3.2.7.1 ATTR_DIRECTORY Attribute value that indicates a directory. 3.2.7.2 ATTR_READ_ONLY Attribute value that indicates a read-only object. 3.2.7.3 basename() Description This returns the base name of path; that is, the portion of the path name after the last directory separator. Syntax sys.fs.basename(pathname) Parameters  pathname  The file/directory path name  Returns  string  The base name  Example  Prints main.lua.  print(sys.fs.basename("/act/svc/geofence/main.lua")) Prints foo. print(sys.fs.basename("foo")) 3.2.7.4 chdir() Description This changes the current working directory to the specified one. All subsequent relative paths are based off of this one. Syntax sys.fs.chdir(path) Parameters path The directory path name Returns boolean Indicates success or failure string An error message if the first return value is false; nil otherwise 3.2.7.5 copy() Description This copies the source file to the destination file/directory. This function blocks the Lua scheduler while running, so it could trigger the watchdog or add extra latency to the system. Syntax sys.fs.copy(src, dest) Parameters src The source file dest The destination file/directory Returns boolean Indicates success or failure string An error message if the first return value is false; nil otherwise Example Copy the file file.txt from the /path1 directory to the /path2 directory. sys.fs.copy("/path1/file.txt", "/path2/") Copy the file file.txt from the path /path1 to the file foo in the/path2 directory. sys.fs.copy("/path1/file.txt", "/path2/foo") 3.2.7.6 dir() Description This function returns a directory iterator (like ipairs), which can be used to traverse the contents of a directory. The iterator function returned by dir() returns the following on each iteration: name  Directory entry name  size  Size of directory entry in bytes  attr  Bitmap attributes of the entry (see info() for details)  fileTime  The file creation time in number of seconds since the epoch  Syntax sys.fs.dir(path) Parameters path Optional directory path name string. If not provided, the current directory is used Returns  iterator  Directory iterator function  handle  Directory handle  Example The shell extension code below displays the contents of a directory similar to the LSF shell. local function dirCmd(args) if #args == 1 and args[1] == '?' then print("Usage: dir [<dirpath>]") else local totalSize = 0 local fileCount = 0 for name,size,attr,mtime in sys.fs.dir(args[1]) do local typeStr if bit32.band(attr, sys.fs.ATTR_DIRECTORY) == 0 then typeStr = " " fileCount = fileCount + 1 else typeStr = "(Dir)" end printf("%s %8d %s %s\n", typeStr, size, os.date('%d/%m/%Y %X', mtime), name) totalSize = totalSize + size end printf("Found %d files using a total of %d bytes.\n", fileCount, totalSize) end end 3.2.7.7 expand() Description This expands a relative file/directory path name into an absolute path name. Syntax sys.fs.expand(pathname) Parameters pathname The file/directory path name to expand Returns string The expanded path name Example Print /some/path/file.txt. sys.fs.chdir("/some/path/") print(sys.fs.expand("file.txt")) 3.2.7.8 getcwd() Description This returns the current working directory. Syntax sys.fs.getcwd() Parameters None Returns string The current working directory 3.2.7.9 info() Description This returns information about the given file/directory path name. Syntax sys.fs.info(pathname) Parameters pathname The file/directory to get information about Returns boolean Indicates success or failure table A table with the following fields if the previous value is true: attr A bitmap of the file attributes 0x01 Ð Read-only 0x10 Ð Directory size The file size, in bytes, or 0 if it is a directory fileTime The file creation time; number of seconds since the epoch 3.2.7.10 isdir() Description This returns whether the given path name is a directory. Syntax sys.fs.isdir(pathname) Parameters  pathname  The path name to check  Returns  boolean  true if the path name is a directory; false otherwise  3.2.7.11 md5()  Description  This returns the MD5 hash for the given file/directory. Syntax sys.fs.md5(pathname) Parameters pathname The file/directory path name Returns string A 16 character string representing the MD5 has of the file content, or nil if the path name is a directory or does not exist 3.2.7.12 mkdir() Description This creates a directory. Syntax sys.fs.mkdir(path) Parameters path The directory path name Returns boolean Indicates success or failure string An error message if the first value is false 3.2.7.13 numvols() Description This returns the number of volumes available. Syntax sys.fs.numvols() Parameters None Returns integer The number of available volumes 3.2.7.14 rmdir() Description This function removes directory entries. The directory to be removed must be empty if the recurse Boolean option is false or missing. If the recurse Boolean option is true then rmdir() recursively deletes all subdirectories and their contents. Syntax sys.fs.rmdir(path, recurse) Parameters  path  Directory path to remove  recurse  Optional Boolean to recursively remove directory entries if true  Returns boolean Indicates success or failure string An error message if the first return value is false; nil otherwise 3.2.7.15 truncate() Description This truncates a file to the given size. Syntax sys.fs.truncate(pathname, size) Parameters pathname The file path name size The desired file size Returns boolean Indicates success or failure 3.2.7.16 volinfo() Description This returns information about the given volume. Syntax sys.fs.volinfo(volumeID) Parameters volumeID This is an integer identifying the volume; it ranges from 1 to the value returned by fs.numvols() .1 Returns table A table with the following fields: name The volume name size The total volume size in bytes free The free space on the volume in bytes bytesPerSector The number of bytes per sector sectorsPerCluster The number of sectors per cluster totalClusters The total number of clusters in the volume freeClusters The number of unused clusters in the volume maxDirEntries The maximum number of directory entries the volume supports freeDirEntries The number of unused directory entries in the volume 3.2.8 heapInfo Description This returns a table with information about the current state of the heap. Syntax sys.heapInfo() Parameters None Returns table A structure with the following fields: size The total heap size (bytes) used The amount of the heap in use (bytes) free The amount of free heap space (bytes) freeFragments A structure with the number of free fragments by size: [1] Number of fragments ² 16 bytes [2] Number of fragments > 16 and ² 32 bytes [3] Number of fragments > 32 and ² 64 bytes [4] Number of fragments > 64 and ² 128 bytes [5] Number of fragments > 128 and ² 256 bytes [6] Number of fragments > 256 and ² 512 bytes [7] Number of fragments > 512 and ² 1024 bytes [8] Number of fragments > 1024 and ² 2048 bytes [9] Number of fragments > 2048 and ² 4096 bytes [10] Number of fragments > 4096 and ² 8192 bytes [11] Number of fragments > 8192 and ² 16384 bytes [12] Number of fragments > 16384 and ² 32768 bytes [13] Number of fragments > 32768 and ² 65536 bytes [14] Number of fragments > 65536 and ² 131072 bytes [15] Number of fragments > 131072 and ² 262144 bytes [16] Number of fragments > 262144 and ² 524288 bytes [17] Number of fragments > 524288 and ² 1048576 bytes [18] Number of fragments > 1048576 and ² 2097152 bytes [19] Number of fragments > 2097152 and ² 4194304 bytes [20] Number of fragments > 4194304 and ² 8388608 bytes [21] Number of fragments > 8388608 and ² 16777216 bytes fragTotal Total size of all fragments (bytes) topSize Size of nonfragmented block at the top of memory (bytes) 3.2.9 info Description The sys.info global table, below, includes a Bluetooth table under sys.info.bluetooth. The table below contains static information about the ST product and has the fields shown. 1Aux is only available on some models. Field Field Type Description BOOT_VERSION MAJOR INTEGER Boot loader major version MINOR INTEGER Boot loader minor version PATCH_LEVEL INTEGER Boot loader patch level REVISION INTEGER Boot loader revision number BUILD_TIME STRING Time the boot loader was built BUILD_DATE STRING Date the boot loader was built APPL_VERSION MAJOR INTEGER Application major version MINOR INTEGER Application minor version PATCH_LEVEL INTEGER Application patch level REVISION INTEGER Application loader revision number BUILD_TIME STRING Time the application was built BUILD_DATE STRING Date the application was built HARDWARE DEVICE_ADDRESS_TYPE INTEGER Device address type (see addrType) DEVICE_ADDRESS STRING 48-bit device address SOFT_DEVICE_VERSION INTEGER Version of the internal protocol stack BLUETOOTH_VERSION STRING Bluetooth protocol version Syntax sys.info.bluetooth Example sys.info = { bluetooth = { APPL_VERSION = { REVISION = 21094 BUILD_TIME = "13:54:11" MAJOR = 2 PATCH_LEVEL = 0 BUILD_DATE = "Mar 12 2020" MINOR = 6 } HARDWARE = { DEVICE_ADDRESS_TYPE = 1 BLUETOOTH_VERSION = "5.0" SOFT_DEVICE_VERSION = 182 DEVICE_ADDRESS = "D4:4D:3F:87:8D:6C" } BOOT_VERSION = { REVISION = 21082 BUILD_TIME = "09:50:04" MAJOR = 2 PATCH_LEVEL = 0 BUILD_DATE = "Mar 11 2020" MINOR = 2 } } HARDWARE = { MANUFACTURING_ID = "Test" PROCESSOR_CLOCK = 120 REVISION = 2 REVISION_MAJOR = 2 VARIANT = 10 FS_FLASH_DEVICE = "W25Q128JV-IM" FEATUREMASK = "\0\0\0\0\0\0\8\0" VARIANT_STRING = "ST9" RESET_REASON = 6 UNIQUEID = "0001FFFFFFFFFFFF4E45529930100014" FUNCTIONMASK = "0000000000000000" REVISION_MINOR = 0 RESET_REASON_STRING = "SOFTWARE" } HEAP_SIZE = 7864320 CONSOLE_CHANNEL = "main" APPL_VERSION = { REVISION = 21096 BUILD_TIME = "15:31:46" BUILD_DATE = "Mar 13 2020" MAJOR = 4 PATCH_LEVEL = 0 DESCRIPTION = "Debug" MINOR = 1 } BOOT_VERSION = { REVISION = 0 BUILD_TIME = "10:53:19" BUILD_DATE = "Mar 17 2020" MAJOR = 4 PATCH_LEVEL = 0 DESCRIPTION = "Debug" MINOR = 1 } SOFTWARE = { RESET_DESCRIPTION = "" RESET_REASON_STRING = "CONSOLE" RESET_REASON = 11 } } 3.2.10 J1587 3.2.10.1 J1587 event Description This event is posted if a response message is available after a request. Source Ò_J1587Ó (string) Event string ÒOnRequestÓ Arguments Event Return Atableofresponsesfortherequestedmessage. mid Number pid Number data A string of message data Example Example of a read vehicle identification number. local jbusQ = sched.createEventQ(1,"_J1587") jbus:request(128,237) local _,_ msg = jbusQ:wait(-1) printf("VIN=%s\nÓ, msg.data) jbusQ:destroy() 3.2.10.2 J1587 Handle Methods The following methods can be used on the handle returned by sys.J1587.open() 3.2.10.2.1 add() Description This method adds message identification (MID) and its parameter identification (PID) to the APIs receiving filter table. After J1587 is opened, all receive messages are disabled; this call is to set a specified parameter that will be accepted. Syntax handle:add(mid, pid) Parameters  mid pid  Message identification (MID) number to assigned. MID range is 128 Ð 255. Parameter identification (PID) number to be assigned. PID range is 0 Ð 511.  Returns  string  Nil if success. A description of the error if failure.  Example --Add PIDs receiving table local function j1587AddPIDs() jbus:add(128,84) --For road speed from engine #1 jbus:add(136,84) --For road speed from ABS jbus:add(128,96) --For fuel level jbus:add(128,100) -ÐFor engine oil pressure jbus:add(128,244) --For trip distance end 3.2.10.2.2 captureOff() Description This function ends capturing J1587 activities. Syntax handle:captureOff() Parameters None Returns list A table of list mid Number pid Number counts Number Example Local stat = jbus:captureOff() if (stat) then for _,v in ipairs(stat) do printf("MID:%d, PID:%d, Counts:%d \n",v.mid,v.pid,v.counts) end end 3.2.10.2.3 captureOn() Description This function starts capturing J1587 bus activities. Recalling this method resets counting. Syntax handle:captureOn() Parameters None Returns None Example jbus:captureOn() 3.2.10.2.4 clean() Description This function empties the receiving table. Syntax handle:clean() Parameters None Returns None Example jbus:clean() --Empty the PID table 3.2.10.2.5 close() Description This function closes the J1587 service. Syntax handle:close() Parameters None Returns None Example jbus:close() jbus=nil collectgarbage() 3.2.10.2.6 list() Description A list of message identification (MID) numbers and parameter identification (PID) numbers in receiving filter table. Syntax handle:list() Parameters None Returns list A MID and PID array table. mid Number pid Number Example List all PIDs in the current list. local list = jbus:list() if (list) then for _,v in ipairs(list) do printf("MID:%d, PID:%d\n",v.mid,v.pid) end end 3.2.10.2.7 remove() Description This function removes a parameter identification (PID) number from the receiving list. Syntax handle:remove(mid, pid) Parameters  mid  MID number to be assigned. MID range is 128 Ð 255.  pid  PID number  Returns rstr A string description of the error. Nil if no error. Example jbus:remove(128,127) --remove oil pressure PID on engine #1 3.2.10.2.8 request() Description This function is used to get an on request parameter. It sends a request parameter message to J1708 bus. Later on, the firmware posts an event if data is available. Syntax handle:request(mid, pid) Parameters mid MID number to be assigned. MID range is 128 Ð 255. pid PID number to be assigned Returns string Nil if success. A description of the error if failure. Note: Only one request is available at a time. A new request replaces an old request. Example: local jbusQ = sched.createEventQ(1,"_J1587") jbus:request(128,237) local _,_ msg = jbusQ:wait(-1) printf("VIN=%s\nÓ, msg.data) jbusQ:destroy() 3.2.10.2.9 query() Description To query the latest parameter, the message identification (MID) number and parameter identification (PID) number have to be added to the receiving table before querying. Syntax handle:query(mid, pid) Parameters mid MID number to be assigned. MID range is 128 Ð 255 pid PID number to be assigned Returns msg A message table. Nil if MID/PID is not in the list or data is not available data A string of variable length data timestamp Integer timestamp in 0.1 second. Note: If connection is not lost, timestamp could be used as counter divided by update rate from 1 to 100 (0.1s to 10s). Examples Get a trip distance and dump raw data. local msg = jbus:query(128,244) -ÐTrip distance if (msg) then printf("time:%d, raw data:\n",msg.timestamp) for i=1,msg.data:len() do printf("%02X ",msg.data:byte(i)) end print("\n") else print("Data is not available \n") end Get the road speed. local speed = jbus:query(128,84) --Dump road speed printf("Vehicle speed:%3.2f KM/H (%3.1f miles/H)\n", speed.data:byte(1) * 0.805, speed.data:byte(1) * 0.5) 3.2.10.3 open() Description This function opens the J1587 interface. Syntax sys.J1587.open() Parameters None Returns handle A handle to access the rest of the API functions if no error. rstr A string description of the error. Nil if no error. Example Open the J1587 interface. If success the handle is saved to ÒjbusÓ. if (sys.J1587) then --open J1587 interface jbus,rstr = sys.J1587.open() if (jbus) then --success print(J1587 port is opened") else --used by others print(rstr) end end 3.2.11 J1939 Lua Firmware Extensions The hardware supports a CAN controller with 14 PGN filter banks. The IsatData Pro system library provides a way to get PGN data on a query basis. ¥ It only keeps the latest data on each specified PGN ¥ Uses Broadcast Announcement Message (BAM) for multipacket communications ¥ A total of 14 PGN filter entries are available with 1 filter is reserved for requests and one for multipacket BAM messages and address management. ¥ PGN messages through BAM have a maximum data size of 512 bytes ¥ Each successful query returns the PGN and an 8-byte data buffer or up to 64 bytes if it is a fast packet used by the NMEA 2000 protocol (NMEA 2000 is a replacement for NMEA 0183 and is based on SAE1939 format). ¥ To request a PGN, an event Ò_J1939Ó is triggered if PGN data is received These are the Lua extensions available in the framework. The following extensions can be found in sys.J1939. 3.2.11.1 captureOff() Description Stops capturing J1939 activities and/or gets the PGN list. Syntax <handle>:J1939.captureOff() Parameters None Returns  list  pgn counts sa  A table of list: The pgn number The number of occurrences Source address (ECU ID) of the sender  Example Local stat = sys.J1939.captureOff() if (stat) then for _,v in ipairs(stat) do printf("pgn:%d, sa:%d, counts:%d \n",v.pgn, v.sa, v.counts) end end 3.2.11.2 captureOn() Description Starts capturing J1939 activities. Initially the interface is closed and then the API runs a special collection mode. This function does not filter PGNs on the bus, it collects all broadcasting PGNs. Syntax <handle>:J1939.captureOn(device, baud, extID, listenOnly) Parameters device baud  Specify which device to use. This is currently ignored; the function always opens CAN1. (optional) Specify which baud rate to use (ST 6xxx). Default is 250K.  0 Ð 1M 1 Ð 800K 2 Ð 500K 3 Ð 250K 4 Ð 125K 5 Ð 100K 6 Ð 50K 7 Ð 20K 8 Ð 10K  extID listenOnly  (optional) Specify extended IDs (29-bit) if true, otherwise standard 11-bit IDs (ST 6xxx). Default is true. (optional) Allow listenOnly mode to be used or not (ST 6xxx). Default is true.  Returns  true  If successful  OR  false  If unsuccessful  errStr  Error string  Example  Ok,err = sys.J1939.captureOn() 3.2.11.3 J1939 Handle Methods The following methods can be used on the handle returned by sys.J1939.open(). 3.2.11.3.1 add() Description Adds a parameter group number (PGN) to the filer table for CAN monitoring. After the CAN port is opened, all receiving messages are filtered out; this call configures CAN so that the specified messages are accepted. If connected to an NMEA 2000 bus, a fast packet message can be received in addition to a single frame 8-byte message. The application must set the PGN type if it is a fast packet (even if it is less than 8 bytes of data), otherwise the API treats it as a regular message and the data could be corrupted. The API defines the maximum fast packet size as 64 bytes. The default method of transmitting multiframe parameter groups in NMEA 2000 is using the fast packet protocol. For NMEA 2000, it is possible that multiple ECUs broadcast the same PGN with different instances; rapid update (broadcast) rate may overwrite previous instance of data before querying. An optional parameter can be used to filter specific data instance, this instance or source ID is defined in the first byte of the PGN data field. For example, Engine, Rudder, Transmission, Switch Bank, AC, Fluid, Charger, Battery, Inverter, AGS and Source IDs. Syntax <handle>:add(pgn,type,ext) Parameters pgn PGN to be assigned type (optional) 1 -Fast packet (used by most NMEA 2000 PGNs). If 0 or nil, it is standard. ext (optional) The extension parameter to PGN ranges from 0 to 255 used for NMEA 2000. It is the first byte (8 bits) of data. If nil or 255, this setting is ignored. Returns string Nil if success. A description of the error if failure Example --Add PGNs to filter table local function j1939AddPGNs() canPort:add(61444) --For engine speed canPort:add(65248) --For trip distance and odometer canPort:add(65265) --For vehicle speed canPort:add(65266) --For fuel rate and fuel economy canPort:add(65271) --For battery voltages canPort:add(65276) --For fuel level(percent) end --NMEA 2000 Trip Fuel Consumption, Vessel. Fast packet. canPort:add(127496,1) Note: type and ext must be used on NMEA 2000 PGNs if needed. Applying these options to regular J1939 PGNs may return unexpected results. Note: Each PGN frame type is well defined in the NMEA 2000 document. Applications must follow the document requirements to set PGN types, otherwise unexpected result can occur. Note: The NMEA 2000 PGN filter must be unique. Two filters may have the same PGN and a different ext. For example, Engine parameters, dynamic, fast packet: canPort:add(127489,1,0) --Engine instance 0 canPort:add(127489,1,1) --Engine instance 1 --Or canPort:add(127489,1) --if there is only one engine or donÕt care Engine Parameters, Rapid Update, Single Frame canPort:add(127489,1) --All Engine(if more than one), or donÕt care. canPort:add(127489,1,1) Ð Incorrect. Above setting covers engine 1 The setting below is duplicated: canPort:add(127489,1) --All Engine(if more than one), or donÕt care. canPort:add(127489,1,1) Ð Incorrect. Above setting covers engine 1 3.2.11.3.2 close() Description Closes the specified interface. Syntax <handle>:close() Parameters None Returns None Example canPort:close() 3.2.11.3.3 flush() Description Flushes out the parameter group number (PGN) buffer from the interface. If PGN is zero, flushes out all PGN data buffer in the filter table. This function lets Lua flush out stale data and wait for an update. If there is no update available, querying PGN returns nil. Syntax <handle>:flush(pgn) Parameters  pgn  PGN or 0  ext  (optional) the extension parameter to PGN ranges from 0 to 255 used for NMEA 2000. It is the first byte  (8 bits) of data if nil or 255, ext setting is ignored.  Returns  None  Example  canPort:flush(0) --reset all PGN data to default invalid. 3.2.11.3.4 list() Description Lists the parameter group numbers (PGN) in a filter table. Syntax <handle>:list() Parameters None Returns list A PGN array Example List all PGNs in current filter list. local list = canPort:list() if (list) then for _,v in ipairs(list) do printf("PGN:%d\n",v) end end 3.2.11.3.5 list_ext() Description Lists the PGNs with type and extension parameter. This method can be used to list NMEA 2000 filter table settings. Syntax <handle>:list_ext() Parameters None Returns list A PGN array Example This example lists all PGNs in the current filter list. local list = canPort:list_ext() if (list) then for _,v in ipairs(list) do printf("PGN:%d Fast Type:%d Data Instance: %d\n",v.pgn, v.type, v.ext) end end 3.2.11.3.6 query() Description Queries the latest parameter group number (PGN) raw data by specified PGN. Syntax <handle>:query(pgn, ext) Parameters  pgn  PGN to be queried  ext  (optional) the extension parameter to PGN ranges from 0 to 255 used for NMEA 2000. It is the first byte  (8 bits) of data if nil or 255, ext setting is ignored.  Returns rpgn The queried PGN. Returns nil if the PGN data is not available or if the PGN is not in the filter list. data 8-byte data buffer. Or variable size of data buffer if it is a fast packet. seq The sequence number of received PGN data (0 Ð 65535). If two queries have the same sequence number no new data is updated. sa Source address (ECU ID) of the sender. Example Check coolant temperature and dump its raw data. Local rpgn,dstr,sa = canPort:query(65262) --coolant temp if (rpgn) then printf("PGN %d sa %d, raw data:",rpgn,sa) printf("%02X %02X %02X %02X %02X %02X %02X %02X\n", dstr:byte(1),dstr:byte(2),dstr:byte(3),dstr:byte(4), dstr:byte(5),dstr:byte(6),dstr:byte(7),dstr:byte(8)) else print("pgn is not in filter list\n") end Fleet management needs converting raw data to measured speed. Local rpgn,dstr = canPort:query(65265) --val = (byte(3)<<8) | byte(2) local val = bit32.bor( bit32.lshift(dstr:byte(3),8),dstr:byte(2)) --Convert to speed val = val/256 --Dump printf("PGN:%3.2f, Vehicle speed:%3.2f KM/H (%d miles/H)\n", rpgn,val, val/1.60934) end NMEA 2000 data: canPort:query(127489,1) --Engine instance 1 parameters 3.2.11.3.7 queryBAM() Description Queries BAM data. The parameter group number (PGN) is defined using the setBAM() method. This method only applies to broadcasting BAM. it returns the last received BAM data. For Òon requestÓ BAM, the application uses the Ò_J1939Ó event to receive the requested data. LUA also keeps the data in this query buffer if it is available. Syntax <handle>:queryBAM() Parameters None Returns pgn The queried PGN, or nil if no data is available size 512 bytes data Variable length data buffer seq Sequence number of received PGN data(0 Ð 65535). If two queries have a same sequence number no new data is updated. sa Source address (ECU ID) of the sender. Examples To monitor multiple BAMs, the application may change PGNs at different time slots. local pgn,size,data,seq,sa = canPort:queryBAM() if (pgn) then printf("PGN %d(sa%d,seq %d), size %d,raw data:\n",pgn,sa,seq,size) for i=1,size do printf("%02X ",data:byte(i)) end print("\n") else print("PGN data is not available \n") end 3.2.11.3.8 remove() Description Removes a parameter group number (PGN) from a filter table. If the PGN is zero, the filter table is emptied. Syntax <handle>:remove(pgn, ext) Parameters  pgn  PGN or 0  ext  (optional) the extension parameter to PGN ranges from 0 to 255 used for NMEA 2000. It is the first  byte (8 bits) of data if nil or 255, ext setting is ignored.  Returns None Example canPort:remove(65263) --remove oil pressure PGN And canPort:remove(127489,1) --NMEA2000.remove Engine instance 1 filter And canPort:remove(0) --Empty the PGN filter table 3.2.11.3.9 request() Description Many PGNs support data query, these PGNs are not usually broadcast or updated at a low rate. To get data for these PGNs, the application must issue a request (through ISO GPN 59904). Electronic control units (ECUs) send the data to the bus if the PGN is valid and the feature is supported. The J1939 standard recommends that the application does not send more than three requests per second. The API rejects any additional requests during this 1 second window. For get request PGN data, the PGN number must be added to the filter table. The API uses a reserved filter for both regular PGN and BAM messages. Use the setBAM method for broadcast messages and query the latest updated data. Using request on broadcast only PGNs may result in a longer response time, a time out , or an increase in bus traffic. If there is no response, a J1939 timeout event code of 0 is returned. If the PGN is unavailable, a J1939 data event code of 1 with an 8-byte payload is returned. If the PGN is available and the size is larger than 8 bytes, a J1939 BAM data event code of 2 with payload (³8 bytes) is returned. If the PGN is available and the request is a fast packet (NMEA 2000), a J1939 data event code 3 with variable size payload is returned. The firmware rejects any new requests if the previous request is not complete. NMEA 2000 request group function (PGN 126208) for specific fields is not supported. The optional da parameter is for sending a PGN request to a specific destination address. The application knows the ECU ID and associated PGNs. By default, without this option, the API sends a request as a global type to the bus. It is possible that some ECUs use the same PGNs with a different source address. In this case, application can use this destination address to filter out the PGN source, the application will not add this PGN to the regular filter table. Syntax <handle>:request(pgn, type, ext, da, specific) Parameters  pgn  PGN number or 0  type  (optional) 1 -Fast packet (used by most NMEA 2000 PGNs). If 0 or nil, it is standard.  ext  (optional) The extension parameter to PGN ranges from 0 to 255 used for NMEA 2000. It is the first  byte (8 bits) of data if nil or 255, ext setting is ignored.  da  (optional) Specific destination address (ECU ID) of the request.  specific  (optional) Default, global PGN request. 1 specific peer request.  Returns boolean True if successful string Error description on error, nil otherwise Examples --Request time/date. local ok,errMsg= canPort:request(65253) if not ok then --Request failed print(errMsg) end --Request VIN, max 200 byte chars(in BAM message) local ok,errMsg= canPort:request(65260) if not ok then --Request failed print(errMsg) end --NMEA 2000. Request Engine 0 static configuration, fast packet. local ok,errMsg= canPort:request(127498,1,0) if not ok then --Request failed print(errMsg) end Note: Most on request messages are not broadcasted and many broadcasted PGNs cannot be requested. Note: When using the optional da parameter for broadcasting PGNs, the firmware does not send a request to the CAN bus, it catches the first available packet from the specific source and then returns. It is recommended you only use this parameter on duplicated PGNs. Note: Peer to peer multipacket communication (RTS/CTS handshaking) is not supported for request. 3.2.11.3.10 setBAM() Description Flushes and assigns a parameter group number (PGN) that has its data filtered and saved if it generates a BAM. This function only supports one BAM PGN at a time but the application can change this by recalling this method. This function applies to Broadcasting and Òon requestÓ BAM messages. Current NMEA 2000 PGNs do not use BAM messages. Syntax <handle>:setBAM(pgn) Parameters  pgn  PGN is valid for BAM. This method flushes the old BAM data buffer.  Returns  boolean  True if successful  string  Error description on error, nil otherwise  Example  canPort:setBAM(65226) --set report DM1 with BAM 3.2.11.4 open() Description Opens the CAN interface. Syntax sys.J1939.open(bus, baud, listenOnly, forceOpen) Parameters  bus  CAN device to use (currently ignored). Device is a number, not a string.  baud  (optional) Specify which baud rate to use. Default is 250K.  0 Ð 1000 kbps 1 Ð 800 kbps 2 Ð 500 kbps 3 Ð 250 kbps (default) 4 Ð 125 kbps 5 Ð 100 kbps 6 Ð 50 kbps 7 Ð 20 kbps 8 Ð 10 kbps  listenOnly  (optional) Allow listenOnly mode to be used or not. Default is false.  forceOpen  Boolean that if true opens the bus even if errors are detected (default: false)  Returns handle A handle to access the rest of the API functions; nil on failure string In the case of failure, a description of the error 3.2.12 J1979 (Terminals with CAN bus) The examples in this section use 0 for 11-bit ID (CAN2.0A) and 1 for 29-bit ID (CAN2.0B) bus type. 3.2.12.1 detect Description Detects the J1979 protocol on the active bus. It is possible to search all emission related ECU on the bus by detecting Service 01 and PID 0. For correct results, the device must be connected to a CAN bus. Syntax sys.J1979.detect() Parameters None Returns conf A table of scan result. Nil if failure. type Number, bus type. 0 for 11-bit ID, 1 for 29-bit ID. baud Number, baud rate. 0 for 500 K, 1 for 250 K list A table of ECU addresses found on the bus. It can be used for a later request. err In the case of failure, a description of the error. Examples --Power local Jconf,errMsg = J1979.detect() if (Jconf) then --success printf("Scan type: %s\n",Jconf.type == CAN20B and "29 bit" or "11 bit") printf("Scan baud: %s\n",Jconf.baud == 1 and "250K" or "500K") print("ECU addresses:") for _,v in ipairs(Jconf.list) do printf("%X\n",v) end else --Open failed print(errMsg) end 3.2.12.2 open Description This opens the CAN interface. Syntax sys.J1979.open() Parameters  type  Number. Optional bus type. 0 for 11-bit ID. 1 for 29-bit CAN IDs.  baud  Number. Optional baud rate. 0 for 500 K, 1 for 250 K.  Note: The firmware interprets any parameter value lager than 1, as 1. Returns handle A handle to access the rest of the API functions; nil if failure errStr In the case of failure, a description of the error Example --Open available CAN port for OBD test obdHdl, errMsg= J1979.open(1,0) if (obdHdl) then --success, with default CAN 2.0B and 500K baud print(ÒJ1979 Session started\n") else --Open failed print(errMsg) end 3.2.12.3 J1979 Handle Methods The following methods can be used on the handle returned by sys.J1979open(). 3.2.12.3.1 close Description This closes the CAN bus interface. Syntax <handle>:close() Parameters None Returns None Examples --Close CAN interface obdHdl:close() 3.2.12.3.2 request Description This sends a request for diagnostic service. Any active ECU that supports requested service responds. The firmware posts an event if a response is available. Normal response time is less than 50 ms. A timeout event is posted if a response is not received after 50 ms. For a functional (broadcast) request, multiple responses are possible. The firmware posts the first response as soon as it is received. The firmware also posts another event to indicate that there are no additional responses from ECUs. The firmware rejects the new request if a previous one is not finished. Syntax <handle>:request() Parameters  addr  Number. ECU address (CAN ID)  service  Number of the Service ID. Service IDs 5 and 8 are rejected.  pid  Optional Number. Many services require this ID. It must be a PID or test ID or monitor ID or  info type. If a request is missing a pid for its service, it is considered an incomplete  request.  parm  Optional additional parameter number (0-255). It could be used by a nonstandard service  if need.  Returns  boolean  true on success  string  Error description, nil otherwise  Examples --Request engine speed for all ECUs local ok,errMsg=obdHdl:request(ECU_ALL 1,0xd) if not ok then --Request failed print(errMsg) end 3.2.12.4 J1979 Event Description An event is posted if the response message is available after request. Source Ò_J1939Ó (string) Event ÒResponseÓ (string) Event Return evtCode Event code number 0 Response from physical address request. No more messages. 1 Response from functional address request. Possible multiple messages. 2 End of response for functional request. No message data. 3 Timeout. No response from any ECUs. No message data. msg A table that contains the response to the requested message. Nil if there is no message data. ecu Number. Indicate the ECU address. For 11-bit CAN bus, response address range:7E8-7EF(requested +8) For 29-bit CAN bus, response address is 18DBF1xx. Where xx is the ECU number. data A string of data payload. The maximal size is 128 bytes. The first byte is always the service ID, which is the requested SID plus 0x40. The second byte is the requested PID, or the first byte of the service data. Refer to SAEJ19979/ISO 15031-5 specification for response message formats and data byte definitions. Example An example of a service response. local value local jbusQ = sched.createEventQ(5, "_J1979" ) while true do local _,_,evtcode,msg =sched.waitQ(-1,jbusQ) if evtcode <2 then printf("RX:ECU=%X Data:",msg.ecu) for i=1, msg.data:len() do printf("%02X ",msg.data:byte(i)) end print("") local sid = msg.data:byte(1) -0x40 local pid = msg.data:byte(2) if sid ==1 or sid == 2 then printf("SID=%02X, PID=%02X ",sid,pid) if pid == 0x5 then printf("Coolant Temperature: %dC\n", msg.data:byte(3) -40) elseif pid == 0xC then value = bit32.bor( bit32.lshift(msg.data:byte(4),8), msg.data:byte(3)) printf("Engine Speed:%.2f RPM\n" , value * 0.25) elseif pid == 0xD then printf("Vehicle Speed:%dKM\n", msg.data:byte(3)) elseif pid>= 0x14 and pid<=0x1B then printf("Oxygen Sensor Voltage:%.3fV\n", msg.data:byte(3) * 0.005) elseif pid == 0x10 then value = bit32.bor( bit32.lshift(msg.data:byte(4),8), msg.data:byte(3)) printf("Airflow Rate:%.2f g/s\n" , value * 0.01) end elseif sid == 9 and pid ==2 then printf("SID=%02X, PID=%02X ",sid,pid) printf("VIN=%s\n",msg.data:sub(4,msg.data:len())) end print("") else if evtcode == 2 then print("End of Response\n") else --code 3 print("Timeout.\n") end end end 3.2.13 LED Operation These functions are used to control the hardware LEDs. They have no effect unless the ledControl property of the associated service is set to User. 3.2.13.1 flash() Description This flashes the specified LED at the specified rate, for a given number of repetitions. Note the period is capped at 65 seconds. Each LED can be flashed independently. If the same LED is configured to flash before the previous flash sequence has completed, the new configuration overrides the old. Syntax sys.led.flash(lid, onTime, period, reps) Parameters  lid  LED identifier (for example, sys.led.SATCOMM)  onTime  The amount of time, in ms, that the LED is ON in each cycle. (Range: 0 Ð 5000 ms, where 0 is disabled)  period  The flashing period, in ms (must be greater than, or equal to, the ÔonTimeÕ).  Range: <onTime> -65535 ms)  reps  The number of repetitions of the flashing pattern (0 -65535 where 0 signifies repeat forever)  Returns  true  Operation was successful  false  Operation failed  errMsg  String description of the error  3.2.13.2 off()  Description  Turns OFF the specified LED. Syntax sys.led.off(lid) Parameters lid  LED identifier (for example, sys.led.POWER)  Returns  true  Operation was successful  false  Operation failed  errMsg  String description of the error  3.2.13.3 on() Description Turns ON the specified LED. Syntax sys.led.on(lid) Parameters lid LED identifier (for example, sys.led.CELL) Returns true Operation was successful false Operation failed errMsg String description of the error 3.2.13.4 Constants 3.2.14 math Firmware extensions performing math operations. 3.2.14.1 convertcoord() Description This converts the coordinates in string format to numerical format. Syntax sys.math.convertcoord(lat, long) Parameters  lat  The latitude, in the form [+-]DDMM.MMMM  long  The longitude, in the form [+-]DDMM.MMMM  Returns  integer  The latitude in minutes, scaled up to fill a 31-bit range (multiplied by 134217728, then divided by  675)  integer  The latitude in milliminutes  integer  The longitude in minutes, scaled up to fill a 32-bit range (multiplied by 134217728, then divided  by 675)  integer  The longitude in milliminutes  3.2.14.2 geodistance() Description This calculates the great-circle distance between two points, using the haversine formula. Syntax sys.math.geodistance(lat1, long1, lat2, long2) Parameters lat1 The latitude of the first point, in milliminutes long1 The longitude of the first point, in milliminutes lat2 The latitude of the second point, in milliminutes long2 The longitude of the second point, in milliminutes Returns number The distance between the two point in meters (single-precision floating point) 3.2.14.3 packint() Description This packs 4 bytes into a single 32-bit value. Syntax sys.math.packint(b1, b2, b3, b4) Parameters b1 b2 b3 b4  The first (most significant) byte The second byte The third byte The fourth (least significant) byte  Returns  integer  The 32-bit value composed of the four above bytes  3.2.14.4 uadd()  Description  Adds two 32-bit unsigned integer values. Because Lua supports only signed integer values, the two arguments are first cast from signed to unsigned, then added together. The result is again cast as a signed integer before being returned. Syntax sys.math.uadd(int1, int2) Parameters int1 The first unsigned integer value int2 The second unsigned integer value Returns integer The resulting sum of the two integer values, converted to a signed integer 3.2.14.5 uge() Description Compares two 32-bit unsigned integers to one another and returns true if the first one is greater than, or equal to, the second. Because Lua supports only signed integer values, the two arguments are first cast from signed to unsigned, then compared to one another. Syntax sys.math.uge(int1, int2) Parameters int1 The first unsigned integer value int2 The second unsigned integer value Returns boolean Whether the first integer value is greater than, or equal to, the second. 3.2.14.6 ugt() Description Compares two 32-bit unsigned integers to one another and returns true if the first one is greater than the second. Because Lua supports only signed integer values, the two arguments are first cast from signed to unsigned, then compared to one another. Syntax sys.math.ugt(int1, int2) Parameters int1 int2  The first unsigned integer value The second unsigned integer value  Returns boolean  Whether the first integer value is greater than the second.  3.2.14.7 ule()  Description  Compares two 32-bit unsigned integers to one another and returns true if the first one is less than, or equal to, the second. Because Lua supports only signed integer values, the two arguments are first cast from signed to unsigned, then compared to one another. Syntax sys.math.ule(int1, int2) Parameters int1 The first unsigned integer value int2 The second unsigned integer value Returns boolean Whether the first integer value is less than, or equal to, the second. 3.2.14.8 ult() Description Compares two 32-bit unsigned integers to one another and returns true if the first one is less than the second. Because Lua supports only signed integer values, the two arguments are first cast from signed to unsigned, then compared to one another. Syntax sys.math.ult(int1, int2) Parameters int1 int2  The first unsigned integer value The second unsigned integer value  Returns boolean  Whether the first integer value is less than the second.  3.2.14.9 usub()  Description  Subtracts one 32-bit unsigned integer value from another. Because Lua supports only signed integer values, the two arguments are first cast from signed to unsigned, then subtracted from one another. The result is again cast as a signed integer before being returned. Syntax sys.math.usub(int1, int2) Parameters int1 The first unsigned integer value int2 The second unsigned integer value Returns integer The resulting difference between the two integer values, converted to a signed integer. 3.2.14.10 unpackint() Description This unpacks a single 32-bit value into 4 bytes. Syntax sys.math.unpackint(val) Parameters val The 32-bit value Returns integer The first (most significant) byte integer The second byte integer The third byte integer The fourth (least significant) byte 3.2.15 Modbus 3.2.15.1 Supported Interfaces 3.2.15.2 RS232 A constant value indicating that the main or auxiliary RS-232 serial channel is used for Modbus. 3.2.15.3 RS485 A constant value indicating that the RS-485 serial channel is used for Modbus. 3.2.15.4 PARITY_NONE A constant value indicating that no parity is to be used on the serial channel. 3.2.15.5 PARITY_EVEN A constant value to indicate that even parity is to be used on the serial channel. 3.2.15.6 PARITY_ODD A constant value to indicate that odd parity is to be used on the serial channel. 3.2.15.7 MODE_RTU A constant value to indicate that the RTU transmission mode is to be used; implies 8 data bits, to comply with the Modbus specification. 3.2.15.8 MODE_ASCII A constant value to indicate that the ASCII transmission mode is to be used; implies 7 data bits, to comply with the Modbus specification. When using this Modbus mode, PARITY_NONE cannot be used, due to a hardware limitation. 3.2.15.9 open() Description This opens the specified serial channel for the Modbus operation. Syntax sys.modbus.open(id, mode, baud, parity, plcAddr, stopBits) Parameters  id  The serial channel ID (RS232, RS232_AUX, or RS485).  mode  The Modbus transmission mode to use (MODE_RTU or MODE_ASCII). RTU connections use 8 data  bits, while ASCII connections use 7 data bits.  baud  The baud rate to use on the serial channel (optional; default is 9600).  parity  The parity to use on the serial channel (optional; default is PARITY_EVEN).  plcAddr  Boolean indicating whether PLC addressing should be used (optional; default is false)  stopBits  The number of stop bits to use on the serial channel ((optional) default is 0, which uses the  appropriate value as defined in the Modbus protocol specification).  Returns handle A handle to access the rest of the API functions; nil in the case of failure string In the case of failure, a description of the error Example Open the RS485 serial channel for use with Modbus, using the RTU transmission mode, at 9600 baud, with even parity. local handle, error = sys.modbus.open(sys.modbus.RS485, sys.modbus.MODE_RTU) Open the main RS232 serial channel for use with Modbus, using the ASCII transmission mode, at 19200 baud, with no parity. sys.modbus. local handle, error = sys.modbus.open(sys.modbus.RS232, sys.modbus.MODE_ASCII, 19200, sys.modbus.PARITY_NONE) 3.2.15.10 open_tcp() Description Available on satellite-cellular terminals. This opens the specified serial channel for the Modbus operation. Syntax sys.modbus.open_tcp(ip, port, plcAddr) Parameters ip The IP address of the external device to connect to port The port to connect to plcAddr Boolean indicating whether PLC addressing should be used (optional; default is false) Returns handle A handle to access the rest of the API functions; nil in the case of failure string In the case of failure, a description of the error 3.2.15.11 Modbus Handle Methods The following methods can be used on the handle returned by sys.modbus.open(). 3.2.15.11.1 close() Description This closes the specified serial channel. Syntax <handle>:close() Parameters None Returns boolean Indicates success or failure string In the case of failure, a description of the error 3.2.15.11.2 maskwritereg() Description This builds and sends a query to modify a holding register value. The final register value is (current value AND andMask)OR (orMask AND (NOT andMask). Does not wait for the response. Syntax <handle>:maskwritereg(slave, addr, addMask, orMask, timeout) Parameters  slave  The slave device address; 0 -247 (0 is broadcast)  addr  The address of the holding register to modify; 0 -65535 (or 1 -65536 for PLC addressing)  addMask  Value that is AND'ed with the current register value (0 -0xFFFF)  orMask  Value that is OR'ed with the current register value (0 -0xFFFF)  timeout  The maximum amount of time (in ms) to wait for a response; must be a positive value (optional;  default is 5000)  Returns boolean Indicates success or failure string In the case of failure, a description of the error Example local result, error = handle:maskwritereg(1, 2, 0xF3F0, 0x0007) The following illustrates what happens after this call when the original register value is 0x0712. Hex  Binary  current value  0712  0000  0111  0001  0010  and mask  F3F0  1111  0011  1111  0000  or mask  0007  0000  0000  0000  0111  final value  0317  0000  0011  0001  0111  3.2.15.11.3 raw() Description This sends a raw request to a Modbus device. The data parameter is passed on to the device verbatim. Syntax <handle>:raw(slave, fcode, data, timeout) Parameters slave The slave device address; 0 -247 (0 is broadcast). fcode The Modbus function code; 1-127. data A byte stream (string) containing the raw data to be sent to the device. timeout The maximum amount of time (in ms) to wait for a response; must be a positive value (optional; default is 5000). Blocking No Returns boolean Indicates success or failure string In the case of failure, a description of the error 3.2.15.11.4 readcoils() Description This builds and sends a query to read one or more coils. Does not wait for the response. Syntax <handle>:readcoils(slave, addr, count, timeout) Parameters slave The slave device address; 1 -247 addr The address of the coil to read; 0 -65535 (or 1 -65536 for PLC addressing) count The number of coils to read (optional; minimum is 1, maximum is 2000, default is 1) timeout The maximum amount of time (in ms) to wait for a response; must be a positive value (optional; default is 5000) Returns boolean Indicates success or failure string In the case of failure, a description of the error 3.2.15.11.5 readholdingregs() Description This builds and sends a query to read one or more holding registers. Does not wait for the response. Syntax <handle>:readholdingregs(slave, addr, count, timeout) Parameters slave The slave device address; 1 -247 addr The address of the holding register to read; 0 -65535 (or 1 -65536 for PLC addressing) count The number of holding registers to read (optional; minimum is 1, maximum is 125, default is 1) timeout The maximum amount of time (in ms) to wait for a response; must be a positive value (optional; default is 5000) Returns boolean Indicates success or failure string In the case of failure, a description of the error Example Read three unsigned holding register values starting at address 7 in little-endian format. local mb485Q = sched.createEventQ(1,"_MODBUS", handle) local result, err = handle:readholdingregs(1, 7, 3) if result then local q, event, success, count, data, raw q, event, success, err, count, data, raw = mb485Q:wait(-1) if success then local buf = sys.buffer.create(data) for i = 1, count do printf("Register #%d = 0x%04X\n", 6 + i, buf:getInt16(false, true)) end else print(err) end else print(err) end Read four 32-bit values from eight holding registers starting at address 3 in the default high word first, big.endian format: local mb485Q = sched.createEventQ(1,"_MODBUS", handle) local result, error = handle:readholdingregs(1, 3, 8) local q, event, success, error, count, data, raw = mb485Q:wait(-1) if success then local buf = sys.buffer.create(data) for i = 1, count/2 do printf("Register #%d = 0x%08X\n", 2 + i, buf:getInt32()) end else print(error) end 3.2.15.11.6 readinfo() Description This builds and sends a query to read a device information value. Syntax <handle>:readinfo(slave, object, timeout) Parameters  slave  The slave device address(1 Ð 247)  object  The ID of the device information object to read (0 -0xFF)  timeout  The maximum amount of time (in ms) to wait for a response; must be a positive value (optional;  default is 5000)  Returns boolean Indicates success or failure string In the case of failure, a description of the error 3.2.15.11.7 readinputregs() Description This builds and sends a query to read one or more input registers. Does not wait for the response. Syntax <handle>:readinputregs(slave, addr, count, timeout) Parameters  slave  The slave device address; 1 -247  addr  The address of the input register to read; 0 -65535 (or 1 -65536 for PLC addressing)  count  The number of input registers to read (optional; minimum is 1, maximum is 125, default is 1)  timeout  The maximum amount of time (in ms) to wait for a response; must be a positive value (optional;  default is 5000)  Returns  boolean  Indicates success or failure  string  In the case of failure, a description of the error  3.2.15.11.8 readinputs() Description This builds and sends a query to read one or more discrete inputs. Does not wait for the response. Syntax <handle>:readinputs(slave, addr, count, timeout) Parameters slave The slave device address; 1 -247 addr The address of the discrete input to read; 0 -65535 (or 1 -65536 for PLC addressing) count The number of discrete inputs to read (optional; minimum is 1, maximum is 2000, default is 1) timeout The maximum amount of time (in ms) to wait for a response; must be a positive value (optional; default is 5000) Returns boolean Indicates success or failure string In the case of failure, a description of the error 3.2.15.11.9 readwriteregs() Description This builds and sends a query to write one or more holding register values at a given address and read one or more holding registers at a possibly different address. The write operation takes place before the read. Does not wait for the response. Syntax <handle>:readwriteregs(slave, rdAdd, rdCount, wrAddr, values, timeout) Parameters slave The slave device address; 1 -247 rdAdd The address of the first holding register to read; 0 -65535 (or 1 -65536 for PLC addressing) rdCount The number of registers to read (1 -125) wrAddr The address of the first holding register to write; 0 -65535 (or 1 -65536 for PLC addressing) values A byte stream (string) containing the packed 16-bit values (1 -121 values, each is 0 -0xFFFF) timeout The maximum amount of time (in ms) to wait for a response; must be a positive value (optional; default is 5000) Returns boolean Indicates success or failure string In the case of failure, a description of the error 3.2.15.11.10 setcfg() Description This allows changing the configuration that was set in the call to sys.modbus.open(): mode, baud rate, parity, PLC addressing. Syntax <handle>:setcfg(cfg) Parameters cfg A table with any of the following fields (a missing field means the current configuration remains unchanged): mode The Modbus transmission mode to use (MODE_RTU or MODE_ASCII). baud The baud rate to use on the serial parity The parity to use on the serial channel plcAddr Boolean indicating whether PLC addressing should be used stopBits The number of stop bits to use (see open) Returns boolean Indicates success or failure string In the case of failure, a description of the error 3.2.15.11.11 writecoil() Description Builds and sends a query to write a single coil value. Does not wait for the response. Syntax <handle>:writecoil(slave, addr, value, timeout) Parameters  slave  The slave device address; 0 -247 (0 is broadcast)  addr  The address of the coil to write; 0 -65535 (or 1 -65536 for PLC addressing)  value  The coil value (true/false)  timeout  The maximum amount of time (in ms) to wait for a response; must be a positive value (optional;  default is 5000)  Returns boolean Indicates success or failure string In the case of failure, a description of the error 3.2.15.11.12 writecoils() Description This builds and sends a query to write one or more coil values. Does not wait for the response. Syntax <handle>:writecoils(slave, addr, count, values, timeout) Parameters slave The slave device address; 0 -247 (0 is broadcast) addr The address of the first coil to write; 0 -65535 (or 1 -65536 for PLC addressing) count The number of coil values to write (1 -1968) values A byte stream (string) containing the packed bit values timeout The maximum amount of time (in ms) to wait for a response; must be a positive value (optional; default is 5000) Returns boolean Indicates success or failure string In the case of failure, a description of the error Example --Create a buffer with space for 10 bits (2 bytes) local buf = sys.buffer.create(2) --Add the 10 bit values buf:addBits(1, 1) buf:addBits(0, 1) buf:addBits(0, 1) buf:addBits(1, 1) buf:addBits(0, 1) buf:addBits(1, 1) buf:addBits(1, 1) buf:addBits(1, 1) buf:addBits(0, 1) buf:addBits(0, 1) --Write the 10 coil values to slave 1, address 0 local bytes, numBits = buf:getString() local result, error = handle:writecoils(1, 0, 10, bytes) Note: The result of getString() is not passed directly to the writeregs() call. That would have the side effect of passing the second result of the getString() call (the number of bits) as the fourth argument to the writeregs() call (the timeout value in milliseconds). In this case, because there are two 16-bit integers in the buffer, for a total of 32 bits, the timeout value is set at 32 milliseconds, likely causing the operation to time out. 3.2.15.11.13 writereg() Description Builds and sends a query to write a single holding register value. Does not wait for the response. Syntax <handle>:writereg(slave, addr, value, timeout) Parameters slave The slave device address; 0 -247 (0 is broadcast) addr The address of the register to write; 0 -65535 (or 1 -65536 for PLC addressing) value The register value (0 -0xFFFF) timeout The maximum amount of time (in ms) to wait for a response; must be a positive value (optional; default is 5000) Returns boolean Indicates success or failure string In the case of failure, a description of the error 3.2.15.11.14 writeregs() Description Builds and sends a query to write one or more holding register values. Does not wait for the response. Syntax <handle>:writeregs(slave, addr, values, timeout) Parameters slave The slave device address; 0 -247 (0 is broadcast) addr The address of the first holding register to write; 0 -65535 (or 1 -65536 for PLC addressing) values A byte stream (string) containing the packed 16-bit values (1 -123 values, each is 0 -0xFFFF) timeout The maximum amount of time (in ms) to wait for a response; must be a positive value (optional; default is 5000) Returns boolean Indicates success or failure string In the case of failure, a description of the error Example Write two signed holding register values starting at address 5 in the default big-endian format. local mb485Q = sched.createEventQ(1,"_MODBUS", handle) --Create a buffer for 2 register values (4 bytes) local buf = sys.buffer.create(4) buf:addInt16(178, true) buf:addInt16(-456, true) --Issue a query to write the registers local bytes, numBits = buf:getString() local result, error = handle:writeregs(1, 5, bytes) --Process the response local q, event, success, error, count, data, raw = mb485Q:wait(-1) if not success then print("Could not write registers: ", error) end Write two 32-bit values to four holding register values starting at address 0 with the high word first, but the bytes within the words in the little-endian format. local mb485Q = sched.createEventQ(1,"_MODBUS", handle) --Create a buffer for 2 32-bit values (8 bytes) local buf = sys.buffer.create(8) buf:addInt32(0x01234567, false, true) buf:addInt32(0x89ABCDEF, false, true) --Issue a query to write the registers local bytes, numBits = buf:getString() local result, error = handle:writeregs(1, 0, bytes) --Process the response local q, event, success, error, count, data, raw = mb485Q:wait(-1) if not success then print("Could not write registers: ", error) end Write a single 32-bit value to two holding register values starting at address 4 with the low word first and the bytes within the words in the big-endian format. local mb485Q = sched.createEventQ(1,"_MODBUS", handle) --Create a buffer for 1 32-bit values (4 bytes) local buf = sys.buffer.create(4) buf:addInt32(0x01234567, true) --Issue a query to write the registers local result, error = handle:writeregs(1, 0, buf:setString()) --Process the response local q, event, success, error, count, data, raw = mb485Q:wait(-1) if not success then print("Could not write registers: ", error) end 3.2.15.12 Response Event 3.2.15.12.1 Modbus Description This event is posted when a response to a query is received. Source "_MODBUS" (string) Event handle Arguments boolean This indicates if the response was received successfully or not. string A description of the error that occurred; or an empty string otherwise. integer The number of result values, or 0 on write operation, raw request or error. string The operation result as a stream of bytes; an empty string on write operation, raw request or error. See examples below for the data format. string A byte stream of the raw Modbus response; nil when a response is not received (i.e., timeout) Example Read four coil values starting at address 3. local mb485Q = sched.createEventQ(1,"_MODBUS", handle) local result, error = handle:readcoils(1, 3, 4) local q, event, success, error, count, data, raw = mb485Q:wait(-1) if success then local buf = sys.buffer.create(data) for i = 1, count do printf("Coil #%d = %d\n", 2 + i, buf:getBits(1)) end else print(error) end 3.2.16 onewire 1-wire functionality is supported on some ST models, refer to the product hardware guide for additional details. 1-Wire is a device communications bus system that provides low-speed data, signaling, and power over a single signal. For a complete list of supported families refer to APPENDIX F. Refer to APPENDIX G for sample code. 3.2.16.1 connect() Description Detect and enable 1-Wire control circuit to open a connection to the 1-Wire bridge (DS2484). Syntax sys.onewire.connect() Parameters None Returns  handle  A handle to access the remaining API functions; nil upon failure  errStr  An error message on failure  Example --Power on DS2484 or open serial port on DS2480B local owHdl,errMsg = sys.onewire.connect() if (owHdl) then --success print(Ò1-Wire Session started\n") else --Open failed print(errMsg) end 3.2.16.2 crc8() Description Calculates the 8-bit DOW CRC of the given byte stream (x^8 + x^5 + x^4 + 1). CRC8 is used for all ROM code checks. In the 1-Wire protocol, the crc8 function is used to verify the data integrity on the bus. Check the device datasheet to determine when to use crc16 rather than crc8. Syntax sys.onewire.crc8(dStr) Parameters dStr The string of byte stream for which a CRC8 needs to be computed Returns ncrc8 The resulting 8-bit CRC value Example DS1920 temperature reading pseudo code. local DS1920_READ_SCRATCHPAD = 0xBE local DS1920_CONVERT_TEMPERATURE = 0x44 local DS1920_FAMILY_CODE = 0x10 local DS1920_SCRATCHPAD_SIZE = 8 --Power on DS2484 or open serial port on DS2480B local owHdl = sys.onewire.connect() if (owHdl == nil) then return end --Reset + ROM Search algorithm local idTbl = owHdl:search() if (idTbl == nil) then owHdl:disconnect() return end --This demo tests first device only local deviceID = idTbl[1] if (deviceID:byte(8) == DS1920_FAMILY_CODE) then owHdl:matchRom(deviceID) --Temperature conversion --Strong Pull-up for 750ms defined by spec owHdl:writeBytePower(DS1920_CONVERT_TEMPERATURE,750) --Read Scratchpad to check temperature reading owHdl:matchRom(deviceID) owHdl:writeByte(DS1920_READ_SCRATCHPAD) --Read entire scratchpad plus CRC8. 8 + 1 = 9 bytes local rbuf = owHdl:readBlock(DS1920_SCRATCHPAD_SIZE) local rcrc = owHdl:readByte() owHdl:reset() --Check CRC8 local ccrc8 =sys.onewire.crc8(rbuf) if (ccyc8 == rcrc) then --Alternative to check if crc8 of whole data is 0; --local rbuf = owHdl:readBlock(DS1920_SCRATCHPAD_SIZE + 1) --owHdl:reset() --local ccrc8 = owHdl:crc8(rbuf) --if (ccyc8 == 0)) then --CRC8 calculation matched, get temperature reading local degree = bit32.bor( bit32.lshift(rbuf:byte(2),8), rbuf:byte(1)) printf("Temperature:%.1f\n", degree * 0.5) end else print("Not a DS1920 temperature sensor\n") end --Disconnect 1-Wire Bus owHdl:disconnect() 3.2.16.3 crc16() Description Calculate the 16-bit CRC of a given byte stream (x^16 + x^15 + x^2 + 1). In the 1-Wire protocol, the crc16 function is used to verify the data integrity on the bus. Check the device datasheet to determine when to use crc16 rather than crc8. Syntax sys.onewire.crc16(dStr) Parameters dStr The byte stream for which a CRC needs to be computed Returns ncrc16 The resulting 16-bit CRC value Example DS1972 EEPROM Fast Access pseudo code. local DS1972_FAMILY_CODE = 0x2D local DS1972_WRITE_SCRATCHPAD = 0x0F local DS1972_READ_SCRATCHPAD = 0xAA local DS1972_COPY_SCRATCHPAD = 0x55 --Power on DS2484 or open serial port on DS2480B local owHdl = sys.onewire.connect() if (owHdl == nil) then return end --Reset + ROM Search algorithm local idTbl = owHdl:search() if (idTbl == nil) then owHdl:disconnect() return end --This demo tests first device only local deviceID = idTbl[1] if (deviceID:byte(8) == DS1972_FAMILY_CODE) then --Scratchpad data size shall be: 8 --Write EEPROM address: 0x0020 local wbuf=string.char(DS1972_WRITE_SCRATCHPAD) .. '\032\000' wbuf = wbuf .. 'SkyWave!' --Calculate CRC16 local wcrc16 sys.onewire.crc16(wbuf) --Write scratchpad, overdrive speed for short cable owHdl:matchRom(deviceID,true) owHdl:writeBlock(wbuf) --Check CRC16, read inverted CRC16 local temp = owHdl:readBlock(2) local rcrc16 = bit32.bor( bit32.lshift(temp:byte(2),8), temp:byte(1)) if (wcrc16 + rcrc16 == 0xffff) then --CRC16 calculation matched, --Copy scratchpad to EEPROM owHdl:matchRom(deviceID,true) owHdl:writeByte(DS1972_COPY_SCRATCHPAD) --Send Authorization code --Address:0x0020, End offset:7 owHdl:writeByte(0x20) owHdl:writeByte(0) owHdl:writeByte(0x7,10) --delay 10 ms --Check AA state. local status = owHdl:readByte() if (status == 0xAA) then print('Write EEPROM OK\n') else print('Write EEPROM Failed\n') end else print('CRC 16 error\n') end else print('Not a DS1972 1024-Bit EEPROM device\n') end --Disconnect 1-Wire Bus owHdl:disconnect() Note: CRC16 value from the device is inverted, so the sum of local CRC16 and the device CRC16 is 0xffff. 3.2.16.4 Onewire Handle Methods 3.2.16.4.1 disconnect() Description Close the 1-Wire interface. Syntax <handle>:disconnect() Parameters None Returns  boolean  Indicates success or failure. If success returned, the slave device responded and is present  on the bus.  string  An error message on failure, or nil otherwise  Example --Power on DS2484 or open serial port on DS2480B owHdl,errMsg=sys.ow.connect() --Session start --Send commands to access iButton data ---Power off DS2484 or close DS2480B owHdl:disconnect() --Session end 3.2.16.4.2 matchRom() Description This call allows the bus master to select a device to access. Only the device with a matching ROM Code (ID) is active on the bus. This call is usually followed by a device-specific command (for example, writeByte()). This call must be in the first place for a transaction sequence. Syntax <handle>:matchRom(deviceID,overdrive) Parameters deviceID A string of 8 bytes ROM code overdrive Optional Boolean. If nil, this function assumes that the bus operates at a normal speed. True to use overdirve fast speed (125 kbps). Returns boolean Indicates success or failure. If success returned, the slave device responded and is present on the bus. string An error message on failure, or nil otherwise Example Multidrop bus operation. local DS1972_FAMILY_CODE = 0x2D --Scan devices on the bus. local idTbl = owHdl:search() if (idTbl == nil) then return end --Check first device if (idTble[1]:byte(8) == DS1972_FAMILY_CODE) then --Normal speed device access owHdl:matchRom(idTbl[1]) --Overdrive speed access --Reset + Overdrive Match ROM + 8 byte Rom Code, --owHdl:matchRom(idTble[1],true) --Send Read or Write command here else print(ÒNot a DS1972 1024-Bit EEPROM device\nÓ) end Note: Application performs a 1-Wire bus sync reset, send a Match ROM, or Overdrive Match ROM function, and then sends 8 bytes ROM code to all devices for matching. If a device does not support fast speed, any following commands are not executed. Next transaction sequence exits the fast speed mode after a bus sync reset. Refer to APPENDIX H for supported Overdrive speed device. 3.2.16.4.3 readBlock() Description After a read command, the master starts to read the bus data 1-byte at a time until the data size is reached. This call always follows a writeByte(), writeBytePower or writeBlock(). Syntax <handle>:readBlock(size) Parameters size 1-Wire device datasheet defines the data size, if the read size is larger than real data buffer; dummy data (such as 0xff) is returned. The value should be between 1 and 128. Returns rbuf A data string of received from the device, nil if failed. errStr An error message on failure Example local DS1972_READ_MEMORY = 0xF0 local DS1972_FAMILY_CODE = 0x2D --Got deviceID before if (deviceID:byte(8) == DS1972_FAMILY_CODE) then owHdl:matchRom(deviceID) --Setup read memory command and address 0 local buf= string.char(DS1972_READ_MEMORY) .. Ô\000\000Õ --Send command to read memory from address 0 owHdl:writeBlock(buf) --Read 100 bytes local rbuf,errStr = owHdl:readBlock(100) --Transaction Done, owHdl:reset() if (rbuf) then print("Memory data:Ó) print(toHex(rbuf)) else print( errStr) end else print(ÒNot a DS1972 1024-Bit EEPROM device\nÓ) end Note: After this call, the current transaction sequence is finished. The application can start another transaction or call reset() if not immediately starting a new transaction. 3.2.16.4.4 readByte() Description Read a single byte from the 1-Wire bus. This call follows a writeByte(), writeBytePower, or writeBlock(). After sending a read command, the master has to read data from the device. It may be also need to read back a device response after data transmission. Syntax <handle>:readByte() Parameters None Returns  rbyte  A data byte if success, nil if failed  errStr  An error message on failure  Example local DS1972_READ_MEMORY = 0xF0 local DS1972_FAMILY_CODE = 0x2D --Got deviceID before if (deviceID:byte(8) == DS1972_FAMILY_CODE) then owHdl:matchRom(deviceID) --Setup read memory command --Read memory from address 64 local buf=string.char(DS1972_READ_MEMORY) .. Ô\064\000Õ --Send command owHdl:writeBlock(buf) --Read a byte local rbyte= owHdl:readByte() --Transaction Done, owHdl:reset() else print(ÒNot a DS1972 1024-Bit EEPROM device\nÓ) end Note: Not every device-specific command has data content. In this case, the current transaction sequence is finished, the application can start another transaction or call reset() if not immediately starting a new transaction. writeByte(0xff) is equal to readByte() in signal level. 3.2.16.4.5 readRom() Description Read the ROM code from the slave device on a single-drop bus. For multiple drop buses, this call results in an incorrect code because of data collision, CRC8 check error. Syntax <handle>:readRom() Parameters  None  Returns  romCode  The obtained ROM code data when successful ROM code is read. Nil if CRC error or there is no  device on the bus.  errStr  An error string if CRC error or no device on the bus  Example  --Read Device Serial ID from single drop bus. --Reset + Read ROM + 8 bytes Rom code local romCode,errStr = owHdl:readRom() --Print device ID if (romCode) then print("Device ID:Ó) print(toHex(romCode)); else print(errStr) end Note: This API performs a 1-Wire bus reset. Send readRom() and then receive 8 bytes ROM code from the device. 3.2.16.4.6 reset() Description Resets all devices on the 1-Wire bus. Syntax <handle>:reset() Parameters None Returns  boolean  Indicates success or failure  string  An error message on failure, or nil otherwise  Example local DS1920_CONVERT_TEMPERATURE = 0x44 --Got deviceID before owHdl:matchRom(deviceID) --Begin a temperature conversion, strong pull-up for 750ms owHdl:writeBytePower(DS1920_CONVERT_TEMPERATURE,750) --transaction is done owHdl:reset() Note: After a 1-Wire transaction is finished, use reset() if not immediately starting a new transaction. 3.2.16.4.7 search() Description Scan 1-Wire bus to search available devices. This call can be used for both single and multiple drop buses. Syntax <handle>:search(alarm) Parameters alarm Optional Boolean. Nil to scan all devices. True to scan devices only with event alarmed. Refer to APPENDIX H for a list of supported devices. Returns idTable A table of 8 byte ROM code string. Nil if failed or there is no device on the bus errStr An error string if failed or no device on the bus Example Search all devices on the bus --Use owHdl:search(true) to search event alarmed devices. --Reset + ROM Search algorithm local idTbl,errStr = owHdl:search() if (idTbl) then print("Device list:Ó) for _,id in ipairs(idTbl) do print(toHex(id)); end --Output examples --A90000003DE58724 --020000077C35C42D --3B0000054E378E2D else print(errStr) end --Other operations É Note: This API performs 1-Wire search algorithm. If there is no matching device found, the API returns an empty table. 3.2.16.4.8 skipRom() Description Resets the 1-Wire bus, sends the 1-Wire skipRom() command and is intended to be used with a single device on the bus. This call is usually followed by a device-specific command, such as writeByte(). If more than one device replies on the bus a protocol error may occur. This call is usually followed by a device-specific function command, then read or write data from/to the device if necessary. This call must be in the first place for a transaction sequence. Syntax <handle>:skipRom(overdrive) Parameters overdrive Optional Boolean. If nil, this function assumes that the bus operates at a normal speed. True to use overdrive fast speed (125 kbps). Returns  boolean  Indicates success or failure  string  An error message on failure, or nil otherwise  Example The example below is for a single drop bus operation. local DS1920_CONVERT_TEMPERATURE = 0x44 --Reset + Skip ROM owHdl:skipRom() --Begin a temperature conversion, strong pull-up for 750ms --Send command to all DS1920 sensors owHdl:writeBytePower(DS1920_CONVERT_TEMPERATURE,750) --transaction is done owHdl:reset() Note: API performs 1-Wire bus sync reset, send a skipRom() or skipRom(overdrive). Refer to APPENDIX H for supported Overdrive devices. 3.2.16.4.9 writeBlock() Description Write one or more bytes to the 1-Wire bus. Note that this call must be preceded by matchRom() or skipRom(). The buffer can include a device-specific command, its address and its data content. For example of an IO switch, data buffer includes a pin number and new state. Refer to device datasheet for detail. Syntax <handle>:writeBlock(buf) Parameters buf The byte stream to write to the bus Returns boolean Indicates success or failure string An error message on failure, or nil otherwise Example local DS1920_WRITE_SCRATCHPAD = 0x4E local DS1920_COPY_SCRATCHPAD = 0x48 local DS1920_FAMILY_CODE = 0x10 --Got deviceID before if (deviceID:byte(8) == DS1920_FAMILY_CODE) then owHdl:mathcRom(deviceID) --Write scratchpad --25 degree C, high trigger threshold ---1 degree C, Low trigger threshold local buf= string.char(DS1920_WRITE_SCRATCHPAD) .. '\025\255' --Set new thresholds owHdl:writeBlock(buf) --You could read back to verify it here --Start a new sequence, save new thresholds to EEPROM. owHdl:matchRom(deviceID) --Send Copy command and enable strong pull-up for 10 ms by spec owHdl:writeBytePower(DS1920_COPY_SCRATCHPAD,10) --transaction is done owHdl:reset() else print('Not a DS1920 temperature sensor\n') end Note: For memory operation, majority of devices have the scratchpad size same as memory page, in most cases, this size is 32 bytes. But there is an exception, an 8-byte scratchpad with a 32-page size. To write to the memory scratchpad, the starting address should always align with the scratchpad size, and should always write full size scratchpad; otherwise the programing memory will fail. If no additional read operation from the device, current transaction sequence is finished, application can start another transaction or call reset() if not immediately starting a new transaction. 3.2.16.4.10 writeByte() Description Write one byte to the 1-Wire bus. This function is blocking if a delay parameter is provided. This call should always be used after matchRom() or skipRom().This call is the same as writeBytePower(). This byte can be device-specific function command or any kind of data to be exchanged. Syntax <handle>:writeByte(wbyte, delay) Parameters  wbyte  The byte to write to the bus  delay  Optional number in milliseconds that defines the duration to block the serial interface and wait  for completion. Value must be between 1 and 1000 milliseconds (optional number  Returns boolean Indicates success or failure string An error message on failure, or nil otherwise Example local DS1920_RECALL_CMD = 0xB8 local DS1920_FAMILY_CODE = 0x10 --Got deviceID before if (deviceID:byte(8) == DS1920_FAMILY_CODE) then owHdl:skipRom() --Send Recall command to device owHdl:writeByte(DS1920_RECALL_CMD) else print(ÒNot a DS1920 temperature sensor\nÓ) end Note: For some operations, a delay is necessary to wait until a job has completed, application must follow the timing specified in the product manufacturer's datasheet. Not every device-specific command has data content. In this case, current transaction sequence is finished, application can start another transaction or call reset() if not immediately starting a new transaction. 3.2.16.4.11 writeBytePower() Description Write one or more bytes to the 1-Wire bus. This call must be preceded by matchRom() or skipRom(). This call is the same as writeByte(). In addition, it changes the power level to strong pull-up after writing. For some devices, standard pull-up time is not enough for a parasite powered device to finish operations such as programming EEPROM and ADC, therefore, the master (usually within 10 us) must change 1-Wire pull-up timing to keep charging and provide extra power. Syntax <handle>:writeBytePower(wbyte, delay) Parameters  wbyte  The byte to write to the bus  delay  Optional number in mSec. Block the serial interface for a period of time. Value must be between 1  and 1000 mSec  Returns boolean Indicates success or failure string An error message on failure, or nil otherwise Example local DS1920_CONVERT_TEMPERATURE = 0x44 local DS1920_FAMILY_CODE = 0x10 --Got deviceID before if (deviceID:byte(8) == DS1920_FAMILY_CODE) then owHdl:matchRom(deviceID) --Begin a temperature conversion, --Enable strong pull-up for 750ms defined by spec owHdl:writeBytePower(DS1920_CONVERT_TEMPERATURE,750) --Transaction is done owHdl:reset() else print(ÒNot a DS1920 temperature sensor\nÓ) end Note: Strong pull-up is automatically terminated on timeout or next 1-Wire bus read, write, or reset. If a strong pull-up is needed for more than one byte, call this API again for each byte. If a delay is required, the application must follow the timing specified in the specific product datasheet, generally available from the manufacturer. Refer to APPENDIX I for devices that require a strong pull-up (extra power). 3.2.17 Stopwatch Stopwatch provides a firmware extension to support millisecond resolution stopwatch like functionality, which can be used to measure the elapsed time between two points in a Lua application. A stopwatch instance is implemented as two start/stop timestamps, so active stopwatches do not use any CPU resources. The number of stopwatch instances is limited only by available Lua heap memory. A stopwatch can overflow if its internal counter exceeds math.hugeint. When this happens, querying the stopwatch returns a -1. 3.2.17.1 create() Description This method creates a new stopwatch instance. New stopwatches start in a clear and stopped state. There is no limit on the number of stopwatches that can be created other than memory resources. Syntax sys.stopwatch.create() Parameters None Returns handle A handle to access the stopwatch Example local sw = sys.stopwatch.create()--create the stopwatch É sw = nil--deletes the stopwatch 3.2.17.2 Stopwatch Handle Methods 3.2.17.2.1 clear() Description This method resets the contents of a stopped or running stopwatch to zero. It does not stop the stopwatch if it is running. Syntax <handle>:clear() Parameters None Returns None 3.2.17.2.2 query() Description Queries the value of the stopwatch counter and optionally clears the counter value. Syntax <handle>:query(clear) Parameters  clear  (Optional) Boolean to indicate if the stopwatch should be cleared or not after being queried. If  omitted, the default is not to clear the stopwatch.  Returns  number  Current value of the stopwatch in milliseconds. If the stopwatch counter has exceeded  math.hugeint, -1 is returned.  3.2.17.2.3 start() Description Starts the stopwatch and optionally clear it. If the counter is already running, this function has no effect. Syntax <handle>:start(clear) Parameters clear Optional Boolean to indicate if the stopwatch should be cleared or not before being started. If omitted, the default is not to clear the stopwatch. Returns None 3.2.17.2.4 stop() Description Stops the stopwatch counter. Syntax <handle>:stop() Parameters None Returns None Example shell> lua lua> sw=sys.stopwatch.create() lua> print(sw) stopwatch (6814d57c) [stopped] lua> print(sw:query()) 0 lua> sw:start() lua> print(sw:query()) 2471 lua> print(sw:query()) 4551 lua> print(sw) stopwatch (6814d57c) [running] lua> sw:stop() lua> print(sw:query()) 25824 lua> print(sw) stopwatch (6814d57c) [stopped] lua> print(sw:query()) 25824 lua> sw:clear() lua> print(sw:query()) 0 lua> sw=nil lua> 3.2.18 timer 3.2.18.1 MAX_TIMEOUT Specifies the maximum timeout supported. If a larger timeout is specified, an error is raised. The maximum value is 21474836 tenths of seconds (about 24 days). 3.2.18.2 MIN_TIMEOUT Specifies the minimum timeout supported. If a smaller timeout is specified, an error is raised. 3.2.18.3 create() Description This creates a new timer. Syntax sys.timer.create() Parameters None Returns handle A handle to access the timer 3.2.18.4 Timer Handle Methods 3.2.18.4.1 arm() Description This arms the timer to generate an event after the timeout has expired. This is a one-time event. An optional user argument can be provided that is passed as an argument to the timeout event. Syntax <handle>:arm(timeout, userArg) Parameters  timeout  The timeout value, in 10ths of a second  userArg  Optional user argument to be passed with the timeout event  Returns  boolean  Returns true if the alarm was rearmed (active alarm was cancelled)  3.2.18.4.2 disarm() Description This disarms the timer, so that it no longer generates any events. Events that have already been queued are not removed. Syntax <handle>:disarm() Parameters None Returns boolean Returns true if the alarm was active and cancelled 3.2.18.4.3 timeleft() Description This method returns the time remaining until the timer expires. Syntax <handle>:timeleft() Parameters None Returns number The time remaining until the timer expires, in tenths of seconds. 0 indicates less than1 /10th of a second remaining, while -1 indicates that the timer is not armed. 3.2.18.5 Firmware Events 3.2.18.5.1 _TIMER event Description Posted when a timer has expired. Source Ò_TIMERÓ (string) Event <timer handle> Arguments userArg User argument passed to the arm() call(optional) 3.2.19 Uptime 3.2.19.1 framework() Description Returns the amount of time since the Lua Services Framework was started. Syntax sys.uptime.framework(format) Parameters format  optional format specification string which can be one of:  Ò*sÓ  return integer seconds since the Lua Services Framework was started (default)  Ò*tÓ  return table with uptime broken into components  Returns  number  Seconds since Lua Services Framework was started if using the Ò*sÓ format  OR  table  With the following fields if using the Ò*tÓ format:  totalSeconds  Total seconds since the Lua Services Framework was started  days  Framework uptime days  hours  Framework uptime hours  minutes  Framework uptime minutes  seconds  Framework uptime seconds  ms  Framework uptime milliseconds  3.2.19.2 idle() Description Returns the idle time of the framework. Syntax sys.uptime.idle(format) Parameters format optional format specification string which can be one of: Ò*sÓ return integer seconds of idle time since the framework was started Ò*tÓ return a table containing the framework idle time broken into components Returns number Seconds of idle time since the framework was started if using the Ò*sÓ format OR table With the following fields if using the Ò*tÓ format: totalSeconds Total idle seconds since the framework started days Framework idle days hours Framework idle hours minutes Framework idle minutes seconds Framework idle seconds ms Framework idle milliseconds 3.2.19.3 powersave() Description Returns the amount of time the terminal was in power save (low power) mode since the last reset. Syntax sys.uptime.powersave(format) Parameters  format  Optional format specification string which can be one of:  Ò*sÓ  return integer seconds (default)  Ò*tÓ  return table with uptime broken into components  Returns: number Seconds terminal spent in power save mode if using the Ò*sÓ format OR table With the following fields if using the Ò*tÓ format: totalSeconds Total seconds terminal was in power save mode days Terminal power save time in days hours Terminal power save time in hours minutes Terminal power save time in minutes seconds Terminal power save time in seconds ms Terminal power save time in milliseconds 3.2.19.4 terminal() Description Returns the amount of time since terminal was last reset. Syntax sys.uptime.terminal(format) Parameters  format  Optional format specification string that can be one of:  Ò*sÓ  Return integer seconds since the terminal reset (default)  Ò*tÓ  Return table with uptime broken into components  Returns: number Seconds since the terminal was reset if using the Ò*sÓ format OR table With the following fields if using the Ò*tÓ format: totalSeconds Total seconds since the terminal reset days Terminal uptime in days hours Terminal uptime in hours minutes Terminal uptime in minutes seconds Terminal uptime in seconds ms Terminal uptime in milliseconds 3.2.20 watchdog 3.2.20.1 clearmaxtime() Description This function clears the Lua thread maximum execution time metric. Syntax sys.watchdog.clearmaxtime() Parameters None Returns None 3.2.20.2 getmaxtime() Description This function returns the maximum execution time in milliseconds of a Lua thread since the LSF was started or the maximum time was cleared. Syntax sys.watchdog.getmaxtime() Parameters None Returns number The maximum execution time of a Lua thread in milliseconds. 3.2.20.3 kick() Description This function restarts the Lua execution watchdog timer, so that its timeout period is reset to the default. Syntax sys.watchdog.kick() Parameters None Returns None 4 LUA INFRASTRUCTURE This section describes the Lua infrastructure. 4.1 Globals Globals are described below. 4.1.1 LSF_VERSION The string version of the Lua Services Framework. 4.1.2 LSF_REVISION The numeric revision (build number) of the Lua Services Framework. 4.1.3 LSF_BUILD_DATE The date the Lua Services Framework was built. 4.1.4 LSF_BUILD_TIME The time the Lua Services Framework was built. 4.1.5 LSF_GENERATION LSF Generation value which corresponds to the following: 4.1.6 LSF_API_LEVEL This global defines the API level of the framework. This value is incremented for every release that changes the API in any way. 4.1.7 SKYWAVE_PACKAGE_VERSION A string containing the version of the package file loaded onto the ST terminals. 4.1.8 zlib Library The zlib library is provided to help applications with data decompression. 4.1.8.1 compress() Description This function compresses the given data (ST 6xxx). Syntax zlib.compress(data, level, method, windowBits, memLevel, strategy) Parameter data This is the data for the compressed (string) level The compression level (optional ; default is -1). The following constants are defined: zlib.DEFAULT_COMPRESSION -1 (compression level 6 is used in this implementation) 0 1 9 method The compression method. The only supported value on this platform is 8 (optional; default is 8). windowBits This defines the compression window size. A smaller value results in less memory usage, but with lower compression. The value can range from 8 to 15 (optional; default is 15). Adding 16 to this value produces a simple gzip header and trailer around the compressed data instead of a zlib wrapper. The following constants are defined: zlib.DEFAULT_WINDOWBITS 15 8 15 Adding 16 to the windowBits value causes the library to wrap the compressed data in a simple gzip header and trailer. The gzip header will have no file name, no extra data, no comment, no modification time (set to zero), no header crc, and the operating system will be set to 255 (unknown). memLevel This defines the amount of memory used for the internal compression state. A smaller value results in less memory usage, but with lower compression and slower speed. The value can range from 1 to 9 (optional; default is 8). The following constants are defined: zlib.DEFAULT_MEMLEVEL 8 1 9 strategy This defines the compression strategy (optional; default is 0). The following constants are defined: zlib.DEFAULT_STRATEGY 0 1 2 3 zlib.FIXED 4 Blocking No Returns string The compressed data 4.1.8.2 decompress() Description This function decompresses the given data. Syntax zlib.decompress(data, windowBits) Parameters  data windowBits  This is the of data to decompress (string) This defines the decompression window size. A smaller value results in less memory usage, but the stream will not decompress properly if this value is smaller than the value used when compressing (optional; default is 15). Add 16 to decompress gzip-formatted data.  Adding 32 to the windowBits value causes the library to automatically detect a zlib or gzip header, and to decompress accordingly. Adding 16 to the windowBits value causes the library to decompress only data with a gzip header  Blocking  No  Returns  string  The decompressed data  4.1.8.3 deflate() Description This sets up a streaming data compressor. Syntax zlib.deflate(dataSink, level, method, windowBits, memLevel, strategy) Parameters zlib.BEST_SPEED 1 zlib.BEST_COMPRESSION 9 method The compression method. The only supported value on this platform is 8 (optional; default is 8). windowBits This defines the compression window size. A smaller value results in less memory usage, but with lower compression. The value can range from 8 to 15 (optional; default is 15). Adding 16 to this value produces a simple gzip header and trailer around the compressed data instead of a zlib wrapper. The following constants are defined: zlib.DEFAULT_WINDOWBITS 15 zlib.MINIMUM_WINDOWBITS 8 zlib.MAXIMUM_WINDOWBITS 15 Adding 16 to the windowBits value causes the library to wrap the compressed data in a simple gzip header and trailer. The gzip header will have no file name, no extra data, no comment, no modification time (set to zero), no header crc, and the operating system will be set to 255 (unknown). memLevel This defines the amount of memory used for the internal compression state. A smaller value results in less memory usage, but with lower compression and slower speed. The value can range from 1 to 9 (optional; default is 8). The following constants are defined: zlib.DEFAULT_MEMLEVEL 8 zlib.MINIMUM_MEMLEVEL 1 zlib.MAXIMUM_MEMLEVEL 9 strategy This defines the compression strategy (optional; default is 0). The following constants are defined: zlib.DEFAULT_STRATEGY 0 zlib.FILTERED 1 zlib.HUFFMAN_ONLY 2 zlib.RLE 3 zlib.FIXED 4 Blocking No Returns handle A handle to the compressor 4.1.8.4 Deflate Handle Methods 4.1.8.4.1 close() Description This method closes the data decompressor. Syntax <handle>:close() Parameters None Blocking No Returns boolean true or false to indicate the success of the close 4.1.8.4.2 lines() Description This method returns an iterator to read all lines in the decompressed data in a loop. Syntax <handle>:lines() Parameters None Blocking No Returns object An iterator to use in a loop Example local inFile, err = io.open(Ô/path/to/my/compressed/fileÕ, ÔrÕ) if inFile then local hdl = zlib.inflate(inFile) for line in hdl:lines() do print(Ôline = Ô, line) end hdl:close() inFile:close() end 4.1.8.4.3 write() Description This method writes a block of data to compress. Syntax <handle>:write() Parameters data  A string to compress. It can be repeated multiple times.  Blocking No  Returns boolean  true or false to indicate the success of the close  4.1.8.5 inflate()  Description  This function sets up a streaming data decompressor. Syntax zlib.inflate(dataSource, windowBits) Parameters dataSource This is the source of data to decompress. It can be: string The actual data to decompress. function A function to call to get the next block of data. The block size is passed in as an argument and it must return a string of that size. object A handle to an object (table or userdata) that supports a read and a close methods. The read method is given the block size as an argument and must return a string of that size. An open file handle is a perfect candidate to be passed to this function. windowBits This defines the decompression window size. A smaller value results in less memory usage, but the stream will not decompress properly if this value is smaller than the value used when compressing (optional; default is 15). Add 16 to decompress gzip-formatted data. Adding 32 to the windowBits value causes the library to automatically detect a zlib or gzip header, and to decompress accordingly. Adding 16 to the windowBits value causes the library to decompress only data with a gzip header. Blocking No Returns handle A handle to the decompressor. 4.1.8.6 Inflate Handle Methods 4.1.8.6.1 read() Description This method reads a block of decompressed data. Syntax <handle>:read(option, ...) Parameters option This specifies the kind of read to perform (optional; default is to read one line). This parameter can be repeated many times to return multiple strings. It can be one of: number  The number of bits to read  Ò*lÓ  Read a single line  Ò*aÓ  Read all the remaining data  Blocking No Returns string The block of decompressed data, or nil when no data is left. There can be multiple such values, if multiple option parameters were passed. Example local inFile, err1 = io.open(Ô/path/to/my/compressed/fileÕ, ÔrÕ) local outFile, err2 = io.open(Ô/path/to/my/decompressed/fileÕ, ÔwÕ) if inFile and outFile then local hdl = zlib.inflate(inFile) repeat local data = hdl:read(8192) if data and #data > 0 then outFile:write(data) end until not data or #data == 0 hdl:close() inFile:close() outFile:close() end 4.1.8.7 Memory Considerations Both compression and decompression require some internal buffers to perform their job. The larger the amount of memory, the better and faster the operation will be. The exact number of bytes allocated for compression is calculated as follows: (1 << (windowBits+2)) + (1 << (memLevel + 9)) For the default values of 15 and 8, this results in 262144 bytes, or 256KB, of memory being used. The windowBits and memLevel values can be tweaked to constrain the amount of memory used, at the expense of compression effectiveness and speed. The exact number of bytes allocated for decompression is calculated as follows: (1 << windowBits) + 11520 For the default value of 15, this results in 142592 bytes, or 139.25 KB, of memory being used. In this case, there is not as much flexibility in selecting a windowBits value, because it must be greater than or equal to the value used when originally compressing the data. The compress() and decompress() functions release this memory as soon as they have completed. However their streaming counterparts, deflate() and inflate(), keep the memory allocated until the close() method is called. Consider this when allocating many streams simultaneously. 4.1.9 Xymodem library The xymodem library is not automatically loaded on startup. It must first be loaded, for example, require ("xymodem"). 4.1.9.1 XYMRC_* Description Constants defining the possible return codes. XYMRC_OK (0) No error occurred. XYMRC_TIMEOUT (1) Download/Packet timeout occurred. XYMRC_CANCEL (2) Cancelled by user. XYMRC_NAK_ERROR (3) Too many NAKs. XYMRC_DATA_ERROR (4) Too many CRC or checksum errors. XYMRC_SEQ_ERROR (5) Bad sequence number. XYMRC_HANDLER_ERROR (6) Problem with the block handler. XYMRC_INIT_ERROR (7) Unable to initialize Y-modem file. 4.1.9.2 XYMP_* Description Constants defining the possible protocols. XYMP_CHKSUM (0) X-modem with 128-byte packets and 8-bit checksum. XYMP_CRC (1) X-modem with 128-byte packets and 16-bit CRC. XYMP_1K (2) X-modem with 1024-byte packets and 16-bit CRC. XYMP_YMODEM (3) Y-modem (X-modem compatible on receive) 4.1.9.3 receive() Description Receive file(s) using the specified protocol. Syntax receive(serial, proto, initFileCb, blockCb) Parameters  serial  The serial handle to use for the transfer.  proto initFileCb  The protocol to use for the transfer (XYMP_*). A function which is called when a new file is received. This is only used when the protocol is XYMP_ YMODEM. This function is given three arguments path the path of the file that is being received size the size of the file that is being received ts the timestamp of the file and must open the file, to be prepared to receive data. It must return true or false, to indicate success or failure.  blockCb  A function which is called when data is received. This function is given two arguments blockSize the number of bytes received data a string containing the received data and is responsible for writing the data to the file. It must return true or false, to indicate success or failure.  Returns  number  The return code (XYMRC_*)  4.1.9.4 receiveX() Description Receive file(s) using X-modem. This is a shortcut for receive(), with the protocol set to XYMP_1K. Syntax receiveX(serial) Parameters serial The serial handle to use for the transfer. Returns numberorstring A string of the received data, or the return code if there was a failure (XYMRC_*). 4.1.9.5 transmit() Description Transmit file(s) using the specified protocol. Syntax transmit(serial, proto, nextFileCb, blockCb) Parameters  serial  The serial handle to use for the transfer.  proto nextFileCb blockCb  The protocol to use for the transfer (XYMP_*). A function which is called when ready to send a new file. This is only used when the protocol is XYMP_ YMODEM. This function is not given any arguments, and must open the next file to send, to be prepared to send data. It must return the path of the file and the file size, or nil in case of error. A function which is called when ready to send a block of data. This function is given one argument blockSize the number of bytes to send and is responsible for reading a block of data of the given size from the file. It must return a string with the data and the data size, or nil on error.  Returns  number  The return code (XYMRC_*)  4.1.9.6 transmitX() Description Transmit file(s) using X-modem. This is a shortcut for transmit(), with the protocol set to XYMP_CRC. Syntax transmitX(serial,data,size) Parameters serial The serial handle to use for the transfer. data A string with the data to send. size The number of bytes to send. Returns number The return code (XYMRC_*). 4.1.9.7 getError() Description Converts the return code to a string describing the error. Syntax getError(code) Parameters code The return code (XYMRC_*). Returns string The error description, or ÒUnknown errorÓ if the code is invalid. 4.2 Scheduler The scheduler provides a cooperative thread dispatch system that supports the posting and waiting on queued events. The scheduler supports: ¥ Thread spawning/destroying and management functions ¥ Event queue creation and management functions ¥ Posting and waiting on event queues 4.2.1 Scheduler Module Functions 4.2.1.1 allThreads() Description A function iterator that calls the supplied function over all thread handles spawned by the system. Syntax sched.allThreads(func) Parameters func Lua function called as func(<thread handle>) Blocking No Returns None 4.2.1.2 createEventQ() Description Create a new event queue to collect posted events. Syntax sched.createEventQ(size, source, , ...) Parameters  size  Maximum size of the queue (integer)  source  Source of the event to collect (any non-nil Lua type)  ...  Optional events to collect. If missing, all events posted to the source are collected.  Blocking No Returns queue Event queue instance Example Create a queue five entries deep that collects system shutdown events. Local q = sched.createEventQ(5, svc.system, 'SHUTDOWN') See Also destroy() 4.2.1.3 delay() Description Yield the CPU and block for the specified duration in integer units of 1/10 of a second. NOTE: A duration value must be include (for example, sched.delay(0)), otherwise the software fails. Syntax sched.delay(duration) Parameters duration Duration in units of 1/10 of a second. A value must be included. Special timeouts are: 0 Ð Force a reschedule to free the CPU to allow other threads to execute -1 Ð Wait forever Blocking Yes Returns None Example Delay the current thread for 1.5 seconds. sched.delay(15) Yield the CPU and allow other ready threads to execute. sched.delay(0) Block forever (function never returns). sched.delay(-1) See Also: waitQ() 4.2.1.4 getThread() Description Given a string name, return the thread handle of the corresponding thread if it exists. Syntax sched.getThread(name) Parameters name String name of a thread or nil to specify the current thread Blocking No Returns threadHandle Handle of the thread Example Get the thread handle of the thread named ÒTestThreadÓ. local th = sched.getThread("TestThread") Get the thread handle of the current thread. local myThread = sched.getThread() See Also spawn() 4.2.1.5 post() Description Posts an event with a source of source and with optional arguments. Syntax sched.post(source, event, É) Parameters  source  Indicates the source of the event. This can be any non-nil Lua value  event  A Lua value that represents the event to be posted  É  Optional arguments that are returned by the wait() or waitQ() method of an event queue.  Blocking No Returns None Example Send Lua object data with string event DONE with a source of Worker. sched.post('Worker', 'DONE', data) Send the event wakeup with a source of _M. In this case, wakeup is an empty table that is guaranteed to be unique, and _M is the table of the current module. wakeup = {} . . . sched.post(_M, wakeup) See Also createEventQ() 4.2.1.6 spawn() Description Create a new named thread to be managed by the scheduler. The thread immediately becomes ready to run. Syntax sched.spawn(name, function, É) Parameters name Name to assign to the new thread (string) function Function to be called when the thread starts (function) É Optional arguments passed to the function when the thread starts Blocking No Returns thread Handle representing the thread Example local th = sched.spawn("myThread", testThread, 100) See Also terminate() 4.2.1.7 terminate() Description Terminate the thread specified by a thread handle. Syntax sched.terminate(threadHandle) Parameters threadHandle Thread handle representing the thread to be terminated. If nil or no arguments are present then the current thread is terminated. If a string, then the thread of that name is terminated, if it exists. Blocking No Returns None Example Create a thread called test consisting of the function myThread. Wait for 1 second, and then terminate the thread. local th = sched.spawn("test", myThread) sched.delay(10) sched.terminate(th) Cause a thread to terminate itself. sched.terminate() Terminate the thread named testthread. sched.terminate("testThread") See Also spawn(), terminate() 4.2.1.8 waitQ() Description Wait on zero or more event queues for events to be collected with a timeout. If a queue already has an event, then sched.waitQ() returns immediately. If multiple event queues have posted events, then sched.waitQ () returns the first event from the first queue in the parameter list. If multiple threads wait on the same event queue, then the first thread to wait for the event gets the event. Note: Calling sched.waitQ() with only a timeout and no queues is semantically the same as calling sched.delay (0). The use of sched.delay(0) is preferred as it results in clearer code and is a more efficient function. Syntax sched.waitQ(timeout, É) Parameters timeout Timeout in units of 1/10 of a second. Special timeouts are: 0 Ð Poll the queue for events and return immediately after yielding the CPU -1 Ð Wait forever É Optional list of event queues to wait on Blocking Yes Returns queue Queue that collected the event, or nil if the timeout occurred event Event that was posted É Optional event arguments pass to sched.post() Example Set up two queues: one to collect system shutdown events and the other to collect received to-mobile messages. The main loop then waits indefinitely on events posted to either queue. local sysQ = sched.createEventQ(1, svc.system, 'SHUTDOWN') local msgQ = sched.createEventQ(5, svc.transport) while true do local q, event = sched.waitQ(-1, sysQ, msgQ) if q == msgQ then --handle received message, where 'event is the event. elseif q == sysQ then --handle shutdown message else --should not happen end end Yield the CPU and allow other ready threads to run. This is a less efficient version of sched.delay(0). sched.waitQ(0) See Also post(), delay() 4.2.2 Thread Handle Methods The function sched.spawn() returns a handle that defines the following methods: 4.2.2.1 addTerminationHandler() Description Add a function and optional argument to be called when the thread terminates. Syntax <thread>:addTerminationHandler(func, closure) Parameters func Function to call when the thread terminates. The function is called with the following arguments: thread The thread handle of the terminated thread closure The closure argument passed to addTerminationHandler() result Boolean value of true if the thread finished normally, or false if a runtime error occurred errMsg Error message string if result is false, otherwise nil traceBack Traceback string of error location if result is false, otherwise nil closure User argument passed to func Blocking No Returns None Example Register the handler function reaper to be called when the thread ÒMy threadÓ terminates. function reaper(thread) print("Thread '", thread, "' terminated") end . . . th = sched.spawn("My thread", myThreadFunc) th:addTerminationHandler(reaper) See Also spawn(), terminate() 4.2.2.2 destroy() Description Destroys the thread handle. If the thread is still active, it is terminated. Syntax <thread>:destroy() Parameters None Blocking No Returns None See Also spawn(), terminate() 4.2.2.3 dispatches() Description This method returns the number of times the thread has been dispatched by the scheduler. Syntax <thread>:dispatches() Parameters None Blocking No Returns number Number of times the thread has been dispatched 4.2.2.4 maxExecutionTime() Description This method returns the maximum execution time of the thread in milliseconds. Syntax <thread>:maxExecutionTime() Parameters None Blocking No Returns number The maximum execution time of the thread in milliseconds 4.2.2.5 name() Description Returns the name of the thread. Syntax <thread>:name() Parameters None Blocking No Returns name String name of thread or nil if not found Example Print ÒMy ThreadÓ; the name of the spawned thread. local myThread = sched.spawn("My Thread", testFunc) print(myThread:name()) Print the name of the current thread. print(sched.getThread():name()) See Also getThread(), spawn() 4.2.2.6 removeTerminationHandler() Description Given a handle returned by addTerminationHandler(), remove the termination handler function. Syntax <thread>:removeTerminationHandler(handle) Parameters handle Handle returned by a call to addTerminationHandler() Blocking No Returns None Example Add the function handlerFunc() with argument myData as a termination handler to the thread represented by th. The handle is saved in tHandle and then used later to remove the handler function. tHandle = th:addTerminationHandler(handlerFunc(), myData) . . . th:removeTerminationHandler(tHandle) See Also addTerminationHandler() 4.2.2.7 status() Description Returns the Lua thread status of the thread. This function maps to the Lua coroutine.status()call. Syntax <thread>:status() Parameters None Blocking No Returns status Lua thread status (one of running, suspended or dead) Example Print the status of the current thread that would be running. print(sched.getThread():status()) See Also getThread(), spawn() 4.2.2.8 terminate() Description Terminate the thread represented by the thread handle. Syntax <thread>:terminate() Parameters None Blocking No Returns None Example Create a thread called ÒtestÓ consisting of the function myThread. Wait for 1 second, and then kill the thread. local theadH = sched.spawn("test", myThread) sched.delay(10) threadH:terminate() See Also spawn(), terminate() 4.2.2.9 thread() Description Returns the underlying Lua thread of a thread handle. Syntax <thread>:thread() Parameters None Blocking No Returns thread Lua thread See Also status() 4.2.2.10 totalExecutionTime() Description This method returns the cumulative execution time of the thread in milliseconds. Syntax <thread>:totalExecutionTime() Parameters None Blocking No Returns number The cumulative execution time of the thread in milliseconds 4.2.3 Event Queue Methods The methods below can be used on the event queue object returned by createEventQ(). 4.2.3.1 clear() Description The clear function removes all currently collected events from the queue. Syntax <queue>:clear() Parameters None Blocking No Returns None See Also count() 4.2.3.2 count() Description Returns the current number of events in the event queue. Syntax <queue>:count() Parameters None Blocking No Returns count Current number of events in the event queue See Also clear() 4.2.3.3 destroy() Description Destroys the event queue. Syntax <queue>:destroy() Parameters None Blocking No Returns None Example Destroy the event queue q. q:destroy() See Also createEventQ() 4.2.3.4 event() Description Returns the first event that the event queue was created to collect, or nil if no event was specified. This method is present for backwards compatibility. Use the events() method. Syntax <queue>:event() Parameters None Blocking No Returns event First event or nil if no event was specified on queue creation See Also createEventQ() 4.2.3.5 events() Description Returns a table containing all events that the event queue was created to collect. The table is empty if no event was specified. Syntax <queue>:events() Parameters None Blocking No Returns events Table of all events 4.2.3.6 lastEvent() Description Returns the last queued event and arguments. Syntax <queue>:lastEvent() Parameters None Blocking No Returns event The collected event É Arguments passed to the post() call 4.2.3.7 lastEventTime() Description Returns the time stamp associated with the last retrieved event. Syntax <queue>:lastEventTime() Parameters None Blocking No Returns table A table containing the following fields: sec The seconds portion of the time stamp msec Example local q, ev, args = myQ:wait(-1) if q == myQ then if ev == ÒMYEVENTÓ then local ts = myQ:lastEventTime() printf(ÒMYEVENT was sent at %d.%03d seconds\nÓ, ts.sec, ts.msec) end end 4.2.3.8 name() Description Returns and optionally sets the name of the event queue. Syntax <queue>:name(name) Parameters name Optional string name to give value in the output Blocking No Returns name Returns the string name of the event queue Example Create a message queue and name it message queue. msgQ = sched.createEventQ(3, svc.transport) msgQ:name('message queue') Print the name, if any, of myQ. myQ:name() 4.2.3.9 size() Description Returns the size of the event queue. Syntax <queue>:size() Parameters None Blocking No Returns size Maximum number of events the event queue can hold See Also createEventQ() 4.2.3.10 source() Description Returns the source that the event queue was created to collect. Syntax <queue>:source() Parameters None Blocking No Returns source Returns the source of the event queue See Also createEventQ() 4.2.3.11 wait() Description Blocks the event queue until an event is collected or the timeout, if specified, occurs. If the queue already has an event, then the call to wait() returns immediately. Syntax <queue>:wait(timeout) Parameters  timeout  Timeout in units of 1/10 of a second. Special timeouts are: 0 Ð Poll the queue for events and return immediately after forcing rescheduling -1 Ð Wait forever  Blocking Yes Returns queue Queue that collected the event, or nil if the timeout occurred event Event that was posted É Optional event arguments pass to post() Example Wait on the event queue for the ALARM event of the geofence service for up to 180 seconds. gpsQ = sched.createEventQ(5, svc.geofence, ÔALARMÕ) . . local q, event = gpsQ:wait(180) See Also waitQ() 4.3 Service Manager The Service Manager provides facilities to manage and control services. Services are software modules that implement the user-visible terminal functionality. Each service is identified by a service identification number (SIN). SIN values in the range 0-15 are reserved for use by the IsatData Pro satellite modem. SIN values in the range 16-127 are reserved for services implemented by ORBCOMM; those in the range of 16-63 are referred to as core services, those in the range of 64-127 as terminal apps. SIN values in the range 128-255 are free to be used by ORBCOMM's customers in implementing their own services; these are usually referred to as user services. Each service can optionally define the format of the various messages that they can send and receive over-the-air. Each message format is identified by the direction in which it is used and a message identification number (MIN). The message directions are commonly referred to as to-mobile, for message going to the terminal, and from-mobile, for message coming from the terminal. Each service can optionally define a number of properties. Properties are values related to the functionality of the service and can be one of two types. Configuration properties are static in nature, and are generally used to affect the service's behavior. Volatile properties are more dynamic in nature, and are generally used to report status information. Each property is identified by a property identification number (PIN). 4.3.1 dataPath() Description This function returns the name of a directory where a service should store its data files. Syntax svcmgr.dataPath() Parameters None Blocking No Returns string The directory path 4.3.2 decodeMsg() Description This function decodes a binary encoded message. Syntax svcmgr.decodeMsg(dir, bytes) Parameters  dir  The message direction (msgs.Direction.RETURN(1), msgs.Direction.FORWARD(0))  bytes  A string containing the message bytes  Blocking  No  Returns  string  An error message on failure, or nil otherwise  table  The decoded message  number  The number of bits used in decoding the message  4.3.3 disableService() Description This function adds or removes a service from the list of disabled services. The disabled services are prevented from starting up on the next framework restart. Syntax svcmgr.disableService(sin, disable) Parameters sin The service to disable/enable disable A Boolean, true=disable the service, false=enable the service Blocking No Returns boolean Indicates success or failure 4.3.4 encodeMsg() Description This function verifies and encodes the fields of a message into the binary common format. Syntax svcmgr.encodeMsg(msg) Parameters  msg  A table with the following fields:  sin  The service identification number of the service containing the message  min  The message identification number of the message  dir  The message direction (msgs.Direction.RETURN(1), msgs.Direction.FORWARD(0))  fields  A table containing the message fields and their values  Blocking  No  Returns  string  An error message on failure, or nil otherwise  string  The encoded message (binary)  number  The number of bits used to encode the message  4.3.5 getDisabledServices() Description This function returns a list of services that are currently disabled. Syntax svcmgr.getDisabledServices() Parameters None Blocking No Returns table An array of SINs 4.3.6 getInfo() Description Retrieves information about a given service. Syntax svcmgr.getInfo(sin) Parameters sin The service identification number (16-255) Blocking No Returns: table The service information, with the following fields: sin The service identification number name The name of the service version The version of the service enabled Indicates whether the service is enabled or not 4.3.7 getList() Description Retrieves a list of services currently installed and not disabled. Syntax svcmgr.getList(core) Parameters core Whether to get only core services (true) or not (false) Blocking No Returns table An array of the requested SINs sorted in ascending order 4.3.8 getMsgDef() Description Retrieves the definition of a message. Syntax svcmgr.getMsgDef(sin, min, dir) Parameters sin The service identification number (16-255) min The message identification number (1-255) dir The message direction (0 Ð To-mobile, 1 Ð From-mobile) Blocking No Returns table The message definition with the following fields, or nil on error: name The message's name fields An array with each entry containing the following: name The field name type The field type (Section 5.1) size The field size (in bytes (B) for data and string in bit (b)for others) Each entry may also contain the following fields: optional Denotes whether the field is optional fixed Denotes whether a string or data field is of a fixed size values A table defining the mapping between Enum names and their associated values (only enum type) valuesStr A table defining the mapping between Enum values and their associated names (only enum type) sin The SIN for the service from which a property value will be used (only property type) pin The PIN of the property value to use (only property type) string An error message, or nil if none occurred 4.3.9 getProp() Description Retrieves a property value from a given service. Syntax svcmgr.getProp(sin, pin) Parameters sin The service identification number (16-255) pin The property identification number (1-255) Blocking No Returns The property value, or nil on error string An error message, or nil if none occurred 4.3.10 getPropDef() Description Retrieves the definition of a property. Syntax svcmgr.getPropDef(sin, pin) Parameters sin The service identification number (16-255) pin The property identification number (1-255) Blocking No Returns  table  The property definition with the following fields, or nil on error:  name  The property's name  type  The property's type (Section 5.1)  storage  The property storage type (0 Ð Config, 1 Ð Volatile)  default  The property's default value  The property definitions may also contain the following fields:  minVal  The minimum value supported by the property (only integer types)  maxVal  The maximum value supported by the property (only integer types)  values  A table defining the mapping between enum names and their associated values  (only enum type)  valuesStr  A table defining the mapping between enum names and their associated names  (only enum type)  string  An error message, or nil if none occurred  4.3.11 getPropList() Description Retrieves a list of PINs for a given service. Syntax svcmgr.getPropList(sin) Parameters sin The service identification number (16-255) Blocking No Returns table An array of the PINs for that given service stored in ascending order 4.3.12 loadCode() Description This function is a wrapper around loadfile. It loads the specified file from the appropriate service directory, sets it to run within the calling service's environment, and returns the loaded chunk. It is up to the caller to run the chunk to load its contents. Syntax svcmgr.loadCode(name) Parameters name The name of the Lua file to load, without any path information Blocking No Returns function The loaded, compiled chunk, or nil on error string An error message, or nil if successful 4.3.13 resetProps() Description Reset multiple properties to their default values. Syntax svcmgr.resetProps(list) Parameters  list  An array wisin pinList  th each element containing the following fields: The service identification number (16-255) An array of PINs to reset  Blocking No Example svcmgr.resetProps({{sin=20,pinList={15}},{sin=22,pinList={31,43,44}}}) Returns string An error message, or nil if none occurred 4.3.14 restart() Description Restart a service. Syntax svcmgr.restart(sin) Parameters sin The SIN for the service to restart (16-255) Blocking No Returns string An error message in case of failure, or nil 4.3.15 revertProps() Description Reverts multiple properties to their saved values. Only configuration properties are affected; volatile properties are ignored. Syntax svcmgr.revertProps(list) Parameters  list  An array with each element containing the following fields:  sin  The service identification number (16-255)  pinList  An array of PINs to save  Blocking  No  Example  svcmgr.revertProps({{sin=20,pinList={15}},{sin=22,pinList={31,43,44}}}) Returns string An error message, or nil if none occurred 4.3.16 saveProps() Description Save multiple properties' values to nonvolatile storage. Only configuration properties are saved; volatile properties are ignored. Syntax svcmgr.saveProps(list) Parameters list Optional array with each element containing the fields below. Omitting this parameter results in all properties being saved to NVM. sin The service identification number (16-255) pinList An array of PINs to save Blocking Yes Example svcmgr.saveProps({{sin=20,pinList={15}},{sin=22,pinList={31,43,44}}}) Returns string An error message, or nil if none occurred 4.3.17 setProp() Description Set a property value on a given service. Syntax svcmgr.setProp(sin, pin, val) Parameters  sin pin val  The service identification number (16-255) The property identification number (1-255) The value to set  Blocking No  Returns  string  An error message, or nil if none occurred  4.3.18 setProps() Description Set multiple property values. This operation is performed in two passes; first all property values are validated, and if they are all valid, then they are applied. Syntax svcmgr.setProps(list) Parameters list An array with each element containing the following fields: sin The service identification number (16-255) propList An array with each element containing the following: pin value  The property identification number The desired property value  Blocking No  Example  svcmgr.setProps({{sin=20, propList={{pin=15,value=2}}},{sin=22,propList={{pin=31,value=4}, {pin=43,value=2}}}}) Returns string An error message, or nil if none occurred 4.3.19 validateSin() Description Validate a SIN. Syntax svcmgr.validateSin(sin) Parameters sin The SIN to validate (16-255) Blocking No Returns boolean Indicates whether the sin is valid and identifies a service that is not disabled 4.3.20 verifyProp() Description Check whether a value is valid for the given property. Syntax svcmgr.verifyProp(sin, pin, val) Parameters sin The service identification number (16-255) pin The property identification number (1-255) val The property value to test Blocking No Returns boolean Indicates whether the property value is valid string An error message describing the problem with the first value is false or nil 4.4 Message Library 4.4.1 Direction Description This table maps message direction names to their numerical values. It has the following fields: FORWARD RETURN  0 1  Syntax msgs.Direction  4.4.2 DirectionStr  Description  This table does the reverse of Direction; it maps numerical values to direction names. It has the following indices: 0 FORWARD 1 RETURN Syntax msgs.DirectionStr 4.4.3 Types Description This table maps message field and property type names to their numerical values. It has the following fields: ENUM 0 BOOLEAN 1 UNSIGNED 2 SIGNED 3 STRING 4 DATA 5 ARRAY 6 DYNAMIC 7 PROPERTY 8 MESSAGE 9 Syntax msgs.Types 4.4.4 TypesStr Description This table does the reverse of Types; it maps numerical values to type names. It has the following indices: 0 ENUM 1 BOOLEAN 2 UNSIGNED 3 SIGNED 4 STRING 5 DATA 6 ARRAY 7 DYNAMIC 8 PROPERTY 9 MESSAGE Syntax msgs.TypesStr 4.5 Property Library 4.5.1 Storage Description This table maps property storage class names to their numerical values. It has the following fields: CONFIG 0 VOLATILE 1 Syntax props.Storage 4.5.2 StorageStr Description This table does the reverse of Storage; it maps numerical values to storage class names. It has the following indices:  0  CONFIG  1  VOLATILE  Syntax  props.StorageStr 4.6 Utilities 4.6.1 clone() Description Create a clone of a Lua object. This new object is a deep copy and does not reference any parts of the original object. Syntax clone(obj) Parameters obj The Lua object to clone; can be any valid Lua type Blocking No Returns object A copy of the original object 4.6.2 dumpvar() Description Recursively dump the types of an arbitrary Lua data structure. Syntax dumpvar(value, name, limit, dumpMem) Parameters  value  Lua value to dump  name  Optional string name to give value in the output  limit  Optional integer which limits the depth of the output recursion  dumpMem  Optional Boolean which indicates if object size information should be included in the output  Blocking Yes Returns None Example Display a complex table. lua> t = { "one", "two", "three", opts = { fast = true, SIN = 21 } } lua> dumpvar(t) ["table: 64041470"] = { --table: 64041470 (count= 3) [1] = "one"; [2] = "two"; [3] = "three"; opts = { --table: 640578d8 (count= 0) SIN = 21; fast = true; }; }; Use dumpvar() to display all the available functions and tables in the global environment. The name _G is used to label the table and the limit two is used to print only the top level content of the table. lua> dumpvar(_G, '_G', 2) _G = { --table: 640105a0 (count= 0) print = function: 64095d48; string = table: 64013720; --LIMIT xpcall = function: 64010b98; pairs = function: 64011a00; package = table: 64011518; --LIMIT tostring = function: 64010b58; gcinfo = function: 64011098; props = table: 64022858; --LIMIT msgs = table: 64010498; --LIMIT _VERSION = "Lua 5.1"; os = table: 64013618; --LIMIT unpack = function: 640111e0; tonumber = function: 64011198; _RELEASE = "Lua 5.1.4"; require = function: 640124d8; getfenv = function: 640110d8; svcmgr = table: 64022f88; --LIMIT tracef = function: 640191f8; setmetatable = function: 640118b0; next = function: 64011028; assert = function: 64010f68; sys = table: 64022518; --LIMIT ipairs = function: 64011998; printf = function: 6408b7b8; io = table: 64012b90; --LIMIT rawequal = function: 64011398; md5 = table: 64015510; --LIMIT collectgarbage = function: 64010e68; _LNUM = "float int32"; newproxy = function: 64011ab0; sched = table: 6401bd68; --LIMIT module = function: 64012498; makeEnum = function: 6401a798; toHex = function: 6401a678; dogc = function: 6401b990; objsize = function: 6401b8c8; _G = ref"table: 640105a0"; tdumpvar = function: 6401b7a0; args = table: 640106b0; --LIMIT LSF_BUILD_TIME = "16:22:00"; LSF_BUILD_DATE = "Jun 21 2011"; LSF_FIRMWARE_API_COMPATIBILITY_LEVEL = 21; LSF_API_LEVEL = 1; rawset = function: 64011138; math = table: 64013cd8; --LIMIT trace = function: 640191b0; pcall = function: 64011318; dumpvar = function: 64019fb8; base64 = table: 640153f8; --LIMIT type = function: 640118f8; bit32 = table: 64014fc8; --LIMIT debug = table: 64014cb8; --LIMIT select = function: 64011158; getmetatable = function: 64010fa8; LSF_VERSION = "3.2.0"; rawget = function: 64011118; loadstring = function: 64011008; table = table: 64012558; --LIMIT load = function: 64010fe8; setfenv = function: 64010b10; svc = table: 64031638; --LIMIT error = function: 64010e88; loadfile = function: 64010fc8; }; See Also print() 4.6.3 makeEnum() Description This function creates two lists, one mapping the entries in the names list to their numerical values, the other mapping the numerical values to their string representations. These lists are useful for implementing and accessing enumerated types. The first string in the list is assigned the value 0, the second one 1, and so on. Syntax makeEnum(names) Parameters names A table containing a list of strings for the enumerated type values Blocking No Returns table A table that maps string values to their numerical equivalents table A table that maps numerical values to their string equivalents Example The following code Parity, ParityStr = makeEnum({"NONE", "ODD", "EVEN", "MARK", "SPACE"}) par = 1 print(ParityStr[par]) par = Parity.NONE print(ParityStr[par]) results in the following text being output. ODD NONE 4.6.4 tdumpvar() Description Same as dumpvar() except that the output is sent to the serial tracing facility. Syntax tdumpvar(value, name, limit, dumpMem) Parameters  value  Lua value to dump  name  Optional string name to give value in the output  limit  Optional integer which limits the depth of the output recursion  dumpMem  Optional Boolean which indicates if object size information should be included in the output  Blocking Yes Returns None 4.6.5 toHex() Description Convert the bytes of a string into a string of hexadecimal digits. Syntax toHex(string) Parameters string String to convert Blocking No Returns string A string of hexadecimal digits Example lua> print(toHex("12345")) 3132333435 5 CORE SERVICES Description Provides general management and control of such things as service identification, metrics, and status query/response. Unified interface to power management at the Lua level. Routes incoming messages to the appropriate service and ensures outgoing messages use the appropriate format. Sends report messages that consist of properties from other services. Messages can be sent on demand or on a preconfigured schedule. Interface to GPS position information. Includes position-based accelerometer capabilities. The geofence service provides the ability to define geographical regions based on circles, polygons, rectangles, as well as reporting entry and exit from these regions. Manages communication through the various serial ports (RS-232, RS-485), including their configuration and status. Stores data in nonvolatile storage. The data can be application data, which can be retrieved at later date, or diagnostic information for troubleshooting. This service also provides auto upload capabilities. Provides an interface for the file system that is in the application firmware. Configures and reports the status of the general purpose I/O. In addition, it is used to monitor the internal temperature . Alarms can be configured if thresholds are exceeded. Shell command-line interface on the RS-232 interface. It also provides the ability to execute the same commands over-the-air and allows you to change the access level of the shell. Provides access to some of the functionality offered by the IsatData Pro satellite modem. -Provides support for JSON and binary encoding of messages, allows configuration and monitoring of the module; and also provides a plugin to the message service allowing it to send/receive messages over cellular. (cellular and satellite-cellular terminals) --32 campaign A mandatory service that must be running to support software over-the-air updates. 33 ip Allows ST products to take advantage of protocols and their associated features on the internet for the development of IP enabled Lua applications. 34 accelerometer Defines the global configuration of the accelerometer API. 35 bluetooth Provides global management and control over the Bluetooth operations. Only available on terminals that support Bluetooth hardware. SINName16system17power18message19report20position21geofence22serial23log24filesystem25eio26shell27idp28reserved29cell30reserved31reserved5.1 Types Property and message fields are defined in terms of their type. This section describes the various types available, and how they are handled. Reserved or undocumented core properties (PINs) are for ORBCOMM use only. Table 1: Field Types Supported Field Type1 Description Properties support: ENUM (0) An enumeration, a common construct in some high-level programming languages. It maps a defined set of strings to numerical values; the makeEnum() function is useful for generating such a mapping. ENUMs can be from 1 to 16 bits wide and can support up to 65535 values. BOOLEAN (1) A simple true/false type. UNSIGNED (2) Used to represent unsigned integer values from 1 to 31 bits wide. SIGNED (3) Used to represent signed integer values from 1 to 32 bits wide. STRING (4) Used to represent string values. String objects can be up to 32767 characters long. DATA (5) Used to easily represent data (byte) arrays, without having to resort to strings (that are typically for printable characters) or the more generic arrays. Data objects can be up to 32767 bytes long. Message fields also support: ARRAY (6) Used to represent a combination of arrays and data structures. The ARRAY is further defined as containing more fields. Array objects can contain up to 32767 entries. DYNAMIC (7) Used when the actual type of a value is not known ahead of time. A description of the contained type is passed in any over-the-air messages, prior to the value, so that the receiver can figure out on the fly what the content is. PROPERTY (8) Used in message definitions as a placeholder to indicate a spot in the message where a service property value needs to be inserted. The definition specifies the property's SIN and PIN, and the framework automatically fills the value in prior to sending the message. This is mainly useful for easily defining new report formats (Section 5.5). MESSAGE (9) Used in message definitions as a placeholder to indicate a spot in the message where another message is inserted in its entirety. 5.2 System (SIN 16) The system service provided management and control of the global aspects of the terminal. 5.2.1 Properties 1The unit of the field size for a particular field is dependent on the field type. 5.2.2 To-Mobile Messages MIN Name Description 1 Request terminal information. A terminalInfo message is generated in response. 2 Request terminal status. A terminalStatus message is generated in response. 3 Request a list of all services. A serviceList message is generated in response. 4 Request information for one or more services. A serviceInfo message is generated in response. 5 Request to restart a service. 6 Resets the terminal (modem and LSF). All terminal hardware is reset regardless of the field value. 7 getTerminalMetrics Request current terminal metrics. Currently, no message is generated in response, because no metrics have been defined. 8 Request the value of one or more properties. A propertyValues message is generated in response. 9 Sets the value of one or more properties. 10 Resets one or more properties to their default values. 11 Saves one or more property values to nonvolatile storage. 12 Reverts one or more property values from nonvolatile storage. 13 Restarts the Lua Framework. 14 Sets the Solution Provider (level 1) password value 15 Disables or re-enables a service on the terminal. The service is not loaded / unloaded until a subsequent restart of the Lua Service Framework (LSF). Generates a disableServiceResult message in response. 16 This message sets the full list of enabled services. Any SINs not in this list are disabled. 17, 18 reserved -getTerminalInfogetTerminalStatusgetServiceListgetServiceInforestartServiceresetTerminalgetPropertiessetPropertiesresetPropertiessavePropertiesrevertPropertiesrestartFrameworksetPassworddisableServicesetEnabledServices5.2.2.1 getTerminalInfo (SIN 16, MIN 1) This message does not contain any fields. A terminalInfo message is generated in response. 5.2.2.2 getTerminalStatus (SIN 16, MIN 2) This message does not contain any fields. A terminalStatus message is generated in response. 5.2.2.3 getServiceList (SIN 16, MIN 3) This message does not contain any fields. A serviceList message is generated in response 5.2.2.4 getServiceInfo (SIN 16, MIN 4) 5.2.2.5 restartService (SIN 16, MIN 5) 5.2.2.6 resetTerminal (SIN 16, MIN 6) 5.2.2.7 getTerminalMetrics (SIN 16, MIN 7) This message does not contain any fields. No message is generated in response. 5.2.2.8 getProperties (SIN 16, MIN 8) 5.2.2.9 setProperties (SIN 16, MIN 9) Name Type Optional Size Comments list Array No ²255 elements .sin Unsigned No 8 bits .propList Array No ²255 elements .pin Unsigned No 8 bits .value Dynamic No n/a .save Boolean No 1 bit If true, saves the new property values after setting them 5.2.2.10 resetProperties (SIN 16, MIN 10) 5.2.2.11 saveProperties (SIN 16, MIN 11) 5.2.2.12 revertProperties (SIN 16, MIN 12) 5.2.2.13 restartFramework (SIN 16, MIN 13) This message does not contain any fields. 5.2.2.14 setPassword (SIN 16, MIN 14) 5.2.2.15 disableService (SIN 16, MIN 15) 5.2.2.16 setEnabledServices (SIN 16, MIN 16) 5.2.2.17 Reserved (SIN 16, MIN 17) This message is reserved. 5.2.2.18 Reserved (SIN 16, MIN 18) This message is reserved. 5.2.3 From-Mobile Messages 5.2.3.1 terminalInfo (SIN 16, MIN 1) This message contains static information about the terminal. 5.2.3.2 terminalStatus (SIN 16, MIN 2) This message contains dynamic information about the terminal. Name Type Comments uptime Signed No 32 bits The number of seconds the terminal has been in continuous operation since reset timeOfDay Signed No 32 bits The current date and time, expressed as number of seconds since the epoch hardwareResetReason Enum No 8 bits The reason for the last terminal reset. 0 Ð Unknown 1 Ð PowerOn 2 Ð External 3 Ð WindowWD 4 Ð IndependentWD 5 Ð LowPower 6 Ð Software 7 Ð JTAG 8 Ð CoreLockup Name Type Comments softwareResetReason Enum No 8 bits The cause of the software reset 0 Ð None (hardwareResetReason is software) 1 Ð Unknown 2 Ð Exception 3 Ð CAssert 4 Ð CMSISAssert 5 Ð AbnormalExit 6 Ð KernelError 7 Ð Panic 8 Ð BootIdle 9 Ð BootConsole 10 Ð Startup 11 Ð Console 12 Ð PasswordFailure 13 Ð CriticalLog 14 Ð RFHardware 15 Ð Update 16 Ð LossOfPower 17 Ð SwWatchdog 18-19 Ð Reserved 20 Ð Lua 21 Ð LuaPanic 22 Ð LuaOTA 23 Ð LuaShell 24 Ð LuaAPI 25 Ð LuaSerial 26 Ð IDPModem softwareResetDescription String No ²1000 Additional information about the software reset cause bytes LSFUptime Signed No 32 bits The number of seconds the LSF has been running powerSaveTime Signed No 32 bits The number of seconds the terminal has been in power save mode since reset LSFIdleTime Signed No 31 bits The number of seconds since startup that the LSF has been idle waiting for an event. 5.2.3.3 serviceList (SIN 16, MIN 3) 5.2.3.4 serviceInfo (SIN 16, MIN 4) 5.2.3.5 propertyValues (SIN 16, MIN 5) 5.2.3.6 termReset (SIN 16, MIN 6) This message does not contain any fields and is used only for logging purposes. It is never sent out. 5.2.3.7 terminalRegistration (SIN 16, MIN 8) NameTypeOptionalSizeCommentslistArrayNo²255elementsAlistofservicessinUnsignedNo8bitsTheSINpropListArrayNo²255elementsAlistofpropertiesforthatservicepinUnsignedNo8bitsThePINvalueDynamicNon/aThepropertyvalueOptionalSizeName Type Comments hardwareVariant Enum No 8 bits hardwareRevision Unsigned No 8 bits hardwareResetReason Enum No 8 bits Section 5.2.3.1. 0 Ð Unknown 1 Ð PowerOn 2 Ð External 3 Ð WindowWD 4 Ð IndependentWD 5 Ð LowPower 6 Ð Software 7 Ð JTAG 8 Ð CoreLockup firmwareMajor Unsigned No 8 bits firmwareMinor Unsigned No 8 bits firmwarePatch Unsigned No 8 bits LSFVersion String No ²16 bytes Version of the Lua services framework Name Type Comments softwareResetReason Enum No 8 bits The cause of the software reset 0 Ð None (hardwareResetReason is 1 Ð Unknown Software) 2 Ð Exception 3 Ð CAssert 4 Ð CMSISAssert 5 Ð AbnormalExit 6 Ð KernelError 7 Ð Panic 8 Ð BootIdle 9 Ð BootConsole 10 Ð Startup 11 Ð Console 12 Ð PasswordFailure 13 Ð CriticalLog 14 Ð RFHardware 15 Ð Update 16 Ð LossOfPower 17 Ð SwWatchdog 18-19 Ð Reserved 20 Ð Lua 21 Ð LuaPanic 22 Ð LuaOTA 23 Ð LuaShell 24 Ð LuaAPI 25 Ð LuaSerial 26 Ð IDPModem sinList Data No 240 bytes Each byte in the data field is the SIN of an installed and enabled service packageVersion String No 32 bytes Version string of the loaded package file 5.2.3.8 setPasswordResult (SIN 16, MIN 9) This message is sent in response to setPassword. 5.2.3.9 disableServiceResult (SIN 16, MIN 10) This message is sent in response to a disableService request. 5.2.3.10 newTimeSync This message is logged when system time is adjusted. Name  Type  Optional  Size  Comments  delta     The time adjustment, in seconds. A negative value indicates the time moved backwards.  source  Enum  No  4 bits  The time source that was used to set the internal system clock (IsatData Pro terminals). 0 Ð None 1 Ð NTP 2 Ð Cellular 3 Ð GNSS 4 Ð IDP  5.2.4 Constants The system service defines the following constants. 5.2.4.1 shutdownCause Description This table maps shutdown causes to their numerical values. It has the following fields: Unknown  0  API  1  OTA  2  Shell  3  Campaign  4  Serial  5  Error  6  IDPModem  7  Switch  8  LowBattery  9  reserved  10  reserved  11  Syntax  svc.system.shutdownCause 5.2.4.2 shutdownCauseStr Description This table does the reverse of shutdownCause; it maps numerical values to cause reason strings. It has the following fields:  0 1 2 3 4 5 6 7 8 9 10 11  Unknown API OTA Shell Campaign Serial Error IDPModem Switch LowBattery reserved reserved  Syntax  svc.system.shutdownCauseStr 5.2.4.3 shutdownReason Description This table maps shutdown reasons to their numerical values. It has the following fields: Stop 0 Restart 1 Reset 2 PowerOff 3 Syntax svc.system.shutdownReason 5.2.4.4 shutdownReasonStr Description This table does the reverse of the shutdownReason; it maps numerical values to shutdown reason strings. It has the following fields: 0 Stop 1 Restart 2 Reset 3 PowerOff Syntax svc.system.shutdownReasonStr 5.2.5 Functions 5.2.5.1 ledFlash() This function has been deprecated. See sys.led.flash(). 5.2.5.2 reset() Description Resets the application card. Syntax svc.system.reset(now) Parameters  now  Optional Boolean that forces immediate reset if specified and set to true, otherwise a clean  shutdown occurs before the reset.  Blocking Yes Returns None Example Resets the application card svc.system.reset() See Also restart() 5.2.5.3 restart() Description Restart the Lua services framework. Syntax svc.system.restart(now) Parameters  now  Optional Boolean that forces immediate restart if specified and set to true, otherwise a clean  shutdown occurs before the restart.  Blocking No Returns None Example Shut down the LSF and then restart it. svc.system.restart() See Also reset() 5.2.5.4 shutdown() Description Shuts down the LSF and drop to the application firmware command prompt on the main serial interface. Syntax svc.system.shutdown(now) Parameters now Optional Boolean that forces immediate shutdown if specified and set to true, otherwise a clean shutdown occurs. Blocking No Returns None Example Shut down the LSF and enter the application firmware command console. svc.system.shutdown() See Also reset() 5.2.6 Posted Events 5.2.6.1 Shutdown Description This event is posted before the system shuts down. If the system is forced to shut down immediately, then this event is not posted. Source  svc.system  (system service table)  Event  ÒSHUTDOWNÓ  (string)  Arguments table A table containing the following fields: reason The reason for the shutdown: 0 Ð Stop 1 Ð Restart 2 Ð Reset 3 Ð PowerOff cause The cause of the shutdown event: 0 Ð Unknown 1 Ð API 2 Ð OTA 3 Ð Shell 4 Ð Campaign 5 Ð Serial 6 Ð Error 7 Ð IDPModem 8 Ð Switch 9 Ð LowBattery 10 Ð reserved 11 Ð reserved 5.2.6.2 Terminal Registered Description This event is posted when the terminal completes registration. Source svc.system (system service table) Event ÒTERMINAL_REGISTEREDÓ (string) Arguments None 5.2.6.3 Time Synchronization Description This event is posted when the terminal time of day is synced to an external source. Source Event  svc.system ÒTIME_SYNCÓ  (system (string)  service  table)  Arguments  number The delta between the new and old times, in seconds (negative if old>new) string The time source 5.3 Power (SIN 17) The power service provides a unified interface to terminal power management at the Lua level. The power service does not apply to ST 6000 models because power is managed externally. 5.3.1 Properties PIN Name Description Type Storage Default Class Value 1 batteryConfig Battery configuration of the terminal Enum Volatile None 0 Ð None An ST 9100 with battery is LilON, without 1 Ð reserved a battery it is ÔDisabledÕ. 2 Ð reserved 3 Ð reserved 4 Ð LiION 2 batteryChargerState Current state of the charger Enum Volatile Disabled 0 Ð Disabled 1 Ð reserved 2 Ð Charging 3 Ð reserved 4 Ð reserved 5 Ð Suspended 6 Ð Fault 7 Ð Aborted PIN Name Description Type Storage Default Class Value 24 postTriggerVoltage The voltage in mV just after the start of Unsigned Volatile n/a the last satellite modem transmit. Min. Ð 0 Max. Ð 32000 25-reserved ---.29 30 ledControl Determines whether the Power LED is Enum Config Terminal controlled by the user or the terminal. 0 Ð Terminal 1 Ð User Refer to [T404] for more details. 5.3.2 To-Mobile Messages 5.3.2.1 powerOff (SIN 17, MIN 1) 5.3.3 From-Mobile Messages 5.3.3.1 extPowerAlarm (SIN 17, MIN 1) 5.3.3.2 powerOnAlarm (SIN 17, MIN 2) 5.3.3.3 powerOffResult (SIN 17, MIN 3) 5.3.3.4 reserved (SIN 17, MIN 4) 5.3.4 Constants The power service defines the following constants. 5.3.4.1 PowerOnReason Description This table contains a mapping of the power on reasons to their numerical value. Refer to PIN 13 for product specific values and descriptions. Unknown  0  External  1  (ST 9100 only)  reserved  2  reserved  3  Timer  4  reserved  5  ResetButton  6  (ST 9100 only)  Temperature 7  (ST 9100 only, battery shutdown)  Syntax  svc.power.PowerOnReason 5.3.4.2 PowerOnReasonStr Description This table contains a mapping of the power on reason numerical values to their string representation. Refer to PIN 13 for product specific values and descriptions. 0  Unknown  1  External  (ST 9100 only)  2  reserved  3  reserved  4  Timer  5  reserved  6  ResetButton  (ST 9100 only)  7  Temperature  (ST 9100 only, battery shutdown)  Syntax  svc.power.PowerOnReasonStr 5.3.4.3 ExtPowerState Description This table contains a mapping of the external power state to their numerical value: Disabled 0 Present 1 Absent 2 Both 3 Syntax svc.power.ExtPowerState 5.3.4.4 ExtPowerStateStr Description This table contains a mapping of the external power state numerical values to their string representation: 0 Disabled 1 Present 2 Absent 3 Both Syntax svc.power.ExtPowerStateStr 5.3.5 Functions 5.3.5.1 powerOff() Description This function powers off the terminal. If the powerOnDelay argument is missing or zero, the terminal is powered off until external power is physically reapplied to turn on the terminal. If the powerOnDelay parameter is nonzero, then power is restored after the specified number of minutes. Power off the terminal for a specified number of minutes. This results in a complete power off of the terminal, including the IsatData Pro modem. After the specified delay in minutes, the terminal powers back on (comes out of reset) and reregisters and restarts the LSF framework. The powerOnReason property indicates a reason of Timer. The minimum valid powerOnDelay is 60 minutes. The maximum allowed value is 525600 minutes. When the terminal is OFF, physical interaction, applying external power , is required to power it back on before the powerOffDelay expires. Syntax powerOff(powerOnDelay) Parameters powerOnDelay Minutes to power the terminal off for. Zero (0) minutes powers off the terminal indefinitely Blocking Yes Returns String Nil if success, or an error message if the command failed 5.3.6 Posted Events 5.3.6.1 External Power Alarm Description This event is posted when the external power status changes and matches the edge detect configuration. Source svc.power (power service table) Event ÒEXT_POWER_ALARMÓ (string) Arguments  table  The alarm message, which is a table containing the following fields: extPowerPresent true if external power input is present reserved - externalVoltage  External power voltage in mV  5.3.7 Firmware Events 5.3.7.1 External Power Description This event is posted when the external power status changes. Source Ò_POWERÓ (string) Event ÒEXTERNALÓ (string) Arguments boolean true if external power is present, false otherwise 5.3.7.2 Shutdown Pending Description This event is posted when the terminal is about to be powered off. Source Ò_POWERÓ (string) Event ÒSHUTDOWN_PENDINGÓ (string) Arguments None 5.4 Message (SIN 18) The message service is responsible for making sure that any incoming messages are routed to the appropriate service, and that outgoing messages are sent over the appropriate transport, and in the appropriate format. The message service keeps all messages that are awaiting transmission in a queue. This queue is limited to a maximum size of 100 pending messages. The service also keeps track of the last five (5) messages that completed (whether by success, failure, timeout or cancellation). There is only one queue shared among all services and all message priorities; however the priority mechanism is used by the transmitting device and not by the terminal. Finally, this queue is only stored in volatile storage. On a terminal reset, or power cycle, all messages that were in the queue are gone; however messages that were already passed to the transmitting terminals may still go out. The send() and sendRaw() functions allow you to queue up to 30 messages per minute in order to protect the Gateway from a high rate of cellular messages. The ip service (SIN 33) exposes a plugin to the message service. This allows the message service to route messages to this transport, based on a user-supplied preference list. The cell transport provides a buffer for from-mobile messages; up to two transmit messages can be in progress at any given time when using JSON, but only one transmit message at a time when using MTBP. It is therefore dependent on the message service's queuing ability to keep track of any further messages to be sent. Synchronized Transmissions It is important to design IsatData Pro applications so that they avoid synchronizing transmissions to or from multiple terminals, as this may result in excessive message segment loss and retransmission due to collisions in the from-mobile traffic channel or excessive queuing delays in the to-mobile traffic channel. For example, terminals should not be configured so that they all transmit at the start of an hour. If the application requires synchronized transmissions please contact Customer Support to discuss a solution. 5.4.1 Multiple Transports (ST 9100) The following set of rules defines how messages are handled: ¥ If only one transport is defined for a message, the only timeout value used is the lifetime of the message. ¥ When a transport is busy, the message service does not move on to the next one. Subsequent attempts are automatically scheduled according to the retryInterval and retryMultiplier properties, until the timeout for that transport elapses, or the message is accepted for transmission. ¥ Upon timeout on the current transport, the message service attempts to cancel the message transmission; this may or may not be possible, and can result in duplicate messages being delivered. ¥ Upon timeout on the current transport, or when it reports a message delivery failure, the message service moves on to the next transport in the list. ¥ After timing out or failing on the last transport in the list, the message service starts over at the beginning of the list, if the retry property, or message option, is set to true; the retryInterval and retryMultiplier properties are used to schedule subsequent attempts. ¥ Messages are given to, and received from, the transport plugins in binary encoded format. It is up to the plugins to convert the message to their required format prior to transmission, and from this format back to binary when receiving messages. 5.4.2 Properties 5.4.3 To-Mobile Messages MIN Name Description 1 getStatus Request the current status for multiple messages. Note that the terminal has a queue depth of 20 for pending messages, and 5 for completed messages. A msgStatus message is generated in response. 2 cancel Cancel a pending message 3, 4 reserved .5 getInstance Retrieves a message instance 6 deleteInstance Removes a message instance 7 getKeys Retrieves a list of keys from a message store 10 setOverrideInstance Reserved 11 setOverrides This message is used to create or modify per-MIN from-mobile message option overrides for one or more MINs for a specific SIN. 12 getOverriddenMins This message is used to request the SINs and MINs of messages with option overrides. The overriddenMins from-mobile message is sent in response. 13 getOverrides This message is used to request the current per-MIN from-mobile message option overrides from-mobile message. 14 deleteOverrides This message is used to delete one or more per-MIN from-mobile message option overrides. 15 deleteAllOverrides This message is used to delete all per-MIN from-mobile message option overrides. 5.4.3.1 getStatus (SIN 18, MIN 1) 5.4.3.2 cancel (SIN 18, MIN 2) 5.4.3.3 getInstance(SIN 18, MIN 5) Name  Type  Optional  Size  Comments  refNo  Unsigned  No  16 bits  Specifies the reference number of a single message that is to be cancelled. This operation removes the message from the terminal's queue. The same is attempted with the modem but may not be possible if the message is already transmitting.  5.4.3.4 deleteInstance (SIN 18, MIN 6) 5.4.3.5 getKeys (SIN 18, MIN 7) 5.4.3.6 setOverrideInstance (SIN 18, MIN 10) This message is reserved. 5.4.3.7 setOverrides (SIN 18, MIN 11) If an option field is present, an override is set (and any existing override is replaced). If an option field is absent, no override is set (and any existing override is removed). Name Type Optional Field Size Comments sin Unsigned No 8 bits The SIN identifying the message option overrides to set overrides Unsigned No 255 bits Lists the message option overrides. min Unsigned No 8 bits Specifies the MIN of the message. log Boolean Yes n/a log override value to use when options.log is not specified for a message with SIN and MIN corresponding to sin and min. If this field and options.log are absent, then svc.message.properties.log is used. send Boolean Yes n/a send override value to use when options.send is not specified for a message with SIN and MIN corresponding to sin and min. If this field and options.send are absent, then svc.message.properties.send is used. Name  Type  Optional  Field Size  Comments  transports override value to use when options.transports is not specified for a message with SIN and MIN corresponding to sin and min.  If this field and options.transports are absent, the message uses the transport(s) and timeout(s) configured in PINs 5-20.  Transport number.  1 Ð SatOnly 2 Ð CellOnly  Specifies the amount of time in minutes, to wait before giving up transmitting on the transport specified by number and moving on to the next one. Not used if only one transport/timeout pair is specified.  Valid range is 1-60.  priority override value from 1 (highest) to 4 to use when options.priority is not specified for a message with SIN and MIN corresponding to sin and min.  If this field and options.priority are absent, then svc.message.properties.priority is used.  lifetime override value (in minutes) to use when options.lifetime is not specified for a message this SIN and MIN corresponding to sin and min.  If this field and options.lifetime are absent, then svc.message.properties.lifetime is used.  persistent override value to use when options.persistent is not specified for a message with SIN and MIN corresponding to sin and min.  If this field and options.persistent are absent, then svc.message.properties.persistent is used.  duplicate override value to use when options.duplicate is not specified for a message with SIN and MIN corresponding to sin and min.  If neither options.duplicate nor a duplicate override value exist, then the default is Allow.  0 Ð Allow 1 Ð Replace 2 Ð Extend 3 Ð ReplaceOldest  dispersion override value (in minutes) to use when options.dispersion is not specified for a message with SIN and MIN corresponding to key.  If this field and options.dispersion are absent, then no dispersion delay is used.  retry  Boolean  Yes  n/a  retry override value to use when options.retry is not specified for a message with SIN and MIN corresponding to key.  If this field and options.retry are absent, then svc.message.properties.retry is used.  Name Type Optional Field Size Comments retryInterval Unsigned Yes 12 bits retryInterval override value (in minutes) to use when options.retryInterval is not specified for a message with SIN and MIN corresponding to key. If this field and options.retryInterval are absent, then no svc.message.properties.retryInterval is used. retryMultiplier Unsigned Yes 3 bits retryMultiplier override value (in minutes) to use when options.retryMultiplier is not specified for a message with SIN and MIN corresponding to key. If this field and options.retryMultiplier are absent, then no svc.message.properties.retryMultiplier is used. 5.4.3.8 getOverriddenMins (SIN 18, MIN 12) 5.4.3.9 getOverrides (SIN 18, MIN 13) 5.4.3.10 deleteOverrides (SIN 18, MIN 14) 5.4.3.11 deleteAllOverrides (SIN 18, MIN 15) 5.4.4 From-Mobile Messages 5.4.4.1 custom (SIN 18, MIN 1) 5.4.4.2 msgStatus (SIN 18, MIN 2) 5.4.4.3 msgInvalid (SIN 18, MIN 3) This message is sent when no definition exists for a received message (only core service), or a message cannot be decoded properly when a definition does exist (all services). It is also sent by default in response to messages received with an invalid SIN; this behavior can be overridden by providing an invalid SIN message handler. 5.4.4.4 msgError (SIN 18, MIN 4) This message is sent by a service when it cannot process a received message, due to lack of resources, being busy, or an invalid combination of field values. 5.4.4.5 instance (SIN 18, MIN 5) 5.4.4.6 deleteResult (SIN 18, MIN 6) 5.4.4.7 keys (SIN 18, MIN 7) 5.4.4.8 overriddenMins (SIN 18, MIN 12) 5.4.4.9 overriddes (SIN 18, MIN 13) Name Type Optional Field Size Comments sin Unsigned No 8 bits Specifies the SIN of the message. Only SINs with message option overrides are included. overrides Unsigned No 255 bits Lists the per MIN overrides. Only MINs with message option overrides are included. min Unsigned No 8 bits Specifies the MIN of the message. log Boolean Yes n/a The log override value (see setOverrides). Only present if this value has been configured. send Boolean Yes n/a The send override value (see setOverrides). Only present if this value has been configured. 5.4.5 Constants 5.4.5.1 MsgDuplicate Description This table maps duplicate message handling actions to their numerical values. It has the following fields: Allow  0  Replace  1  Extend  2  ReplaceOldest  3  Syntax  svc.messageMsgDuplicate 5.4.5.2 MsgDuplicateStr Description This table does the reverse of MsgDuplicate. It maps numerical values back to the string value. It has the following fields:  0 1 2 3  Allow Replace Extend ReplaceOldest  Syntax  svc.message.MsgDuplicateStr 5.4.5.3 MsgStatus Description This table contains a mapping of the message status to their numerical value. Invalid 0 In_progress 1 Cancelled 2 Success 3 Failure 4 Timeout 5 Corrupted 6 Delayed 7 Syntax svc.message.MsgStatus 5.4.5.4 MsgStatusStr Description This table contains a mapping of the message status numerical values to their string representation. 0 Invalid 1 In_progress 2 Cancelled 3 Success 4 Failure 5 Timeout 6 Corrupted 7 Delayed Syntax svc.message.MsgStatusStr 5.4.6 Functions 5.4.6.1 allInstances() Description An iterator for all message instances in a store. Syntax svc.message.alltInstances(sin, min) Parameters  sin min  The SIN identifying the message instance to retrieve. The MIN identifying the message instance to retrieve.  Blocking No  Returns  function  The iterator  Example  for instance in allInstances(mySIN, myMIN) do process(instance) end 5.4.6.2 deleteInstance() Description Remove a message from the message store. Syntax svc.message.deleteInstance(sin, min, key) Parameters sin The SIN identifying the message instance to remove. min The MIN identifying the message instance to remove. key If present, identifies which instance to remove. If absent, all instances are removed. This is ignored for single-instance messages. Blocking No Returns boolean Indicates success or failure string In the case of failure, a description of the error. 5.4.6.3 getInstance() Description Retrieve a message from the message store. Syntax svc.message.getInstance(sin, min, key) Parameters  sin min key  The SIN identifying the message instance to retrieve. The MIN identifying the message instance to retrieve. If present, identifies which instance to retrieve. For single-instance messages, the key is ignored if present. For multi-instance messages, they key must be present.  Blocking No  Returns  table string  The retrieved message, or nil in case of error. In the case of failure, a description of the error.  5.4.6.4 getOverrides() Description Get the current per-MIN from-mobile message options overrides. Syntax svc.message.getOverrides(mins, sin) Parameters mins Optional single MIN, or table (list) of MINs whose overrides are to be retrieved, overrides are returned for all MINs if nil sin Optional SIN of the target service. If nil the callerÕs SIN is used Blocking No Returns table  A list table containing tables indexed by MIN, each containing the following optional  fields; or nil if no overridden MINs exist for the specified SIN; or nil and an error string  if an error  log  In the case of failure, a description of the error.  send  Boolean to indicate whether to send the message.  transports  An array of (transport number, transport timeout) pairs.  priority  The message priority (1-4).  lifetime  The lifetime of the message in minutes (1-2103840).  duplicate  Action to take if another message with the same MIN is already queued: can be one of  Allow, Replace or Extend (see svc.message.MsgDuplicate). The default is Allow.  persistent  Boolean to indicate if the message is persistent.  dispersion  The maximum amount of time (in minutes) to delay the message. The mobile ID is used  to calculate the actual delay.  retry  Boolean to indicate whether to retry the message.  retryInterval  The base interval (in seconds) between retry attempts.  retryMultiplier  The multiplier to use on the retryInterval for every attempt after the first lifetime.  5.4.6.5 getKeys()  Description  Retrieve a list of all keys that are currently present in the message store. Syntax svc.message.getKeys(sin, min) Parameters sin The SIN identifying the message store. min The MIN identifying the message store. Blocking No Returns table A list of all keys; empty if there are no instances, if the SIN and/or MIN are invalid or the message is a single-instance one. 5.4.6.6 invalidSinHandler() Description Install a handler to process incoming messages with an invalid SIN. If no function is provided, use the default handler, which sends an msgInvalid message. Syntax svc.message.invalidSinHandler(func) Parameters  func  The function that is being installed to process messages with an invalid SIN. The function is given a string (byte array) representing the message as its sole argument  Blocking No  Returns None  5.4.6.7 register() Description Registers a service for receiving and sending messages. Syntax svc.message.register(sin) Parameters sin The Service Identification Number (SIN) of the service being registered Blocking No Returns handle A handle to used to access message service functionality, or nil if the particular SIN value has already been registered 5.4.6.8 setInstance() Description Add a message to the message store. The message is assumed to be a to-mobile message Syntax svc.message.setInstance(msg) Parameters msg The message to add. It must be a table with the following fields: sin The SIN of the message min The MIN of the message fields A table containing the message fields, in the form Ò<field name> = <value>Ó.  Blocking No  Returns  string  In the case of failure, a description of the error.  5.4.7 Message Handle Methods The register() function returns a handle that defines the following functions: 5.4.7.1 cancel() Description Cancels transmission of a queued message. If message transmission has begun on the satellite modem, the message may still be delivered. Syntax <handle>:cancel(id) Parameters id The messageÕs reference number, which was returned by a previous call to send() or sendRaw() Blocking No Returns string An error message in the case of a failure, or nil if successful 5.4.7.2 getList() Description Retrieves a list of the serviceÕs specified messages currently in the queue. Syntax <handle>:getList(min) Parameters min Optional MIN to look for; if not specified, retrieves all of the service's messages Blocking No Returns table An array of tables, each containing the following fields; the table can be empty if there are no messages, or nil if the handle is invalid: id The identification number of the message min The MIN of the current message time A timestamp from when the message was queued transport The transport the message is currently transmitting on, or 0 if in a retry delay attempt The number of the current attempt scheduled A timestamp for when the message is scheduled to start transmitting. This is the same as the time field if the message was not flagged for dispersion. 5.4.7.3 msgError() Description Send out an error response for a received message. Syntax <handle>:msgError(min, desc) Parameters min The MIN of the message that caused the error desc A string describing the error Blocking No Returns number A reference number for the queued error message, or 0 if there was a problem string An error message if there is a problem queuing the error message, or nil 5.4.7.4 reply() Description Queue a formatted message to be sent over-the-air and/or logged in response to a request. This function allows you to queue up to 30 messages per minute. The options parameter allows you to override the default parameters for the message as defined by the service properties. The num parameter specifies the transport on which the original request was received; it is only used if the replyOnSameTransport (PIN 25) property is set to true and the options table does not contain a list of specific transports to use. Syntax <handle>:reply(min, num, fields, options) Parameters min num fields options Blocking No Returns number string Default Options priority send log retry lifetime transports retryInterval retryMultiplier duplicate persistent dispersion The MIN of the message to send The transport number the request was received on A table containing the message fields and their values A table that may contain any of the following options: priority The message priority (1-4) send Boolean to indicate whether to send the message log Boolean to indicate whether to log the message retry Boolean to indicate whether to retry the message lifetime The lifetime value (1-2103840) transports An array of (transport number, transport timeout) pairs that override the property values, also overrides the num parameter retryInterval The base interval (in seconds) between retry attempts retryMultiplier The multiplier to use on the retryInterval for every attempt after the first duplicate Action to take if another message with the same MIN is already queued. Can be one of Allow, Replace or Extend. The default is Allow. persistent Boolean to indicate whether to save the message in flash dispersion The maximum amount of time (in minutes) to delay the message. The mobile ID is used to calculate the actual delay; this is useful when a number of terminals send messages at a fixed time to ensure they do not all transmit at exactly the same time. A reference number for the queued message, or 0 if there was a problem An error message if there is a problem queuing the message, or nil priority property (PIN 1) true log property (PIN 4) retry property (PIN 2) lifetime property (PIN 3) num parameter if the replyOnSameTransport property is true; transport and timeout service properties otherwise retryInteval property (PIN 22) retryMultiplier property (PIN 23) Allow false 0 (no delay) 5.4.7.5 send() Description Queue a formatted message to be sent over-the-air and/or logged. This function allows you to queue up to 30 messages per minute. You can override the default parameters for the message as defined by the service properties. Note: It is important to design IsatData Pro applications so that they avoid synchronizing transmissions to or from multiple terminals, as this may result in excessive message segment loss and retransmission due to collisions in the from-mobile traffic channel or excessive queuing delays in the to-mobile traffic channel. For example, terminals should not be configured so that they all transmit at the start of an hour. If the application requires synchronized transmissions, use the dispersion option judiciously. Syntax <handle>:send(min, fields, options) Parameters  min fields options  The MIN of the message to send A table containing the message fields and their values A table that may contain any of the following options: priority The message priority (1-4) send Boolean to indicate whether to send the message log Boolean to indicate whether to log the message retry Boolean to indicate whether to retry the message lifetime The lifetime value (1-2103840) transports An array of (transport number, transport timeout) pairs that override the property values  retryInterval retryMultiplier duplicate persistent dispersion  The base interval (in seconds) between retry attempts The multiplier to use on the retryInterval for every attempt after the first lifetime Action to take if another message with the same MIN is already queued. Can be one of Allow, Replace or Extend. The default is Allow. Boolean to indicate whether to save the message in flash The maximum amount of time (in minutes) to delay the message. The mobile ID is used to calculate the actual delay; this is useful when a number of terminals send messages at a fixed time to ensure they do not all transmit at exactly the same time.  Blocking  No  Returns  number string  A reference number for the queued message, or 0 if there was a problem An error message if there is a problem queuing the message, or nil  Default Options  priority  priority property (PIN 1)  send  true  log  log property (PIN 4)  retry  retry property (PIN 2)  lifetime  lifetime property (PIN 3)  transports  transport and timeout service properties  retryInterval  retryInteval property (PIN 22)  retryMultiplier  retryMultiplier property (PIN 23)  duplicate  Allow  persistent  false  dispersion  0 (no delay)  Example  Attempts to send a message with MIN 1 over cellular (satellite-cellular terminals) first, with a timeout of 2 minutes, then over satellite, with a timeout of 10 minutes. msgHdl:send(1, myFields, {transports={{2, 2}, {1, 10}}}) 5.4.7.6 sendRaw() Description Queue a raw (binary) message to be sent over-the-air and/or logged. This function allows you to queue up to 30 messages per minute. The specified MIN must not be defined. This option allows you to override the default parameters for the message as defined by the service properties. Note: Raw messages are supported only over satellite; they are not supported over MTWS. To send binary data, use send() rather than sendRaw() and define a message that contains a single field of type data. The binary data is received as a base64 encoded string over satellite and cellular. Syntax <handle>:sendRaw(min, data, options) Parameters min The MIN of the raw message to send data The message payload as a string options A table that may contain any of the following options: priority The message priority (1-4) send Boolean to indicate whether to send the message log Boolean to indicate whether to log the message retry Boolean to indicate whether to retry the message lifetime The lifetime value (1-2103840) Blocking No Returns number string Default Options priority send log retry lifetime transports retryInterval retryMultiplier duplicate persistent dispersion transports An array of (transport number, transport timeout) pairs that override the property values retryInterval The base interval (in seconds) between retry attempts retryMultiplier The multiplier to use on the retryInterval for every attempt after the first lifetime duplicate Action to take if another message with the same MIN is already queued. Can be one of Allow, Replace or Extend. The default is Allow. persistent Boolean to indicate whether to save the message in flash dispersion The maximum amount of time (in minutes) to delay the message. The mobile ID is used to calculate the actual delay; this is useful when a number of terminals send messages at a fixed time to ensure they do not all transmit at exactly the same time. A reference number for the queued message, or 0 if there was a problem An error message if there is a problem queuing the message, or nil priority property (PIN 1) true log property (PIN 4) retry property (PIN 2) lifetime property (PIN 3) transport and timeout service properties retryInteval property (PIN 22) retryMultiplier property (PIN 23) Allow false 0 (no delay) 5.4.8 Posted Events 5.4.8.1 All Overrides Deleted Description This event is sent when all the per-MIN from-mobile message option overrides are deleted. Source svc.message Event ÒALL_OVERRIDES_DELETEDÓ (string) Arguments None 5.4.8.2 Instance Added Description This event is sent whenever a message instance has been added to the message store Source The handle that was returned by the call to register() Event ÒINSTANCE_ADDEDÓ (string) Arguments  table  A table containing the following fields:  min  The MIN identifying the message store  key  A key identifying the specific message instance (nil for a single-instance message)  5.4.8.3 Instance Cleared Description This event is sent whenever a message store is cleared. Source The handle that was returned by the call to register() Event ÒINSTANCE_CLEAREDÓ (string) Arguments table A table containing the following fields: min The MIN identifying the message store 5.4.8.4 Instance Deleted Description This event is sent whenever a message instance has been deleted from the message store. Source The handle that was returned by the call to register() Event ÒINSTANCE_DELETEDÓ (string) Arguments  table  A table containing the following fields:  min  The MIN identifying the message store  key  A key identifying the specific message instance (nil for a single-instance message)  5.4.8.5 Message Status Description This event is sent whenever a message changes state, whether is succeeds or fails. Source The handle that was returned by the call to register() Event ÒTX_STATUSÓ (string) Arguments table A table containing the following fields: id The message's reference number status The completion status, which is one of: svc.message.MsgStatus.Cancelled (2) svc.message.MsgStatus.Success (3) svc.message.MsgStatus.Failure (4) svc.message.MsgStatus.Timeout (5) svc.message.MsgStatus.Corrupted (6) transport The transport the message was delivered on, or was last attempted on in the case of a failure msg A copy of the original message, in encoded format. If a Lua version of the message is required, the application can call svcmgr.decodeMsg(). 5.4.8.6 Message Service Ready Description Alerts interested parties that the message service is ready to receive messages. Source Event send by the message service Event ÒMSG_SVC_READYÓ (string) Arguments None 5.4.8.7 New Decoded Message Description This event is posted when a new decoded to-mobile message is available. Source The handle that was returned by the call to register() Event ÒRX_DECODEDÓ (string) Arguments  table  A table contmin transport fields  aining the following fields: Integer MIN of the message Transport the message was received on A table of the message fields and their values  5.4.8.8 New Raw Message Description This event is posted when a new raw to-mobile message is available. The event is sent when a message comes in for a user service and a MIN that is not defined. Source Handle that was returned by the call to register() Event ÒRX_RAWÓ (string) Arguments table The raw message, which is a table containing the following fields: min Integer MIN of the message transport Transport the message was received on payload The message payload, as a string (byte array) 5.4.8.9 Overrides Changed Description This event is sent when the per-MIN from-mobile message option overrides for one or more from-mobile messages are added or modified. Source svc.message Event ÒOVERRIDES_CHANGEDÓ (string) Arguments sin The SIN. minList An array list of MINs, whose overrides have been added and/or modified for the SIN. 5.4.8.10 Overrides Deleted Description This event is sent when the per-MIN from-mobile message option overrides for one or more from-mobile messages are deleted. Source svc.message Event ÒOVERRIDES_DELETEDÓ (string) Arguments sin The SIN. minList An array list of MINs, whose overrides have been deleted for the SIN. 5.4.8.11 Queue Blockage Description This event is posted when a message remains unsent in the queue for too long, or when a previous blockage condition clears (for example, a message is finally successfully transmitted). Source svc.message (message service table) Event ÒQUEUE_BLOCKAGEÓ (string) Arguments table A table containing the following fields: blocked A Boolean indicating whether blockage was detected (true) or cleared (false) lsfUptime The LSF uptime at event generation time The time (in seconds since the epoch) at event generation, or 0 if not available 5.5 Report (SIN 19) The report service sends out report messages, consisting of properties from various services, either on-demand, or following preconfigured schedules. 5.5.1 Properties The SIN and MIN properties for each of the four reports must specify a valid return message format, which must contain only PROPERTY fields. If these conditions are not met, the reports are not generated properly. For example, setting report1SIN to 19 and report1MIN to 1 selects simpleReport as the message format; because it contains only PROPERTY fields, the report is generated properly. However, setting report1SIN to 19 and report1MIN to 6 can cause errors, because there is no return MIN 6 for the report service. And setting report1SIN to 18 and report1MIN to 2 selects msgStatus as the message format; because that message contains fields that are not of type PROPERTY, the report fails. Description Type Storage Default Value Class 29 logRequests Controls whether reports that are manually requested Boolean Config false should be logged. 40 maxAge1 The maximum age value (in seconds) to use if a GPS Config 0 fix request is required to send report 1. Setting this to 0 automatically uses half the interval value. Any value greater than 600 is automatically replaced with 600, as that is the largest maximum age value the modem supports. 41 timeout1 The timeout value (in seconds) to use if a GPS fix Config 180 request is required to send report 1. If this value is greater than the interval, then the interval is used instead. 42 maxAge2 The maximum age value (in seconds) to use if a GPS Config 0 fix request is required to send report 2. Setting this to 0 automatically uses half the interval value. Any value greater than 600 is automatically replaced with 600, as that is the largest maximum age value the modem supports. 43 timeout2 The timeout value (in seconds) to use if a GPS fix Config 180 request is required to send report 2. If this value is greater than the interval, then the interval is used instead. 44 maxAge3 The maximum age value (in seconds) to use if a GPS Config 0 fix request is required to send report 3. Setting this to 0 automatically uses half the interval value. Any value greater than 600 is automatically replaced with 600, as that is the largest maximum age value the modem supports. 45 timeout3 The timeout value (in seconds) to use if a GPS fix Config 180 request is required to send report 3. If this value is greater than the interval, then the interval is used instead. 46 maxAge4 The maximum age value (in seconds) to use if a GPS Config 0 fix request is required to send report 4. Setting this to 0 automatically uses half the interval value. Any value greater than 600 is automatically replaced with 600, as that is the largest maximum age value the modem supports. 47 timeout4 The timeout value (in seconds) to use if a GPS fix Config 180 request is required to send report 4. If this value is greater than the interval, then the interval is used instead. Unsigned Minimum Ð 1 Maximum Ð 180 5.5.2 To-Mobile Messages 5.5.2.1 generateReport (SIN 19, MIN 1) Name  Type   Comments  reportSIN    The SIN of the report to send (16-255)  reportMIN    The MIN of the report to send (1-255)  reserved    - priority  An optional priority for the message. If not specified, uses the priority property of  the message service.  retry  An optional retry flag for the message. If not specified, uses the retry property of  the message service.  lifetime  An optional lifetime for the message. If not specified, uses the lifetime property  of the message service.  send    An optional send flag for the message. If not specified, the default value is true.  log  An optional log flag for the message. If not specified, uses the log property of the  message service.  maxAge  The maximum age value (in seconds) to use if a GPS fix request is required to  send the report. If omitted, or set to 0, 60 seconds is used. Any value greater than  600 is automatically replaced with 600, as that is the largest maximum age value  the modem supports.  timeout  Unsigned  Yes  8 bits  The timeout value (in seconds) to use if a GPS fix request is required to send the  report. If omitted, or set to 0, 180 seconds is used.  5.5.3 From-Mobile Messages The service predefines four reports. Additional custom report formats can be defined. 5.5.3.1 simpleReport (SIN 19, MIN 1) 5.5.3.2 fullReport (SIN 19, MIN 2) 5.5.3.3 eioReport (SIN 19, MIN 3) 5.5.3.4 noEIO (SIN 19, MIN 4) Name Type Optional Size SIN PIN fixValid 2 (fixValid) fixType 3 (fixType) latitude 6 (latitude_mm) longitude 7 (longitude_mm) speed 9 (speed) heading 10 (heading) altitude 8 (altitude) fixTime 11 (fixTime) DTEConnect Property No n/a 22 (serial) 7 (rs232mainDTEIsConnected) 5.5.4 Functions 5.5.4.1 sendReport() Description Send a report immediately. This operation does not affect the schedule for any of the periodic reports. Syntax svc.report.sendReport(sin, min, opt, maxAge, timeout, wait) Parameters  sin  The SIN of the report to send  min  The MIN of the report to send  opt  The options for sending the message (see the send() message handle method)  maxAge  The maximum age for the fix request, if the message contains data from the position service  (default: 60)  timeout  The timeout for the fix request, if the message contains data from the position service (default:  180)  wait  Whether to wait for the message to be queued (default: false)  Blocking  Yes, if wait is set to true Returns string An error message if a failure occurs, or nil otherwise. NOTE: If wait is false, the return value does not reflect any queuing errors, for example, queue full. 5.5.5 Posted Events This service does not currently generate any events. 5.6 Position (SIN 20) The position service is responsible for providing position information. It includes position-based accelerometer capabilities. 5.6.1 Properties Description Type Storage Default Class Value 13 GPS 14 GPS 15 0 16 Unknown 17 jammingFlag GPS jamming detection flag. Available on Boolean Volatile false modem hardware number 4 or higher. This is reported only for control word. Description Type Storage Default Class Value 30 false 31 false 32 0 33 0 35 300 36 1 37 Config -1 39 Config 400 40 accHarshBrakeMinTime Minimum duration in seconds that Config 1 accHarshBrakeThreshold must be reached before generating a HARSH_BRAKE_START event. Description 41 accHarshBrakeMaxTime 43 44 accHarshCornerMinTime 45 47 accAccidentThreshold 48 accAccidentMinTime Type Storage Default Class Value Signed -1 Min. Ð -1 Max. Ð 30 Unsigned Config 450 Min. Ð 0 Max. Ð 16000 Config 3 Signed -1 Min. Ð -1 Max. Ð 30 Unsigned Config 5000 Min. Ð 0 Max. Ð 16000 Config 0Description Type Storage Default Class Value 49 0 51 true 52 false 53 true 54 accStopLog Whether or not accelStop messages are Boolean Config false enabled. 5.6.2 To-Mobile Messages 5.6.2.1 getPosition (SIN 20, MIN 1) Name Type Optional Size Comments fixType The desired fix type timeout The timeout value. This is the maximum amount of time, in seconds, to wait for a fix before giving up and returning the previous position data. Valid range is from 1-180; values outside the range are replaced with the appropriate value (1 or 180). age Unsigned Yes 16 bits The maximum age of the fix, in seconds, that is acceptable. If the current position data is older than this, a new fix is requested. Any value greater than 600 is automatically replaced with 600, as that is the largest maximum age value the modem supports. 5.6.2.2 getLastPos (SIN 20, MIN 2) This message does not contain any fields. 5.6.2.3 getSources (SIN 20, MIN 3) This message does not contain any fields. 5.6.3 From-Mobile Messages 5.6.3.1 position (SIN 20, MIN 1) This message reports position information. If the fixValid field is set to false, it means that the fix request failed, and the rest of the data represents the previous position information. In the case where no position information is available at all, all fields are set as follows: fixType  2D  latitude  5400000  longitude  10800000  altitude  200000  speed  10000  heading  3599  timestamp  0  Name Type Optional Size Comments fixValid Boolean No 1 bit Whether the fix data is valid. If true, the fix position data is current; otherwise the data is from a previous fix. fixType Enum No 1 bit The fix type 0 Ð 2D 1 Ð 3D latitude Signed No 24 bits The latitude in milliminutes longitude Signed No 25 bits The longitude in milliminutes altitude Signed No 18 bits The altitude in tenths of meters speed Unsigned No 16 bits The speed in tenths of knots heading Unsigned No 14 bits The heading in tenths of degrees timestamp Signed No 32 bits The time the last position was obtained, expressed as the number of seconds since the epoch 5.6.3.2 sources (SIN 20, MIN 2) Name  Type  Optional  Size  Comments  mask  Unsigned  No  8 bits  A bitmap of supported sources. Bit 0 Ð IDPmodem Bit 1 Ð OnBoardGNSS Bit 2 Ð CellLocate All other bits are reserved.  5.6.3.3 accelStart (SIN 20, MIN 3) This message reports the start of acceleration as determined using position fixes, and in accordance with PINs 30-52. Acceleration is considered to have started when any of the (non-zero) harsh acceleration, harsh braking, harsh cornering, or accident thresholds have been reached. Name  Type  Optional  Size  Comments  accelDetected  Indicates if harsh acceleration was detected  brakeDetected  Indicates if harsh braking was detected  cornerDetected  Indicates if harsh cornering was detected  Indicates if an accident related acceleration was  detected  accForward  Forward direction acceleration in milli-g. Corresponds to  harsh acceleration or harsh braking.  accLateral  Lateral acceleration in milli-g. Corresponds to harsh  cornering.  speed  The speed in km/h  latitude  The latitude in milliminutes  longitude  The longitude in milliminutes  heading  The heading in degrees  timestamp  Signed  No  32 bits  The timestamp of the oldest position fix of the pair of  position fixes that first resulted in the presence of an  acceleration condition, expressed as the number of  seconds since the epoch  5.6.3.4 accelStop (SIN 20, MIN 4) This message reports the stop of acceleration as determined using position fixes, and in accordance with PINs 30-49 and 53-54. Acceleration is considered to have stopped when all of the (non-zero) harsh acceleration, harsh braking, harsh cornering, or accident thresholds are no longer reached. The detected and min./max. fields indicate values that have occurred between (and including) accelStart and accelStop. 5.6.4 Constants The position service defines the following constants. 5.6.4.1 FixTypes Description This table contains a mapping of the GPS fix types to their numerical value: 2D  0  3D  1  Syntax  svc.position. FixTypes 5.6.4.2 FixTypeStr Description This table contains a mapping of the GPS fix type numerical values to their string representation: 0  2D  1  3D  Syntax  svc.position. FixTypeStr 5.6.4.3 GpsSource Description This table contains a mapping of the GPS sources to their numerical value: IDPModem 0 OnBoardGNSS 1 CellLocate 2 None 3 Syntax svc.position. GpsSource 5.6.4.4 GpsSourceStr Description This table contains a mapping of the GPS source numerical values to their string representation: 0 IDPModem 1 OnBoardGNSS 2 CellLocate 3 None Syntax svc.position. GpsSourceStr 5.6.4.5 HarshDrvStopReason Description This table contains a mapping of the harsh driving (acceleration, braking, cornering) stop reasons to their numerical values: BelowThreshold MaxTimeReached NoValidFix  0 1 2  Syntax  svc.positon. HarshDrvStopReason 5.6.4.6 HarshDrvStopReasonStr Description This table contains a mapping of the harsh driving stop reason numerical values to their string representation: 0 BelowThreshold 1 MaxTimeReached 2 NoValidFix Syntax svc.positon. HarshDrvStopReasonStr 5.6.5 Functions 5.6.5.1 requestFix() Description Request a fix, and optionally to provide a callback function that is called when the fix is ready. Syntax svc. position . requestFix(fixType, maxAge, timeout, func, É) Parameters fixType Indicates the desired fix type (2D or 3D). maxAge Indicates how old of a fix the caller is willing to accept, in seconds. The minimum value is 1 and any value greater than 600 is automatically replaced with 600, as that is the largest maximum age value the modem supports. timeout Indicates how long the caller is willing to wait, in seconds. Valid range is from 1-180, values outside the range are replaced with the appropriate value (1 or 180) func An optional callback function, which is called with a table containing all volatile properties (PINs 2-13, 16-18, 21) and any optional user data provided in the requestFix() call; this function must not block. If the fixValid field is false, it means that the request timed out. This parameter is called only once. If multiple fixes are required, requestFix must be called multiple times. É Optional user data; this data is passed as-is to the call to func, after the fix properties table. Blocking Yes Returns boolean A flag to indicate whether all parameters were valid 5.6.6 Posted Events 5.6.6.1 Accident Start Description This event is posted when an accident related acceleration is determined using position fixes, and in accordance with PINs 30 and 47-49. Source svc. position (position service table) Event ÒACCIDENT_STARTÓ (string) Arguments  table  A table containing the following fields:  integer  accForward, signed forward direction acceleration/deceleration in milli-g  integer  accLateral, signed lateral acceleration/deceleration in milli-g  integer  latitude, latitude in milliminutes  integer  longitude, longitude in milliminutes  integer  metricSpeed, speed in tenths of km/h  integer  heading, heading in tenths of degrees  integer  timestamp, timestamp of the oldest of the pair of position fixes used to calculate the  accelerations/decelerations, expressed as the number of seconds since the epoch  5.6.6.2 Accident Stop Description This event is posted when an accident related acceleration is no longer determined using position fixes, and in accordance with PINs 30 and 47-49. Source svc. position (position service table) Event ÒACCIDENT_STOPÓ (string) Arguments table A table containing the following fields: integer accForward, signed forward direction acceleration in milli-g integer accLateral, signed lateral acceleration/deceleration in milli-g integer latitude, latitude in milliminutes integer longitude, longitude in milliminutes integer metricSpeed, speed in tenths of km/h integer heading, heading in tenths of degrees integer timestamp, timestamp of the newest of the pair of position fixes used to calculate the accelerations/decelerations (when stopReason ~= NoValidFix) or timestamp of the last valid GNSS fix obtained (when stopReason == NoValidFix), expressed as the number of seconds since the epoch integer stopReason, the reason for the stop event, one of: svc.position.HarshStopReason.BelowThreshold (0) svc.position.HarshStopReason.MaxTimeReached (1) svc.position.HarshStopReason.NoValidFix (2) table A table of minimum or maximum acceleration information containing the following fields: integer accForward, forward acceleration/deceleration in milli-g (minimum or maximum acceleration when magnitude exceeds magnitude of accLateral, or forward acceleration at time of accLateral otherwise) integer accLateral, signed lateral acceleration/deceleration in milli-g (minimum or maximum acceleration when magnitude exceeds magnitude of accForward, or lateral acceleration at time of accForward otherwise) integer latitude, latitude of minimum or maximum acceleration occurrence in milliminutes integer longitude, longitude of minimum or maximum acceleration occurrence in milliminutes integer metricSpeed, speed at time of minimum or maximum acceleration occurrence in tenths of km/h integer heading, heading at time of minimum or maximum acceleration occurrence in tenths of degrees integer timestamp, timestamp of the newest of the pair of position fixes at time of minimum or maximum acceleration occurrence, expressed as the number of seconds since the epoch 5.6.6.3 Antenna Cut Description This event is posted when the antenna cut status changes on satellite-cellular terminals. This event is identical to the event generated by the idp service. Both services generate events for terminals with satellite service, but only the position service generates an event for cellular-only terminals. Source svc. position (position service table) Event ÒANTENNA_CUTÓ (string) Arguments boolean Indicates whether an antenna cut is currently detected or not 5.6.6.4 GPS Jamming Description This event is posted when the GPS jamming status changes. This event is identical to the event generated by the idp service. Both services generate events for terminals with satellite service, but only the position service generates an event for cellular-only terminals. Source svc. position (position service table) Event ÒJAMMING_UPDATEÓ (string) Arguments table An array with the following values number The jamming status: 0 Ð Unknown 1 Ð OK (no significant jamming) 2 Ð Warning (interference visible, but fix OK) 3 Ð Critical (interference visible and no fix) boolean Indicates whether jamming is detected or not number The raw jamming indicator value for the hardware 5.6.6.5 Harsh Acceleration Start Description This event is posted when harsh acceleration is determined using position fixes, and in accordance with PINs 30 and 35-37. Source svc. position (position service table) Event ÒHARSH_ACCEL_STARTÓ (string) Arguments table A table containing the following fields: integer accForward, signed forward direction acceleration in milli-g integer accLateral, signed lateral acceleration/deceleration in milli-g integer  latitude, latitude in milliminutes  integer  longitude, longitude in milliminutes  integer  metricSpeed, speed in tenths of km/h  integer  heading, heading in tenths of degrees  integer  timestamp, timestamp of the oldest of the pair of position fixes used to calculate the  accelerations/decelerations, expressed as the number of seconds since the epoch  5.6.6.6 Harsh Acceleration Stop Description This event is posted when harsh acceleration is no longer determined using position fixes, and in accordance with PINs 30 and 35-37. Source svc. position (position service table) Event ÒHARSH_ACCEL_STOPÓ (string) Arguments table A table of harsh acceleration stop information containing the following fields: integer accForward, signed forward direction acceleration in milli-g integer accLateral, signed lateral acceleration/deceleration in milli-g integer latitude, latitude in milliminutes integer longitude, longitude in milliminutes integer metricSpeed, speed in tenths of km/h integer heading, heading in tenths of degrees integer timestamp, fix time of the newest of the pair of position fixes used to calculate the acceleration/deceleration (when stopReason ~= NoValidFix) or timestamp of the last valid GNSS fix obtained (when stopReason == NoValidFix), expressed as the number of seconds since the epoch integer stopReason, the reason for the stop event, one of: svc.position.HarshStopReason.BelowThreshold (0) svc.position.HarshStopReason.MaxTimeReached (1) svc.position.HarshStopReason.NoValidFix (2) table A table of maximum forward acceleration information containing the following fields: integer accForward, signed maximum forward direction acceleration in milli-g integer accLateral, signed lateral acceleration at the time of maximum forward acceleration in milli.g integer latitude, latitude of maximum forward acceleration in milliminutes integer longitude, longitude of maximum forward acceleration in milliminutes integer metricSpeed, speed at time of maximum forward acceleration in tenths of km/h integer heading, heading at time of maximum forward acceleration in tenths of degrees integer timestamp, timestamp of the newest of the pair of position fixes at time of maximum forward acceleration, expressed as the number of seconds since the epoch 5.6.6.7 Harsh Braking Start Description This event is posted when harsh braking is determined using position fixes, and in accordance with PINs 30 and 39-41. Source svc. position (position service table) Event ÒHARSH_BRAKE_STARTÓ (string) Arguments table A table containing harsh braking stop with the following fields: integer accForward, signed forward direction acceleration in milli-g integer accLateral, signed lateral acceleration in milli-g integer latitude, latitude in milliminutes integer longitude, longitude in milliminutes integer metricSpeed, speed in tenths of km/h integer heading, heading in tenths of degrees integer timestamp, timestamp of the oldest of the pair of position fixes used to calculate the accelerations/decelerations, expressed as the number of seconds since the epoch 5.6.6.8 Harsh Braking Stop Description This event is posted when harsh braking is no longer determined using position fixes, and in accordance with PINs 30 and 39-41. Source svc. position (position service table) Event ÒHARSH_BRAKE_STOPÓ (string) Arguments table A table containing the following fields: integer accForward, signed forward direction acceleration/deceleration in milli-g integer accLateral, signed lateral acceleration/deceleration in milli-g integer latitude, latitude in milliminutes integer longitude, longitude in milliminutes integer metricSpeed, speed in tenths of km/h integer heading, heading in tenths of degrees integer timestamp, timestamp of the newest of the pair of position fixes used to calculate the accelerations/decelerations (when stopReason ~= NoValidFix) or timestamp of the last valid GNSS fix obtained (when stopReason == NoValidFix), expressed as the number of seconds since the epoch integer stopReason, the reason for the stop event, one of: svc.position.HarshStopReason.BelowThreshold (0) svc.position.HarshStopReason.MaxTimeReached (1) svc.position.HarshStopReason.NoValidFix (2) table A table of minimum forward acceleration information containing the following fields: integer accForward, signed minimum forward direction acceleration in milli-g integer accLateral, signed lateral acceleration at the time of minimum forward acceleration in milli-g integer latitude, latitude of minimum forward acceleration in milliminutes integer longitude, longitude of minimum forward acceleration in milliminutes integer metricSpeed, speed at time of minimum forward acceleration in tenths of km/h integer heading, heading at time of minimum forward acceleration in tenths of degrees integer timestamp, timestamp of the newest of the pair of position fixes at time of minimum forward acceleration, expressed as the number of seconds since the epoch 5.6.6.9 Harsh Cornering Start Description This event is posted when harsh cornering is determined using position fixes, and in accordance with PINs 30 and 43-45. Source svc. position (position service table) Event ÒHARSH_CORNER_STARTÓ (string) Arguments table A table containing the following fields: integer accForward, signed forward direction acceleration/deceleration in milli-g integer accLateral, signed lateral acceleration/deceleration in milli-g integer latitude, latitude in milliminutes integer longitude, longitude in milliminutes integer metricSpeed, speed in tenths of km/h integer heading, heading in tenths of degrees integer timestamp, timestamp of the oldest of the pair of position fixes used to calculate the accelerations/decelerations, expressed as the number of seconds since the epoch 5.6.6.10 Harsh Cornering Stop Description This event is posted when an accident related acceleration is no longer determined using position fixes, and in accordance with PINs 30 and 47-49. Source svc. position (position service table) Event ÒHARSH_CORNER_STOPÓ (string) Arguments table A table containing the following fields: integer accForward, signed forward direction acceleration/deceleration in milli-g integer accLateral, signed lateral acceleration/deceleration in milli-g integer latitude, latitude in milliminutes integer longitude, longitude in milliminutes integer metricSpeed, speed in tenths of km/h integer heading, heading in tenths of degrees integer timestamp, timestamp of the newest of the pair of position fixes used to calculate the accelerations/decelerations (when stopReason ~= NoValidFix) or timestamp of the last valid GNSS fix obtained (when stopReason == NoValidFix), expressed as the number of seconds since the epoch integer stopReason, the reason for the stop event, one of: svc.position.HarshStopReason.BelowThreshold (0) svc.position.HarshStopReason.MaxTimeReached (1) svc.position.HarshStopReason.NoValidFix (2) table A table of minimum or maximum lateral acceleration information containing the following fields: integer accForward, signed forward acceleration at time of minimum or maximum lateral acceleration in milli-g integer accLateral, signed minimum or maximum lateral acceleration (the minimum negative or maximum positive value Ð the one with the largest magnitude) in milli-g integer latitude, latitude of minimum or maximum lateral acceleration occurrence in milliminutes integer longitude, longitude of minimum or maximum lateral acceleration occurrence in milliminutes integer metricSpeed, speed at time of minimum or maximum lateral acceleration occurrence in tenths of km/h integer heading, heading at time of minimum or maximum lateral acceleration occurrence in tenths of degrees integer timestamp, timestamp of the newest of the pair of position fixes at time of minimum or maximum lateral acceleration occurrence, expressed as the number of seconds since the epoch 5.6.6.11 Position Data Updated Description This event is posted whenever a new GNSS fix is obtained following a call to the requestFix() function. It allows all other services to take advantage of a service's request. Source svc. position (position service table) Event ÒPOS_UPDATEDÓ (string) Arguments table A table containing all volatile properties 5.7 Geofence (SIN 21) The geofence service has provisions for up to 128 boundaries (fences), each of which can be a circle, a polygon, or a rectangle. At any given point in time, the geofence service makes available whether the current terminal position is inside or outside of each individual boundary. Note that the calculations involved in trying to determine whether a position is within a fence are quite complex. Therefore, the higher the number of fences defined, the longer the check lasts; the interval property should therefore be set accordingly. Geofence Tags Geofence tags store user metadata for geofences. Four different sets of tags are supported for each fence. A tag index with the range 0...3 is associated with each set of tags, and each tag has a maximum length of 40 bytes. Geofence tags are stored on terminals in an LSF data file (in /data/svc/geofence). When a Geofence Designer package is exported a file named tags-fences.dat containing the geofence names using tagIndex=0 is included in the generated .idppkg file (in addition to fences.dat, which contains the corresponding fence definitions in binary format). Older LSF versions do not support geofence tags, but still function without them. The filename property (with default value of fences.dat) is used to switch between pairs of geofence definition and geofence tags files. For example, when set to fences2.dat the fence definition file to use is fences2.dat, and the fence tags file to use is tags-fences2.dat. When renaming a geofence definition file, you must also rename the geofence tags file accordingly. Geofence tags can be added or modified (as well as requested and reported) via over-the-air messages. Although Geofence Designer initially uses tagIndex=0 for fence names, you can choose to use tagIndex=0 for other information. 5.7.1 Properties PIN Name Description Type Storage Class Default Value 1 enabled Controls whether the geofence Boolean Config false functionality is enabled. 2 interval The time interval, in seconds, between two consecutive geofence checks. The maximum value represents one week. The value is capped at the maximum value supported by the hardware platform. 3 hysteresis The time hysteresis for fence crossings, in seconds. The fence status is rechecked once after this time has elapsed before officially declaring a fence crossing. The time hysteresis applies after any distance hysteresis condition is met. The value is capped at the maximum value supported by the hardware platform. 4 sendAlarm Controls whether alarm messages Boolean Config true should be sent over-the-air. 5 logAlarm Controls whether alarm messages Boolean Config true should be logged. 6 fileName Specifies the name of the fence String Config fences.dat database file to use. 16 entryHysteresis The distance hysteresis for fence entry, in meters. A fence crossing is not declared until the position is this many meters inside the fence. The time hysteresis value is not checked until this condition is met. A value of 0 disables the hysteresis check. This only applies to circle or rectangle fences. 17 exitHysteresis The distance hysteresis for fence exit, in meters. A fence crossing is not declared until the position is this many meters outside the fence. The time hysteresis value is not checked until this condition is met. A value of 0 disables the hysteresis check. This only applies to circle or rectangle fences. Unsigned Min. Ð 0 Max. Ð 604800 Config 60 PIN  Name  Description  Type  Storage Class  Default Value  31  fenceCheckSuccessFixTime The fixTime at the time the last successful fence check was performed on enabled fences, expressed as the number of seconds since the epoch.  Signed Minimum Ð -2147483648 Maximum Ð 2147483647  Volatile  0  5.7.2 To-Mobile Messages Description MINName1 setCircle Configures a new simple (circular) fence. 2 setPolygon Configures a new complex (polygonal) fence. 3 enableFence Updates the enabled property of a fence. 4 updateAlarmCond Updates the alarmCondition property of a fence. 5 getStatus Retrieves the current status of a single fence. A fenceStatus message is generated in response. 6 getAllStatus Retrieves the current status of all fences. An allFencesStatus message is generated in response. 7 setRectangle Configures a new rectangular fence. 8 removeTags Removes any existing tags of the specified fences and tag indices. 9 setTags Configures any subset of tags, for a specific tag index. 10 getTags Retrieves the tags of any subset of fences. A tags message is generated in response. 11 getFenceDef Retrieves the definitions of any subset of fences. A fenceDef message is generated in response. 5.7.2.1 setCircle (SIN 21, MIN 1) This message defines a circle fence in the current fence database file. Name Type Optional Size Comments number Unsigned No 7 bits The fence number to configure enabled Boolean No 1 bit Whether this fence is enabled or not alarmCondition Enum No 2 bits Controls when alarms should be generated 0 Ð None 1 Ð Entry 2 Ð Exit 3 Ð Both centreLatitude Signed No 24 bits The latitude of the center point, in milliminutes centreLongitude Signed No 25 bits The longitude of the center point, in milliminutes radius Unsigned No 20 bits The radius of the fence, in meters 5.7.2.2 setPolygon (SIN 21, MIN 2) This message defines a polygon fence in the current fence database file. 5.7.2.3 enableFence (SIN 21, MIN 3) 5.7.2.4 updateAlarmCond (SIN 21, MIN 4) Field Name Type Optional Size Comments number 7 bits The fence number to update alarmCondition Enum No 2 bits Controls when alarms should be generated 0 Ð None 1 Ð Entry 2 Ð Exit 3 Ð Both 5.7.2.5 getStatus (SIN 21, MIN 5) 5.7.2.6 getAllStatus (SIN 21, MIN 6) This message does not contain any fields. 5.7.2.7 setRectangle (SIN 21, MIN 7) This message defines a rectangle fence in the current fence database file. Name Type Optional Size Comments number The fence number to configure enabled Whether this fence is enabled or not alarmCondition Enum No 2 bits Controls when alarms should be generated 0 Ð None 1 Ð Entry 2 Ð Exit 3 Ð Both 5.7.2.8 removeTags (SIN 21, MIN 8) This message removes any existing geofence tags of the specified fences and tag indices. If the list field is not populated, the tags of all fences are removed. Name Type Optional Size Comments list Array No ²128 elements A list of fence numbers. number Unsigned No 7 bits The fence number. removeTagsIndex0 Boolean No 1 bit False: Keep all existing tagIndex0 tags True: Remove tageIndex0 tags of the specified fences removeTagsIndex1 Boolean No 1 bit False: Keep all existing tagIndex1 tags True: Remove tageIndex1 tags of the specified fences removeTagsIndex2 Boolean No 1 bit False: Keep all existing tagIndex2 tags True: Remove tageIndex2 tags of the specified fences removeTagsIndex3 Boolean No 1 bit False: Keep all existing tagIndex3 tags True: Remove tageIndex3 tags of the specified fences 5.7.2.9 setTags (SIN 21, MIN 9) This message configures any subset of geofence tags. If desired, the removeTags message can be used to remove all existing tags for specified tag indices before setting tags using the setTags message (or multiple setTags messages). It is possible that the size of this message could exceed the maximum to-mobile message size. This can be avoided by using multiple setTags messages. Name Type Optional Size Comments list Array No ²128 elements A list of fence numbers and their tags number Unsigned No 7 bits The fence number. tag0 String Yes ²40 bytes The tagIndex0 string. An empty string deletes the tag. tag1 String Yes ²40 bytes The tagIndex1 string. An empty string deletes the tag. tag2 String Yes ²40 bytes The tagIndex2 string. An empty string deletes the tag. tag3 String Yes ²40 bytes The tagIndex3 string. An empty string deletes the tag. 5.7.2.10 getTags (SIN 21, MIN 10) This message retrieves the tags for any subset of geofences. A tags message is generated in response. If the fenceList field is not populated, the tags are reported for all fences. If the tagList field is not populated, the tags are reported for all tag indices. It is possible that the size of the tags message generated in response could exceed the maximum from-mobile message size (and therefore would not be sent). This can be avoided by using multiple getTags messages, each requesting the tags for a smaller subset of tag indices and/or fences. 5.7.2.11 getFenceDef (SIN 21, MIN 11) This message retrieves the definitions of any subset of fences. A fenceDef message is generated in response. If the list field is not populated, all fence definitions are reported. 5.7.3 From-Mobile Messages 5.7.3.1 alarm (SIN 21, MIN 1) Comments The latitude at the time the crossing was detected (prior to any hysteresis checks), in milliminutes The longitude at the time the crossing was detected (prior to any hysteresis checks), in milliminutes The speed at the time the crossing was detected (prior to any hysteresis checks), in tenths of knots The heading at the time the crossing was detected (prior to any hysteresis checks), in tenths of degrees The fixTime at the time the crossing was detected (prior to any hysteresis checks), in seconds since the epoch 5.7.3.2 fenceStatus (SIN 21, MIN 2) Name Type Optional Size Comments number 7 bits The fence number defined 1 bit Whether this fence is currently configured enabled 1 bit Whether this fence is currently enabled status 2 bits Whether position was inside or outside the fence at the last check time fenceCheckStatus 3 bits The status of the last fence check or time hysteresis check. fenceCheckSuccessFixTime Signed No 32 bits The fixTime at the time the last successful fence check was performed on enabled fences, expressed as the number of seconds since the epoch. 5.7.3.3 allFencesStatus (SIN 21, MIN 3) 5.7.3.4 alarms (SIN 21, MIN 4) Name Type Comments list The array of fence crossing data The fence number to which the alarm applies Whether the alarm is for a fence entry or exit The latitude at the time the crossing was detected (prior to any hysteresis checks), in milliminutes longitude Signed No 25 bits The longitude at the time the crossing was detected (prior to any hysteresis checks), in milliminutes 5.7.3.5 alarms2 (SIN 21, MIN 5) Name  Type  Comments  list1   The array of fence crossing data  The latitude at the time the crossing was detected (prior  to any hysteresis checks), in milliminutes  The longitude at the time the crossing was detected  (prior to any hysteresis checks), in milliminutes  The speed at the time the crossing was detected (prior to  any hysteresis checks), in tenths of knots  The heading at the time the crossing was detected (prior  to any hysteresis checks), in tenths of degrees  The fixTime at the time the crossing was detected (prior  to any hysteresis checks), in seconds since the epoch    The array of fence crossing data   The fence number to which the alarm applies  status  Enum  No  2 bits  Whether the alarm is for a fence entry or exit  0 Ð Inside  1 Ð Outside  5.7.3.6 tags (SIN 21, MIN 6) Name Type Comments list The array of fence numbers and tags. Fences without any corresponding tags are omitted from the list. The fence number The tagIndex0 string The tagIndex1 string The tagIndex2 string tag3 Signed Yes ²40 bits The tagIndex3 string 5.7.3.7 fenceDef (SIN 21, MIN 7) Name Type Comments Whether this fence is enabled Controls when alarms should be generated The array of the polygon's points The latitude of the point, in milliminutes longitude Signed No 25 bits The longitude of the point, in milliminutes 5.7.3.8 fenceCheckStatus (SIN 21, MIN 8) Comments The status of the last fence check or time hysteresis check. The fixTime at the time the last successful fence check was performed on enabled fences, expressed as the number of seconds since the epoch. The latitude at the last successful fence check, in milliminutes The longitude at the last successful fence check, in milliminutes The speed at the last successful fence check, in tenths of knots The heading at the last successful fence check in tenths of degrees The age of the GNSS fix at the last successful fence check in seconds. 5.7.4 Constants The geofence service defines the following constants. 5.7.4.1 AlarmCondition Description This table contains a mapping of the alarm conditions to their numerical value: None  0  Entry  1  Exit  2  Both  3  Syntax svc.geofence.AlarmCondition 5.7.4.2 AlarmConditionStr Description This table contains a mapping of the alarm condition numerical values to their string representation: 0 1 2 3  None Entry Exit Both  Syntax  svc.geofence.AlarmConditionStr 5.7.4.3 FenceCheckStatus Description This table contains a mapping of the fence check status to their numerical value: Unknown 0 NotPerformed 1 Success 2 Failure 3 Syntax svc.geofence.FenceCheckStatus 5.7.4.4 FenceCheckStatusStr Description This table contains a mapping of the fence type numerical values to their string representation: 0 Unknown 1 NotPerformed 2 Success 3 Failure Syntax svc.geofence.FenceCheckStatusStr 5.7.4.5 Status Description This table contains a mapping of the fence status to their numerical value: Inside  0  Outside  1  Undefined  2  Syntax  svc.geofence.Status 5.7.4.6 StatusStr Description This table contains a mapping of the fence status numerical values to their string representation: 0 Inside 1 Outside 2 Undefined Syntax svc.geofence.StatusStr 5.7.4.7 Type Description This table contains a mapping of the fence types to their numerical value: Circle 0 Polygon 1 Rectangle 2 Syntax svc.geofence.Type 5.7.4.8 TypeStr Description This table contains a mapping of the fence type numerical values to their string representation: 0 Circle 1 Polygon 2 Rectangle Syntax svc.geofence.TypeStr 5.7.5 Functions 5.7.5.1 enableFence() Description Enables or disables a specific fence. Syntax svc.geofence.enableFence(fenceNum, enable) Parameters  fenceNum enable  The fence number to enable or disable (0 Ð 127). boolean indicating whether to enable (ture) or disable (false) the fence.  Blocking No  Returns  nil|string Nil if successful, or an error description otherwise. Example shell> lua =svc.geofence.enableFence(0, true) shell> 5.7.5.2 getFenceDef() Description Get the definition of one or more fences. Syntax svc.geofence.getFenceDef(É) Parameters É The fences can be specified as either multiple fence number arguments or a single table argument consisting of the desired fence numbers. If no arguments are specified, the definitions of all fences are returned. Blocking No Returns table An array of fence definition entries, each containing the following common fields: number The fence number enabled A Boolean indicating whether the fence is enabled type Fence type (svc.geofence.Type) condition Fence alarm condition (svc.geofence.AlarmCondition) tags A table of defined tags (undefined tags are omitted), containing the following fields: [0] tagIndex0 tag string [1] tagIndex1 tag string [2] tagIndex2 tag string [3] tagIndex3 tag string Fences of type Circle (type = svc.geofence.Type.Circle) include the following extra fields: centre A table defining the center of the circle, containing the following fields: lat Latitude in milliminutes of the center point. long Longitude in milliminutes of the center point. radius The radius of the circle in meters. Fences of type Rectangle (type = svc.geofence.Type.Rectangle) include the following extra fields: centre A table defining the center of the rectangle, containing the following fields: lat Latitude in milliminutes of the center point. long Longitude in milliminutes of the center point. latitudeDistance The distance the rectangle extends to the north and south from the center in meters. longitudeDistance The distance the rectangle extends to the east and west from the center in meters. Fences of type Polygon (type = svc.geofence.Type.Polygon) include the following extra fields: latPoints  Table of the latitude in milliminutes for each point making up the polygon.  longPoints  Table of the longitude in milliminutes for each point making up the polygon.  Example  shell> lua dumpvar(svc.geofence.getFenceDef(6)) ["table: 642561e8"] = { --table: 642561e8 (count= 1) [1] = { --table: 64242360 (count= 0) number = 6 type = 2 centre = { --table: 642432f0 (count= 0) long = -6332820 lat = 2340000 } latitudeDistance = 302308 longitudeDistance = 222588 tags = { --table: 642d6668 (count= 3) [0] = "Colorado" [1] = "USA" [2] = "Interstate speed limit: 70 mph" [3] = "Mountain time" } condition = 3 enabled = true } } shell> 5.7.5.3 getStatus() Description Retrieve the status of one or more fences. Syntax svc.geofence.getStatus(É) Parameters É The fences can be specified as either multiple fence number arguments or a single table argument consisting of the desired fence numbers. If no arguments are specified, the status of all fences is returned. Blocking No  Returns  table  An array of number defined enabled status  fence status entries, each containing the following fields: The fence number A Boolean indicating whether the fence is defined A Boolean indicating whether the fence is enabled 0 Ð Inside, 1 Ð Outside, 2 Ð Undefined  Example  shell> lua dumpvar(svc.geofence.getStatus(6)) ["table: 642a7a68"] = { --table: 642a7a68 (count= 1) [1] = { --table: 642a7aa8 (count= 0) number = 6 status = 1 enabled = true defined = true } } shell> 5.7.5.4 getTags() Description Retrieve the tags of one or more fences. Syntax svc.geofence.getTags(fenceNums, tagIndices) Parameters  fenceNums The fences can be specified as either a single fence number argument or a single table  argument consisting of the desired fence numbers. If no arguments are specified, the tags of  all fences are returned.  tagIndices The tag indices can be specified as either a single tag index argument or a single table  argument consisting of the desired tag indices. If no arguments are specified, the tags of all  tag indices are returned.  Blocking  No  Returns  table  An array of entries, each containing the following fields:  number  The fence number  tags  A table of defined tags (undefined tags are omitted), containing the following fields:  [0]  tagIndex0 tag string  [1]  tagIndex1 tag string  [2]  tagIndex2 tag string  [3]  tagIndex3 tag string  Example  shell> lua dumpvar(svc.geofence.getTags(6)) ["table: 642496c8"] = { --table: 642496c8 (count= 1) [1] = { --table: 64249838 (count= 0) number = 6 tags = { --table: 64249808 (count= 3) [0] = "Colorado" [1] = "USA" [2] = "Interstate speed limit: 70 mph" [3] = "Mountain time" } } } shell> 5.7.5.5 removeTags() Description Remove the tags of one or more fences, and one or more tag indices. Syntax svc.geofence.removeTags(fenceNumArray, removeTag0, removeTag1, removeTag2, removeTag3) Parameters fenceNumArray Array table of the desired fence numbers (or an empty table for all fences), or nil for all fences removeTag0  Remove tag0 tags if true  removeTag1  Remove tag1 tags if true  removeTag2  Remove tag2 tags if true  removeTag3  Remove tag3 tags if true  Blocking  No  Returns  nil nil if no error encountered, error string otherwise Example shell> lua svc.geofence.removeTags({6}, false, false, true, false) shell> lua dumpvar(svc.geofence.getTags(6)) ["table: 6428ad70"] = { --table: 6428ad70 (count= 1) [1] = { --table: 6428ada0 (count= 0) number = 6 tags = { --table: 6428acd0 (count= 1) [0] = "Colorado" [1] = "USA" [3] = "Mountain time" } } } shell> 5.7.5.6 setTags() Description Set the tags of one or more fences. Syntax svc.geofence.setTags(newTags) Parameters  newTags  An array of number tags  tag information, each entry containing the following fields: The fence number A table of tag strings where any subset of tags 0...3 may exist. An empty string removes the tag. [0] tagIndex0 tag string [1] tagIndex1 tag string [2] tagIndex2 tag string [3] tagIndex3 tag string  Blocking No  Returns  nil  nil if no erro r encountered, error string otherwise  Example  shell> lua dumpvar(svc.geofence.getTags(6)) ["table: 642a05f8"] = { --table: 642a05f8 (count= 0) } shell> lua svc.geofence.setTags({ {number=6,tags={[0]="Colorado",[1]="USA", [2]="Interstate speed limit: 70 mph",[3]="Mountain time"} } }) shell> lua dumpvar(svc.geofence.getTags(6)) ["table: 6428d0a0"] = { --table: 6428d0a0 (count= 1) [1] = { --table: 642d3a58 (count= 0) number = 6 tags = { --table: 642564d8 (count= 3) [0] = "Colorado" [1] = "USA" [2] = "Interstate speed limit: 70 mph" [3] = "Mountain time" } } } shell> 5.7.6 Posted Events 5.7.6.1 Fence Check Done Description This event is posted when the fence check completes and the checkDoneEvents (PIN 23) property is true. Source svc.geofence (geofence service table) Event ÒFENCE_CHECK_DONEÓ (string) Arguments number The fence check status 1 Ð Success, 2 Ð Failure 5.7.6.2 Fence Crossing Alarm Description This event is posted when a fence entry or exit is detected, or when a fence status changes from undefined to inside/outside, regardless of the fence's alarm condition setting, and regardless of the sendAlarm and logAlarm property values. Source svc.geofence (geofence service table) Event  ÒALARMÓ  (string)  Arguments  table  A table with the following fields (see the alarm message): number The fence number  status  0 Ð Inside, 1 Ð Outside  prevStatus latitude longitude speed  The previous status: 0 Ð Inside, 1 Ð Outside, 2 Ð Undefined The latitude at the time the crossing was detected, (prior to any hysteresis checks), in milliminutes The longitude at the time the crossing was detected, (prior to any hysteresis checks), in milliminutes The speed at the time the crossing was detected (prior to any hysteresis checks), in tenths of knots  heading  The heading at the time the crossing was detected (prior to any hysteresis  checks), in tenths of degrees  fixTime  The fixTime at the time the crossing was detected (prior to any hysteresis  checks), in seconds since the epoch  5.7.6.3 Fence Crossing Alarm (multiple) Description This event is posted when one or more fence entry or exit events are detected, or when a fence status changes from undefined to inside/outside, regardless of the fence's alarm condition setting, and regardless of the sendAlarm and logAlarm property values. Source svc.geofence (geofence service table) Event ÒALARMSÓ (string) Arguments table An array of alarms, where each entry is a table with the following fields (see the alarms message): number The fence number status 0 Ð Inside, 1 Ð Outside prevStatus The previous status: 0 Ð Inside, 1 Ð Outside, 2 Ð Undefined latitude The latitude at the time the crossing was detected, (prior to any hysteresis checks), in milliminutes longitude The longitude at the time the crossing was detected, (prior to any hysteresis checks), in milliminutes speed The speed at the time the crossing was detected (prior to any hysteresis checks), in tenths of knots heading The heading at the time the crossing was detected (prior to any hysteresis checks), in tenths of degrees fixTime The fixTime at the time the crossing was detected (prior to any hysteresis checks), in seconds since the epoch 5.7.6.4 Hysteresis Check Done Description This event is posted when hysteresis check completes and the checkDoneEvents (PIN 23) property is true. Source svc.geofence (geofence service table) Event ÒHYST_CHECK_DONEÓ (string) Arguments number The fence check status 1 Ð Success, 2 Ð Failure 5.8 Serial (SIN 22) The serial service manages communication through the terminal's various serial ports (RS-232 and RS-485), including their configuration and status. Table 2: Property to Physical Port Connector Mapping 5.8.1 ST 6000 The ST 6000 does not have any integral RS-232 or RS-485 transceivers, so the rs232mainTcvrMode and rs232auxTcvrMode properties have no effect. If the ÔConsole ValidÕ and ÔAUX ValidÕ lines are not connected/used, then DTE connection detection functionality and related features (ÔautoÕ shutdown mode) are not supported. The ST 6000 supports full serial power management features as long as the corresponding ÔVALIDÕ line is connected and asserted when an external connection is present. 5.8.2 Properties 1The rs232mainEnabled property is provided for compatibility with the old enabled property of the rs232 service, and has no effect. The rs232 port is enabled whenever connect() is called and disabled whenever disconnect() is called. 1Only with 8 data bits 1Only with 8 data bits. The rs232mainTcvrMode property controls when the transceiver turns itself on or off. The autoShutdown value should be used in most cases, and it allows the transceiver to automatically turn itself off when there is no DTE connected; otherwise it is turned on. The forceOn value is useful when connected to a DTE which also uses automatic shutdown; one of them must be forced on, or they both remain off. Finally, the forceOff value is useful when connected to a DTE which is not in use; forcing the transceiver off can help prevent unnecessary leakage. The rs232mainShutdownMode property controls what to do with the UART when going into low power mode. When the property is set to Auto, the action taken depends on whether a DTE is connected or not. If a DTE is connected, then the UART is not shut down and the terminal remains in normal operating mode; if no DTE is connected, then the UART is shut down and the low power mode is entered. Setting the property to Always ensures that the UART is always shut down, and allows low power mode to be entered; setting it to Never has the opposite effect. 5.8.2.1 External DTE Connect/Disconnect The rs232main port supports full DTE connect/disconnect event notification via the built-in transceiver. When the INVALID line of the transceiver changes state, a DTE connect/disconnect event is generated. The transceiver determines if a terminal is connected by the voltage state of the Rx line coming into the terminal. The rs232mainDTEEdgeDetect property controls which transition of this signal should generate events and the rs232mainDTEEdgeSampleCount and rs232mainDTEEdgeSampleError properties control the filtering on this line. The rs232mainDTEIsConnected volatile property can be used to query the current state of this line to determine if an external terminal is connected. Table 3: RS-232 Port Differences ST 6100 ST 9100 and ST Desktop Main Main Debug Transceiver Present YES YES YES Transceiver FON/FOFF control YES YES NO DTE Connection state YES YES NO DTE Alarming/Logging YES YES NO DTE Edge Transition Config YES YES NO DTE Edge Filter Config YES YES NO UART Break Detection YES YES YES UART Break Alarming/Logging YES YES YES Configurable Power Management YES YES NO 5.8.2.2 Power Management The rs232mainShutdownMode property controls when the terminal can enter power save mode and the UART can be turned off to save power. When the property is set to Auto, the action taken depends on whether a DTE is connected to the port or not. If a DTE is connected, the terminal is blocked from entering power save mode and the UART stays fully powered to allow for normal communication. If no DTE is connected, the terminal is able to enter power save mode. Setting the property to Always allows the terminal to enter power save mode (and therefore powering down the UART) at any time, even if communication is in progress on the port. Setting the property to Never prevents the terminal from entering power save mode and keeps the UART fully operational at all times, even when nothing is connected. The ST 6000 supports full serial power management features as long as the corresponding ÔVALIDÕ line is connected and asserted when an external connection is present. 5.8.3 To-Mobile Messages This service does not currently define any to-mobile messages. 5.8.4 From-Mobile Messages 5.8.4.1 DTEAlarm (SIN 22, MIN 1) This message is never sent. Name Type Optional Size Comments DTEConnected Boolean No 1 bit Whether the alarm is for the DTE being connected or disconnected. port String No ²16 bytes 'rs232main', 'rs232aux' other values are reserved * rs232aux not available on all models. 5.8.4.2 breakAlarm (SIN 22, MIN 2) 5.8.5 Functions 5.8.5.1 connect() Description Open a connection to the RS-232 port. The port is opened in exclusive mode, so only one caller at a time can have it open. A call to connect returns a handle which is used to call all other functions exported by this service. Any given function xxx can be called in one of two ways: ¥ handle.xxx(handle, ...) ¥ handle:xxx(...) Syntax svc.serial.connect(port) Parameters port The port to connect to can be either 'rs232main', 'rs232aux' or 'rs485' (default to 'rs232main' if nil or no argument is provided). rs232aux not available on all models. Blocking No Returns  handle  A handle allowing subsequent access to all port functions, or nil if the port has already been  opened  string  An error message when the port has already been opened, or nil  Example local handle, err = svc.serial.connect() if handle then handle.writestr(handle, "This is a test.") handle:writestr("This is another test.") svc.serial.disconnect(handle) else printf("Error opening rs232 connection (%s)\n", err) end handle, err = svc.serial.connect('rs485') if handle then handle.writestr(handle, "This is a test.") handle:writestr("This is another test.") svc.serial.disconnect(handle) else printf("Error opening rs485 connection (%s)\n", err) end 5.8.5.2 disconnect() Description Close a previously-opened connection. Syntax svc.serial.disconnect(handle) Parameters handle The handle that was returned by the call to connect(). Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure; nil otherwise 5.8.6 Common Handle Methods The following methods are available on the handle for any port connection. 5.8.6.1 cancelEvent() Description Cancels any pending eventOnByte(), eventOnLine(), and eventOnFrame(). Syntax <handle>:cancelEvent() Parameters None Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure; nil otherwise 5.8.6.2 disconnect() Description Closes the serial channel associated with the handle. This is equivalent to calling the disconnect() method with the <handle> as the argument. Syntax <handle>:disconnect() Parameters None Blocking No Returns None 5.8.6.3 eventOnByte() Description Causes the BYTE event to be posted when the next byte is received by the serial port. Syntax <handle>:eventOnByte(timeout) Parameters  timeout  Timeout in milliseconds. A negative timeout means wait forever, and a timeout of zero means no  timeout and to poll the interface.  Blocking  No  Returns  boolean  Indicates success or failure  string  A description of the error in the case of a failure; nil otherwise  5.8.6.4 eventOnFrame() Description This function enables the FRAME event to be posted when the next time a stream of data matching the frame configuration is received. Syntax <handle>:eventOnFrame(len, timeout) Parameters len The number of bytes to read. A value of zero means the configured maximum. timeout Timeout in milliseconds. A negative timeout means wait forever, and a timeout of zero means no timeout and to poll the interface. Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure; nil otherwise Example This example transparently receives frames based on a timeout and a maximum length. local SimpleFrameConfig = { maxRxSize=4096, maxTxSize=4096 } handle:setFrameConfig(SimpleFrameConfig) . . . --Generate a frame event after 2000 received bytes or 5000ms timeout, whichever is first. handle:eventOnFrame(2000, 5000) 5.8.6.5 eventOnLine() Description Causes the line event to be posted after the configured delimiter sequence had been received. Syntax <handle>:eventOnLine(timeout) Parameters  timeout  Timeout in milliseconds. A negative timeout means wait forever, and a timeout of zero means no  timeout and to poll the interface.  Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure; nil otherwise 5.8.6.6 flush() Description Flushes out any pending data from the serial port buffers. Flushing a serial handle cancels any pending event condition. Syntax <handle>:flush(mode) Parameters  mode  A strin'*r' '*t' '*b'  g describing the desired mode Flush (empty) the received buffer Flush the transmit buffer (wait until it is empty) Flush both buffers  Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure; nil otherwise 5.8.6.7 getByte() Description Get a byte from the serial port with a timeout. Internally eventOnByte() is called and then a temporary message queue is created to collect the BYTE event and wait() is called to wait until the event occurs. Syntax <handle>:getByte(timeout) Parameters timeout Timeout in milliseconds. A negative timeout means wait forever, and a timeout of zero means no timeout and to poll the interface. Blocking Yes Returns byte Integer value of the byte received, or -1 if a error occurred err String error message when the returned byte is -1 5.8.6.8 getFrame() Description Get a frame of data from the serial port with a timeout. Internally eventOnFrame() is called and then a temporary message queue is created to collect the frame event and wait() is called to wait until the event occurs. Syntax <handle>:getFrame(len, timeout) Parameters len  The number of bytes to read. Zero uses the maximum configured size  timeout  Timeout in milliseconds. A negative timeout means wait forever, and a timeout of zero means no  timeout and to poll the interface.  Blocking  Yes  Returns  success  Boolean indicating true if the frame was received successfully or if a timeout occurred, and  false otherwise  frame  String containing the received data if success, otherwise a string indicating the error. If a timeout  occurs, success is true but the frame string is empty  5.8.6.9 getFrameConfig() Description Query the configuration of the serial port frame processor. Syntax <handle>:getFrameConfig() Parameters None Blocking No Returns boolean Indicates success or failure table A table with the same configuration fields passed to setFrameConfig(). 5.8.6.10 getLine() Description Retrieves a delimited line from the serial port with a timeout. Internally eventOnLine() is called and then a temporary message queue is created to collect the line event and wait() is called to wait until the event occurs. Syntax <handle>:getLine(timeout) Parameters timeout Timeout in milliseconds. A negative timeout means wait forever, and a timeout of zero means no timeout and to poll the interface. Blocking  Yes  Returns  string  Contains the received line, or whatever is in the buffer if a timeout occurred, or nil if an error  occurred  errMsg  A string description of the error if string is nil  5.8.6.11 getLineConfig() Definition Query the configuration of the RS-232 line processor Syntax <handle>:getLineConfig() Parameters None Blocking No Returns boolean Indicates success or failure table A table with the same configuration fields passed to setLineConfig() 5.8.6.12 sendBreak() Description Sends a break. Syntax <handle>:sendBreak() Parameters None Blocking No Returns boolean Indicates success or failure string An error message if a failure occurs or nil otherwise 5.8.6.13 setBaud() Description Change the baud rate of the serial interface. Syntax <handle>:setBaud(baud) Parameters  baud  The integer baud rate to use (1200, 2400, and so on.)  Blocking  No  Returns  boolean  Indicates success or failure  string  An error message if a failure occurs or nil otherwise  5.8.6.14 setFrameConfig() Description Specifies the configuration of the serial port frame processor. The frame processor can be used to automatically delimit, escape, and checksum frames of binary data. Configuration parameters are optional and use default values if not present. A frameEnd value is mandatory only if a frameStart value is provided. FRAME is better suited for operations on raw buffers of data using no delimiter. Syntax <handle>:setFrameConfig(config) Parameters config A table with any of the following fields: maxRxSize Maximum receive frame size (integer). If present, includes the errorDetection size. For example, if the maximum payload you can receive is 20 bytes, and you have no errorDetection, then the maxRxSize=20 (22 if 16-bit errorDetection is used). maxTxSize Maximum transmit frame size (integer). Accommodates fully escaped frame (including errorDetection). For example, if the maximum payload you can transmit is 20 bytes, then you need a maxTxSize greater than 20 to accommodate possible escape sequences. minFrameSize Minimum size of the frame (integer). This is used to generate an error if the unescaped data portion of the frame is less than this value. For example, if you always expect a minimum of msgType byte and length byte, then set minFrameSize to 2. frameStart frameEnd escapeByte escapeMapping errorDetection Start of a frame byte (integer). End of a frame byte (integer). This field is mandatory if a frameStart value is provided. Bytes to escape (string) Strings to map each escapeByte to (table of strings) Error detection mechanism (string) can be one of: "" none "*cs16" 16-bit checksum "*crc16" 16-bit CCITT CRC Blocking  No  Returns  boolean  Indicates success or failure  string  A description of the error in the case of a failure; nil otherwise  Default Configuration  maxRxSize  1024  maxTxSize  1024  minFrameSize  0  escapeBytes  "" (no escaping)  escapeMapping {} errorDetection "" (none) 5.8.6.15 setLineConfig() Description Specifies the configuration of the serial port line processor. Syntax <handle>:setLineConfig(config) Parameters: config A table with any of the following fields: maxLineSize  Maximum size of a line (number)  echo  indicate if characters are echoed as input (Boolean)  onlyPrintable  If true, ignore nonprintable characters (Boolean)  backspace  If true, perform a destructive backspace (Boolean)  controlBytes  List bytes that are passed immediately (string)  delimiterSeq  Sequence of characters to delimit a line (string)  Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure; nil otherwise Default Configuration:  maxLineSize  200  echo  false  onlyPrintable  false  backspace  false  controlBytes  ""  delimiterSeq  "\n"  Example Set up the line processor to allow for up to 300 character lines, echo input, filter out nonprintable characters, pass <CTRL-C> and <CTRL-D> immediately, and use a carriage return to terminate line processing. local res, err = handle:setLineConfig( { maxLineSize = 300, echo = true, onlyPrintable = true, backspace = true, controlBytes = '\003\004', delimiterSeq = '\r' } ) 5.8.6.16 source() Description Returns the event source events generated from this serial interface. Syntax <handle>:source() Parameters None Blocking No Returns source Source of events generated from this interface 5.8.6.17 write() Description Write an arbitrary number of string, table (array format) or byte arguments to the port. Syntax <handle>:write(É) Parameters ... A variable number of integer, string or table arguments. The integer arguments are treated as bytes (range of 0 to 255), strings are treated as sequences of bytes, and tables are interpreted as arrays (indexed starting at 1) of bytes. Blocking No Returns  boolean  Indicates success or failure  string  A description of the error in the case of a failure; nil otherwise  Example Output the string Òhello worldÓ followed by a carriage return and line feed character. handle:write("hello world", 13, 10) Output to the port the binary sequence: 01 0C 01 81 03 04 (shown here in hex). SOH = 0x01 EOT = 0x04 É val = 1 É data = { 12, 1, bit32.bor(0x80,val),3 } handle:write(SOH, data, EOT) 5.8.6.18 writeframe() Description Write an arbitrary number of string, table (array format) or byte arguments to the port, using the configured framing protocol. Syntax <handle>:writeframe(É) Parameters É The integer arguments are treated as bytes (range of 0 to 255), strings are treated as sequences of bytes, and tables are interpreted as arrays (indexed starting at 1) of bytes Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure; nil otherwise Example Output the binary frame: 01 03 00 10 24 AA BB 10 31 CC FD B6 04 (shown here in hex), which includes the SOT and EOT characters, escaped control characters and the checksum. local DMRFrameConfig = { maxRxSize = 2048, maxTxSize = 2048, minFrameSize = 5, --prefix + length + chksum frameStart = SOH, frameEnd = EOT, escapeBytes = string.char(SOH, EOT, DLE, XON, XOFF), escapeMapping = { string.char(DLE, SOH+0x20), string.char(DLE, EOT+0x20), string.char(DLE, DLE+0x20), string.char(DLE, XON+0x20), string.char(DLE, XOFF+0x20) }, errorDetection = '*cs16' --16-bit checksum mode } handle:setFrameConfig(DMRFrameConfig) data = { 0xAA, 0xBB, 0x11, 0xCC } --data with XON in middle. lenHi = bit32.rshift(#data, 8) lenLow = bit32.band(#data, 0xFF) handle:writeframe({ 3, lenHi, lenLow }, data) 5.8.6.19 writestr() Description Write an arbitrary number of string, table (array format) or byte arguments to the port, converting '\n' characters into '\r\n' sequences. Syntax <handle>:writestr(É) Parameters ... A variable number of integer, string or table arguments. The integer arguments are treated as bytes (range of 0 to 255), strings are treated as sequences of bytes, and tables are interpreted as arrays (indexed starting at 1) of bytes. Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure; nil otherwise 5.8.7 Posted Events 5.8.7.1 Break Condition Description Posted that a break condition has been detected on the port. (terminals) Source <handle>:source() (string) Event "BREAK" (string) Arguments None 5.8.7.2 Byte Received Description Event that is posted when a byte has been received by the UART. Source <handle>:source() (string) Event "BYTE" (string) Arguments byte Integer value of the byte received, or -1 if a timeout occurred 5.8.7.3 DTE Connection Description Event posted that a DTE terminal has been either connected or disconnected from the RS-232 port. Source "_RS232MAIN" (string) "_RS232AUX" (string) Event "DTECONNECTED" (string) Arguments connected Boolean that if true indicates that a DTE terminal has been connected, otherwise the terminal has been disconnected. 5.8.7.4 Frame Received Description Posted that a protocol frame of binary data has been received by the UART. Source: <handle>:source() (string) Event: "FRAME" (string) Arguments: success Boolean indicating true if the frame was received successfully frame String containing the received data, or an error message if success is false 5.8.7.5 Line Received Description Event posted that a line has been received by the UART. Source <handle>:source() (string) Event "LINE" (string) Arguments line String containing received line 5.9 Log (SIN 23) The log service provides the ability to store data in nonvolatile storage for history and/or troubleshooting purposes. The data log can store any outgoing message; the debug log stores arbitrary strings. This service also provides auto upload capabilities. When responding to a query, or when auto uploading message log entries, the log service does not send entries if the SIN or MIN no longer exist (due to a service being removed from the terminal or modified). The log service has two sets of properties. The first set controls which debug log entries are saved to the log files, while the second controls which ones are output on the trace port. Each set consists of 14 Data properties, one for each of the debug log levels; levels 0 and 1 (CRITICAL, ERROR) cannot be suppressed. Each property is a list of SINs that are suppressed for that level. CAUTION: Observe caution when enabling extra debug logging because most serial tracking output is now generated as an INFO level debug log. For example, setting Bit 3 of the debugLogLevelMask writes all modem command/responses to the debug files. This can be controlled by using the suppression features (PINs 16 to 43) to filter out logs from services that are not required. 5.9.1 Properties 5.9.2 To-Mobile Messages Description 8 Sets a filter for the auto uploading of data log records. An uploadDataLogFilter message is generated in response. 9 Sets a filter for the auto uploading of debug log records. An uploadDebugLogFilter message is generated in response. 10 Requests the approximate number of records remaining to be auto uploaded based on the upload data log filter. An uploadDataLogCount message is generated in response. 11 Requests the approximate number of records remaining to be auto uploaded based on the upload debug log filter. An uploadDebugLogCount message is generated in response. 12 Sets a filter for subsequent retrieval of debug log records. A debugLogFilter2 message is generated in response. This message must be used instead of setDebugLogFilter when the SIN is to be used as a filtering criterion. 13 Requests a block of records matching the data log filter. A debugLogEntries2 message is generated in response. This message must be used instead of getDebugLogEntries when the response must include the SIN. 14 setUploadDebugLogFilter2 Sets a filter for the auto uploading of data log records. An uploadDebugLogFilter2 message is generated in response. This message must be used instead of setUploadDebugLogFilter when the SIN is to be used as a filtering criterion. 5.9.2.1 setDataLogFilter (SIN 23, MIN 1) Comments The start of the range of sequence numbers to include The end of the range of sequence numbers to include The start of the range of timestamps to include The end of the range of timestamps to include Whether to return the records in reverse order An optional list of SIN/MIN pairs to include. If not specified, or the size is 0, include all SINs. The SIN to include A list of MINs to include for the SIN. If not specified, or the size is 0, include all MINs. 5.9.2.2 setDebugLogFilter (SIN 23, MIN 2) Field Name Field Type Optional Field Field Size Comments seqStart The start of the range of sequence numbers to include seqEnd The end of the range of sequence numbers to include timeStart The start of the range of timestamps to include timeEnd The end of the range of timestamps to include reverse Whether to return the records in reverse order levels Unsigned Yes 16 bits An optional bitmap of debug levels to include 5.9.2.3 getDataLogCount (SIN 23, MIN 3) This message does not contain any fields. 5.9.2.4 getDebugLogCount (SIN 23, MIN 4) This message does not contain any fields. 5.9.2.5 getDataLogEntries (SIN 23, MIN 5) 5.9.2.6 getDebugLogEntries (SIN 23, MIN 6) 5.9.2.7 clearLogs (SIN 23, MIN 7) Name  Type  Optional  Size  Comments  logType  Enum 0 Ð Data 1 Ð Debug 2 Ð Both  No  2 bits  Set of log files to remove  5.9.2.8 setUploadDataLogFilter (SIN 23, MIN 8) Sets a filter for the auto uploading of data log records and stores it in data/svc/log/msgUpld.dat to ensure these settings are nonvolatile. Upon reset, if no such file exists, the default filter is as follows: ¥ maxSize: 6400 bytes ¥ maxEntries: as many records as can fit in the maxSize ¥ ageLimit: 604800s (7 days) ¥ reverse: false (oldest records sent first) ¥ all SINs and MINs included Name  Type  Optional  Size  Comments  maxSize  Unsigned  Yes  16 bits  The maximum size of individual uploadDataLogEntries return messages. At least 1 record is returned, even if it causes the return message to exceed this value. If not specified, the maximum size of messages supported by the terminal is used.  Comments The maximum number of records to return in individual uploadDataLogEntries return messages. If not specified, return as many records as can fit in the maximum size. Age limit (with respect to ever-changing system time), in seconds, which can be used to restrict (by age) the number of records to be auto uploaded. Only records within the age limit are auto uploaded. Any age limit < 60 is set to 60. If not specified, include all records. Whether to return the records in reverse order. An optional list of SIN/MIN pairs to include. If not specified, or the size is 0, include all SINs. SIN to include A list of MINs to include for the SIN. If not specified, or the size is 0, include all MINs 5.9.2.9 setUploadDebugLogFilter (SIN 23, MIN 9) Sets a filter for the auto uploading of debug log records, and stores it in data/svc/log/dbgUpld.dat to ensure these settings are nonvolatile. Upon reset, if no such file exists, the default filter is as follows: ¥ maxSize: 6400 bytes ¥ maxEntries: as many records as can fit in the maxSize ¥ ageLimit: 604800s (7 days) ¥ reverse: false (oldest records sent first) ¥ levels: 65535 (all levels included) Name Type Optional Size Comments maxSize The maximum size of individual uploadDebugLogEntries return messages. At least 1 record is returned, even if it causes the return message to exceed this value. If not specified, the maximum size of messages supported by the terminal is used. maxEntries The maximum number of records to return in individual uploadDebugLogEntries return messages. If not specified, return as many records as can fit in the maximum size. ageLimit Age limit (with respect to ever-changing system time), in seconds, which can be used to restrict (by age) the number of records to be auto uploaded. Only records within the age limit are auto uploaded. Any age limit < 60 is set to 60. If not specified, include all records. reverse Whether to return the records in reverse order levels Unsigned Yes 16 bits An optional bitmap of debug levels to include 5.9.2.10 getUploadDataLogCount (SIN 23, MIN 10) This message does not contain any fields. 5.9.2.11 getUploadDebugLogCount (SIN 23, MIN 11) This message does not contain any fields. 5.9.2.12 setDebugLogFilter2 (SIN 23, MIN 12) Sets a filter for subsequent retrieval of debug log records. A debugLogFilter2 message is generated in response. This message must be used instead of setDebugLogFilter when the SIN is to be used as a filtering criterion. Comments The start of the range of sequence numbers to include The end of the range of sequence numbers to include The start of the range of timestamps to include The end of the range of timestamps to include Whether to return the records in reverse order An optional bitmap of debug levels to include An optional list of SINs to include. If not specified, or the size is 0, include all SINs. 5.9.2.13 getDebugLogEntries2 (SIN 23, MIN 13) Requests a block of records matching the data log filter. A debugLogEntries2 message is generated in response. This message must be used instead of getDebugLogEntries when the response must include the SIN. 5.9.2.14 setUploadDebugLogFilter2 (SIN 23, MIN 14) Sets a filter for the auto uploading of data log records. An uploadDebugLogFilter2 message is generated in response. This message must be used instead of setUploadDebugLogFilter when the SIN is to be used as a filtering criterion. 5.9.3 From-Mobile Messages Description 1 Confirmation that a data log filter was set 2 Confirmation that a debug log filter was set 3 The number of data log records that match the current filter 4 The number of debug log records that match the current filter 5 A block of data log records matching the data log filter 6 A block of debug log records matching the debug log filter 7 Confirmation that an upload data log filter was set 8 Confirmation that an upload debug log filter was set 9 The approximate number of data log records remaining to be auto uploaded based on the upload data log filter. 10 The approximate number of debug log records remaining to be auto uploaded based on the upload debug log filter 11 A block of data log records matching the upload data log filter 12 A block of debug log records matching the upload debug log filter 13 Confirmation that a debug log filter was set 14 A block of debug log records matching the debug log filter 15 Confirmation that an upload debug log filter was set 16 uploadDebugLogEntries2 A block of debug log records matching the upload debug log filter 5.9.3.1 dataLogFilter (SIN 23, MIN 1) Name Type Optional Size Comments seqStart The start of the range of sequence numbers to include seqEnd The end of the range of sequence numbers to include timeStart The start of the range of timestamps to include timeEnd The end of the range of timestamps to include reverse Whether to return the records in reverse order list Array Yes ²255 elements An optional list of SIN/MIN pairs to include. If not specified, or the size is 0, include all SINs. 5.9.3.2 debugLogFilter (SIN 23, MIN 2) Name Type Optional Size Comments seqStart Unsigned Yes 31 bits The start of the range of sequence numbers to include seqEnd Unsigned Yes 31 bits The end of the range of sequence numbers to include timeStart Signed Yes 32 bits The start of the range of timestamps to include timeEnd Signed Yes 32 bits The end of the range of timestamps to include reverse Boolean No 1 bit Whether to return the records in reverse order levels Unsigned Yes 16 bits An optional bitmap of debug levels to include. 5.9.3.3 dataLogCount (SIN 23, MIN 3) Name Type Optional Size Comments matchingEntries Unsigned No 31 bits The number of matching records firstEntrySeq Unsigned No 31 bits The sequence number of the first matching record firstEntryTime Signed No 32 bits The time stamp of the first matching record lastEntrySeq Unsigned No 31 bits The sequence number of the last matching record lastEntryTime Signed No 32 bits The time stamp of the last matching record firstEntryUploaded Boolean No 1 bit Indication that the first matching record has been auto uploaded lastEntryUploaded Boolean No 1 bit Indication that the last matching record has been auto uploaded 5.9.3.4 debugLogCount (SIN 23, MIN 4) Name Type Comments matchingEntries Unsigned No 31 bits The number of matching records firstEntrySeq Unsigned No 31 bits The sequence number of the first matching record firstEntryTime Signed No 32 bits The time stamp of the first matching record lastEntrySeq Unsigned No 31 bits The sequence number of the last matching record lastEntryTime Signed No 32 bits The time stamp of the last matching record firstEntryUploaded Boolean No 1 bit Indication that the first matching record has been auto uploaded lastEntryUploaded Boolean No 1 bit Indication that the last matching record has been auto uploaded 5.9.3.5 dataLogEntries (SIN 23, MIN 5) 5.9.3.6 debugLogEntries (SIN 23, MIN 6) Name Type Optional Size Comments entryList A list of debug log records uploaded Indication that the record has been auto uploaded sequence The record's sequence number timestamp The record's time stamp level The record's log level log String No ²128 bytes The record 5.9.3.7 uploadDataLogFilter (SIN 23, MIN 7) Comments The maximum size of individual uploadDataLogEntries return messages. At least 1 record is returned, even if it causes the return message to exceed this value. If not specified, the maximum size of messages supported by the terminal is used. The maximum number of records to return in individual uploadDataLogEntries return messages. If not specified, return as many records as can fit in the maximum size. Age limit (with respect to ever-changing system time), in seconds, which can be used to restrict (by age) the number of records to be auto uploaded. Only records within the age limit are auto uploaded. Any age limit < 60 is set to 60. If not specified, include all records. Whether to return the records in reverse order. An optional list of SIN/MIN pairs to include. If not specified, or the size is 0, include all SINs. The SIN to include A list of MINs to include for the SIN. If not specified, or the size is 0, include all MINs 5.9.3.8 uploadDebugLogFilter (SIN 23, MIN 8) 5.9.3.9 uploadDataLogCount (SIN 23, MIN 9) Name  Type  Optional  Size  Comments  maxSize  Unsigned  Yes  16 bits  The maximum size of individual uploadDataLogEntries return messages. At least 1 record is returned, even if it causes the return message to exceed this value. If not specified, the maximum size of messages supported by the terminals used.  5.9.3.10 uploadDebugLogCount (SIN 23, MIN 10) 5.9.3.11 uploadDataLogEntries (SIN 23, MIN 11) Name Type Optional Size Comments searchStatus Enum No 3 bits searchStatus 0 Ð MatchingRecordsFound 1 Ð LastMatchingRecordFound All other values are reserved entryList Array No ²255 elements A list of data log records sequence Unsigned No 31 bits The record's sequence number timestamp Unsigned No 31 bits The record's timestamp log Submessage No n/a The record 5.9.3.12 uploadDebugLogEntries (SIN 23, MIN 12) Name Type Optional Size Comments searchStatus searchStatus 0 Ð MatchingRecordsFound 1 Ð LastMatchingRecordFound All other values are reserved entryList A list of data log records sequence The record's sequence number The record's time stamp level The record's log level log String No ²128 bytes The record 5.9.3.13 debugLogFilter2 (SIN 23, MIN 13) Comments The start of the range of sequence numbers to include The end of the range of sequence numbers to include The start of the range of timestamps to include The end of the range of timestamps to include Whether to return the records in reverse order An optional bitmap of debug levels to include An optional list of SINs to include. If not specified, or the size is 0, include all SINs. 5.9.3.14 debugLogEntries2 (SIN 23, MIN 14) Name Type Optional Size Comments entryList Array No ²255 elements A list of debug log records uploaded Boolean No 1 bit Indication that the record has been auto-uploaded sequence Unsigned No 30 bits The record's sequence number timestamp Unsigned No 31 bits The record's time stamp level Unsigned No 4 bits The record's log level sin Unsigned No 8 bits The record's SIN log String No ²128 bytes The record 5.9.3.15 uploadDebugLogFilter2 (SIN 23, MIN 15) Comments The maximum size of individual uploadDebugLogEntries2 return messages. At least 1 record is returned, even if it causes the return message to exceed this value. If not specified, the maximum size of messages supported by the terminal is used. The maximum number of records to return in individual uploadDebugLogEntrie2s return messages. If not specified, return as many records as can fit in the maximum size. Age limit (with respect to ever-changing system time), in seconds, which can be used to restrict (by age) the number of records to be auto uploaded. Only records within the age limit are auto uploaded. Any age limit < 60 is set to 60. If not specified, include all records. Whether to return the records in reverse order An optional bitmap of debug levels to include An optional list of SINs to include. If not specified, or the size is 0, include all SINs. 5.9.3.16 uploadDebugLogEntries2 (SIN 23, MIN 16) Name Type Optional Size Comments searchStatus searchStatus 0 Ð MatchingRecordsFound 1 Ð LastMatchingRecordFound All other values are reserved entryList A list of data log records sequence The record's sequence number timestamp The record's time stamp level The record's log level log String No ²128 bytes The record 5.9.4 Constants The log service defines the following constants. 5.9.4.1 CRITICAL This constant has a value of 0, and is the level used in debug logs to represent critical errors. 5.9.4.2 ERROR This constant has a value of 1, and is the level used in debug logs to represent errors. 5.9.4.3 WARNING This constant has a value of 2, and is the level used in debug logs to represent warnings. 5.9.4.4 INFO This constant has a value of 3, and is the level used in debug logs to represent informational logs. 5.9.4.5 Levels Description This table contains a mapping of the predefined debug log levels to their numerical value: CRITICAL 0 ERROR 1 WARNING 2 INFO 3 Syntax svc.log.Levels 5.9.4.6 LevelsStr Description This table contains a mapping of the predefined debug log level numerical values to their string representation: 0 'CRITICAL' 1 'ERROR' 2 'WARNING' 3 'INFO' Syntax svc.log.LevelsStr 5.9.5 Functions 5.9.5.1 addDebug() Description This function adds a new entry to the debug log, if the specified level is enabled in the debugLogLevelsMask property and is not disabled in the appropriate logSuppressX property. In addition, the log is output to the trace port if not suppressed in the appropriate traceSuppressX property. Adding a level 0 log (critical error) resets the terminal. Syntax svc.log.addDebug(sin, level, dbgStr) Parameters  sin level dbgStr  The SIN of the service adding the log (16-255) The debug log level (0-15) The string to log; the string is truncated at 128 characters  Blocking No  Returns None  5.9.5.2 addDebugf() Description This function adds a new entry to the debug log, if the specified level is enabled in the debugLogLevelsMask property and is not disabled in the appropriate logSuppressX property. In addition, the log is output to the trace port if not suppressed in the appropriate traceSuppressX property. Adding a level 0 log (critical error) resets the terminal. The format uses the same specifiers as the standard Lua string.format(). Syntax svc.log.addDebugf(sin, level, format, ...) Parameters sin The SIN of the service adding the log (16-255) level The debug log level (0-15) format String optionally containing format specifiers.The resulting string is truncated at 128 characters ... Zero or more arguments matching the format specifiers contained in the format argument. Blocking No Returns None 5.9.5.3 clearLogs() Description This function deletes all log files associated with the given log type. Syntax svc.log.clearLogs(logType) Parameters  logType  The log type to clear:  0  Data  1  Debug  2  Both  Blocking No Returns None 5.9.5.4 createFilter() Description This function creates a filter to be used for retrieving log entries. A maximum of 10 filters can be active at the same time. Syntax svc.log.createFilter(logType, config) Parameters logType The type of log for which to create a filter: 0 Data 1 Debug config A table containing the filter configuration; it supports the same fields as the setDataLogFilter or setDebugLogFilter2 messages, depending on the logType value Blocking No Returns handle A handle for invoking further log retrieval functions string A description of the error if handle is nil Example Create a filter for retrieving data log entries in forward order. local filter, err = svc.log.createFilter(0, {reverse = false}) if filter then É filter:close() else trace("Error creating filter: ", err) end Create a filter for retrieving CRITICAL and ERROR debug log entries with SIN 16 in reverse order, from sequence 10 to the end. local filter, err = svc.log.createFilter(1, {reverse = true, seqStart = 10, levels = 0x03}) 5.9.5.5 getUploadLogCount() Description This function returns the approximate number of log records remaining to be auto uploaded based on the current upload log filter specified by the logType value. Syntax svc.log.getUploadLogCount(logType) Parameters  logType  The log type to count:  0  Data  1  Debug  Blocking Yes Returns table Information about the matching entries, similar to the uploadDataLogCount or uploadDebugLogCount message fields, or nil upon error string A description of the error if the table is nil Example local result, err = svc.log.getUploadLogCount(0) if result then if result.matchingEntries >= 50 then É end else trace("Error obtaining count: ", err) end 5.9.5.6 setUploadFilter() Description This function sets an upload filter to be used for auto uploading of log entries. The filters, which can be set by this function, are the same filters that can be set by the setUploadDataLogFilter and the setUploadDebugLogFilter messages. The filter is saved to a file to ensure it is nonvolatile. Syntax svc.log.setUploadFilter(logType, config) Parameters  logType  The log type to create a filter for: 0 Data  config  1 Debug A table containing the filter configuration; it supports the same fields as the setUploadDataLogFilter or setUploadDebugLogFilter messages, depending on the logType value  Blocking No Returns boolean true if filter is set successfully, false otherwise string A description of the error if previous return parameter is false Example Update the filter for uploading data log entries in forward order, for specific MIN and MIN/SIN combinations, with an age limit of 24 hours. local success, err = svc.log.setUploadFilter(0, {reverse = false, list = {{sin=16}, {sin=21,minList=string.char(1,2,4)}, {sin=30,minList=string.char(3)}}, ageLimit=86400}) if not success then trace("Error updating filter: ", err) end Update the filter for uploading debug log entries in reverse order, for CRITICAL, ERROR, WARNING, and INFO entries in reverse order, with a maximum message size of 1000 bytes. local success, err = svc.log.setUploadFilter(1, {levels = 0xF, reverse = true, maxSize = 1000}) if not success then trace("Error updating filter: ", err) end 5.9.6 Handle Methods 5.9.6.1 close() Description This function closes the handle, freeing the associated resources. Syntax <handle>:close() Parameters None Blocking No Returns None 5.9.6.2 getCount() Description This function returns the number of remaining log entries that match the filter. Syntax <handle>:getCount() Parameters  None  Blocking Yes  Returns  table  Information about the mmatchingEntries firstEntrySeq firstEntryTime lastEntrySeq lastEntryTime firstEntryUploaded lastEntryUploaded  atching entries, similar to the dataLogCount message fields: The number of matching log records The sequence number of the first record The timestamp of the first record The sequence number of the last record The timestamp of the last record Indication that the first matching record has been auto uploaded Indication that the last matching record has been auto uploaded  5.9.6.3 getNext() Description This function returns the next log entry that matches the filter. Data log entries are returned in binary encoded format, so they need to subsequently be decoded. Syntax <handle>:getNext() Parameters None Blocking Yes Returns boolean true if at least one entry was found, false if none was found or the filter has been closed If the first return value is true, the remaining return values depend on the log type. For data logs: number The entry's sequence number number The entry's timestamp number The number of bits in the encoded binary message string The binary encoded message For debug logs: number  The entry's sequence number  number  The entry's timestamp  number  The log level  number  The log SIN  string  The debug log text  Example Process data log entries with a sequence number between 2 and 5. local filter, err = svc.log.createFilter(0, {reverse = false, seqStart = 2, seqEnd = 5}) if filter then repeat local res, seq, ts, bits, data = filter:getNext() if res then local err, msg, bits2 = svcmgr.decodeMsg(msgs.Direction.RETURN, data) --Process logged message here É end until not res filter:close() else trace("Error creating filter: ", err) end 5.9.7 Posted Events This service does not currently generate any events. 5.10 File System (SIN 24) The filesystem service provides an interface to the file system on the terminal. 5.10.1 Properties This service does not currently define any properties. 5.10.2 To-Mobile Messages 5.10.2.1 write (SIN 24, MIN 1) Name Type Optional Size Comments path String No ²255 bytes The full path name of the file to write offset Signed No 24 bits The offset within the file to write the data. A negative value can be used to append to the end of the file. If the offset is greater than the current file size, zeroes are added to fill the gap. flags Enum No 8 bits Describes how to carry out the operation. 0 Ð Normal Normal (if offset is not at the end of the file, the 1 Ð Overwrite operation is refused) 2 Ð Truncate Overwrite (if the offset is not at the end of the file, the operation proceeds) Truncate (if the offset is not at the end of the file, the content of the file after the offset is discarded and then the data is written) data Data No ²9700 bytes The file content to write 5.10.2.2 read (SIN 24, MIN 2) 5.10.2.3 dir (SIN 24, MIN 3) 5.10.2.4 stat (SIN 24, MIN 5) 5.10.3 From-Mobile Messages 5.10.3.1 writeResult (SIN 24, MIN 1) Name Type Optional Size Comments path The full path name of the file that was written to offset The actual offset in the file where the data was written flags The flags value specified in the request result Enum No 8 bits The result of the operation 0Ð OK 1 Ð InvalidPath 2 Ð CannotOverwrite 5.10.3.2 readResult (SIN 24, MIN 2) 5.10.3.3 dirResult (SIN 24, MIN 3) Name Type Optional Size Comments path The requested path entries If the path does not exist, this is an empty array. If the path point to a file, the array has one entry for the file itself. If the path points to a directory, the first entry in the array is for Ò.Ó, the directory itself. type Type of file object name The file or subdirectory name. size The file size (0 for directories). creationTime Signed No 32 bits The creation time of the file or directory, expressed as the number of seconds since the epoch. 5.10.3.4 statResult (SIN 24, MIN 4) Name Type Optional Size Comments path The requested path attributes A bitmap of the file attributes Bit 0 Ð Read-only Bit 1 Ð Hidden Bit 2 Ð System Bit 3 Ð Reserved Bit 4 Ð Directory Bit 5 Ð Archive size The file size (0 for directories). creationTime The creation time of the file or directory, expressed as the number of seconds since the epoch. MD5Hash Data No ²16 bytes The MD5 hash of the file (or 16 zeroes for directories). 5.10.4 Functions This service does not currently export any functions. The Lua I/O library can be used to access files. 5.10.5 Posted Events This service does not currently generate any events. 5.11 External Input/Output (EIO) (SIN 25) The eio (external input/output) service provides a mechanism to configure and interface with the terminal's I/O ports. The service provides functionality to: ¥ Read digital inputs and analog voltages or current ¥ Write single or pulsed values to digital outputs ¥ Generate events/alarms/messages on analog inputs that go out/in a configured range ¥ Generate events on rising/falling edges using the sample-based edge detector ¥ Count high speed digital pulses Standard Terminals The following table shows the supported external I/O hardware features: Table 4: External I/O Hardware Features OEM Terminals These devices are integrated at the board level so they do not have all the hardware features of a full terminal. Some of these differences are: ¥ No hardware input protection because they are connected directly to the terminalÕs processor. ¥ Only support 0 Ð 3.3V inputs ¥ Only support push-pull outputs Refer to the appropriate product hardware guide for details. The following table shows supported external I/O hardware features for OEM terminals: Table 5: External I/O Hardware Features (OEM Terminals) Port Analog Analog Digital Digital Push-pull Digital Open-drain Current Limited Extra Supported Input Current Input Output Output Open-drain Load Hardware 1 ST 6000 2 ST 6000 3 ST 6000 4 ST 6000 5 ST 6000 6 X X X X X X ST 6000 Ã Port Configuration The following table provides details on the different possible configurations. Table 6: Port Configuration Details Configuration Description Disabled Port is disabled and the hardware pin is configured as high impedance. Analog Port configured for analog voltage measurements in the range of 0 to 3300 milli-volts. This configuration uses the Ôport<N>AnalogXXXÕ properties. InputWeakPullDown Port configured as a digital input with a weak pull-down These modes support the use NOTE: In this configuration, the processor will latch the port to the last input of the edge value. For example, if a HIGH is present externally and is then disconnected, the detector pin will stay HIGH. This behavior is different than IDP terminals. InputPullUp Port configured as a digital input with a pull-up InputPullDown Port configured as a digital input with a pull-down OpenDrainOutputLow Port configured as open-drain output with an initial state of LOW (closed/grounded) OpenDrainOutputHigh Port configured as open-drain output with an initial state of HIGH (open) PushPullOutputLow Port configured as a push-pull output with an initial state of LOW (0 V) PushPullOutputHigh Port configured as a push-pull output with an initial state of HIGH (3.3 V) InputWeakPullDownPulse Same as ÔInputWeakPullDownÕ, with pulse counting enabled In pulse counting mode, NOTE: In this configuration, the processor will latch the port to the last input the edge value. For example, if a HIGH is present externally and is then disconnected, the detector is not pin will stay HIGH. This behavior is different than IDP terminals. used. InputPullUpPulse Same as ÔInputPullUpÕ, with pulse counting enabled InputPullDownPulse Same as ÔInputPullDownÕ, with pulse counting enabled AnalogCurrent Port configured to measure 4-20 mA current. The value is returned as milli-amperes X 10 so the range is 40 to 200. 5.11.1 Properties PIN Name Description Type Storage Default Class Value 182 port10AnalogSampleFilter Number of consecutive samples Unsigned Config 1 needed in a new state before Minimum Ð 1 declaring an alarm. Maximum Ð 255 185 port10Value The current port 10 value, whether Unsigned Config 0 analog or digital. Minimum Ð 0 Maximum Ð 5000 5.11.2 To-Mobile Messages 5.11.2.1 readPort (SIN 25, MIN 1) Note: The ST 6000 has two additional ports; ports 5 and 6. Name  Type  Optional  Size  Comments  port  Unsigned  No  5 bits  The port number.  1 Ð General-purpose I/O port 1  2 Ð General-purpose I/O port 2  3 Ð General-purpose I/O port 3  4 Ð General-purpose I/O port 4  5 Ð Output only I/O port 5 (ST 6000 OEM and ST 9100)  6 Ð Output only I/O port 6 (ST 6000 OEM and ST 9100)  7 Ð Input/Current port 7 (ST 9100)  8 Ð Input/Current port 8 (ST 9100)  9 Ð Input port 9 (ST 9100)  10 Ð Input port 10 (ST 9100)  30 Ð Temperature analog input  31 Ð Input power analog input  All other values are reserved  5.11.2.2 writePort (SIN 25, MIN 2) 5.11.2.3 pulsePort (SIN 25, MIN 3) NameTypeOptionalSizeCommentsportUnsignedNo5bitsTheportnumber.Seesection1.1.2.1forpossiblevaluesdurationUnsignedNo16bitsThenumberofmillisecondstokeeptheoutputportinverted,beforechangingitbacktoitsoriginalstate5.11.3 From-Mobile Messages MINNameDescription1portValueThecurrentvalueofaport2portAlarmAnalarmforaportstatechange5.11.3.1 portValue (SIN 25, MIN 1) 5.11.3.2 portAlarm (SIN 25, MIN 2) Name  Type  Optional  Size  Comments  port  Unsigned  No  5 bits  The port number. See section 1.1.2.1 for possible values  value  Signed  No  16 bits  The current port value  type  Enum  Yes  2 bits  The alarm type, only for analog alarms:  0 Ð BelowRange  BelowRange (below the low threshold)  1 Ð InRange  InRange (between the high and low thresholds)  2 Ð AboveRange  AboveRange (above the high threshold)  5.11.4 Functions 5.11.4.1 getPulseCount Description This command queries the current pulse count for the specified port. It also clears the pulse counter if the boolean parameter is enabled. This function guaranties atomicity of the clear operation in order to report every pulse. To clear the current pulse count, set the clear parameter to true. Syntax svc.eio.getPulseCount(port, clear) Parameters port The port number. clear The clear flag. Blocking No Returns  pulseCnt  Current pulse count; nil in the case of a failure/overflow  msClear  Milliseconds since last counter clear operation; nil in the case of a failure  errStr  In the case of a failure, a description of the error  Example --Getting the pulse count local pulseCnt, msClear, errMsg = svc.eio.getPulseCount(1, true) if (pulseCnt) then --success print(ÒPulse count: Ò..pulseCnt..Ó period(ms): Ò..msClear..Ó\nÓ) else --failed print(errMsg) end 5.11.4.2 pulsePort() Description Temporarily change the state of an output port. Syntax svc.eio.pulsePort(port, duration) Parameters port The port number to read from; see section 1.1.2.1 for possible values duration The number of milliseconds to keep the output port inverted, before changing it back to its original state Blocking No Returns string A description of the error in the case of a failure; nil otherwise 5.11.4.3 readPort() Description Returns the current value of the given port. Syntax svc.eio.readPort(port) Parameters port The port number to read from; see section 1.1.2.1 for possible values Blocking No (except for temperature) Returns number The current port value or nil on error string An error message if the previous value is nil 5.11.4.4 writePort() Description Sets a new output value for an appropriately-configured port. Syntax svc.eio.writePort(port, val) Parameters  port val  The port number to read from; see section 1.1.2.1 for possible values The new output value (0 or 1)  Blocking No  Returns  string  Nil is success, or an error message if the command failed.  5.11.5 Posted Events 5.11.5.1 Analog Alarm Description This event is posted every time an analog alarm is triggered. Source svc.eio (eio service table) Event ÒANALOG_ALARMÓ (string) Arguments table The alarm message, which is a table containing the following fields: port  The port that caused the alarm  value  The current port value  type  The alarm type:  0  Below range (below the low threshold)  1  In range (between the high and low thresholds)  2  Above range (above the high threshold)  5.11.5.2 Digital Alarm  Description  This event is posted every time a digital alarm is triggered. Source svc.eio (eio service table) Event ÒDIGITAL_ALARMÓ (string) Arguments table The alarm message which is a table containing the following fields: port The port that caused the alarm value The current port value 5.11.5.3 Pulse Counter Report Description This event sends to the user application a list containing the last pulse counter sampling values with the exact sampling interval in milliseconds. The number of samples is defined by the report multiplier property. The frequency of the report is defined by the sampling interval multiplied by the report multiplier. Source Event sent by Ò_EIOPULSEÓ from the terminalÕs EIO Lua external API. Event ÒFULL_REPORTÓ (string) Arguments table A table containing the following fields: port The I/O port number timestamp System uptime with millisecond accuracy samples Table containing the pulse counter samples [multiplier] number Number of the sample pulseCount Number of pulses counted msInterval Milliseconds since last counter reset state BelowRange, InRange, or AboveRange 5.11.5.4 Pulse Counter Threshold Description This event notifies the application that the sampling interval crossed a user specified threshold. This report is identical to the FULL_REPORT event but only contains a single sample, responsible for the threshold crossing. Source Event sent by Ò_EIOPULSEÓ, from the terminalÕs EIO Lua external API. Event ÒTHRESHOLD_CROSSINGÓ (string) Arguments table A table containing the following fields: port  The I/O port number  timestamp  System uptime with millisecond accuracy  samples[1]  Table containing the pulse counter samples  number  Correspond to the sample index of the pulse counter report event  pulseCount  Number of pulses counted  msInterval  Milliseconds since the last counter reset  state  BelowRange, InRange or AboveRange  5.12 Shell (SIN 26) The shell service provides a command-line interface (CLI) over the RS-232 port. It also provides the ability to execute the same commands over-the-air. An execution timeout limits how long noninteractive shell commands can execute. For details on system provided shell commands and their usage, see T404. 5.12.1 Properties 5.12.2 To-Mobile Messages 5.12.2.1 executeCmd (SIN 26, MIN 1) This message fails if the over-the-air access level is below the individual shell command's level (the command's options level parameter) and a password exists for the shell command's level [T404]. 5.12.2.2 executeLua (SIN 26, MIN 2) This message fails if the over-the-air access level is 0 and a level 1 password exists [T204]. 5.12.2.3 executePrivilegedCmd (SIN 26, MIN 3) This message generates an error if the specified level is greater than MAX_OTA_LEVEL. 5.12.2.4 executePrivilegedLua (SIN 26, MIN 4) This message generates an error if the specified level is greater than MAX_OTA_LEVEL. 5.12.2.5 getAccessInfo (SIN 26, MIN 5) This message does not contain any fields. An accessInfo message is generated in response. 5.12.2.6 setAccessLevel (SIN 26, MIN 6) This message generates an error if the specified level is greater than MAX_OTA_LEVEL. 5.12.2.7 changeAccessPassword (SIN 26, MIN 7) This message generates an error for all levels other than 1. 5.12.3 From-Mobile Messages 5.12.3.1 cmdResult (SIN 26, MIN 1) Sent in response to to-mobile messages 1 to 4. 5.12.3.2 accessInfo (SIN 26, MIN 2) 5.12.3.3 accessSetChangeResult (SIN 26, MIN 3) 5.12.4 Functions 5.12.4.1 attach() Description Attach the shell CLI to the RS-232 interface. Does nothing if the shell CLI is already attached. Syntax svc.shell.attach() Parameters None Blocking No Returns None 5.12.4.2 detach() Description Detaches the shell CLI and releases the connection to the RS-232 interface. Syntax svc.shell.detach() Parameters None Blocking No Returns None 5.12.4.3 executeCmd() Description Executes a shell command, and returns its output. Syntax svc.shell.executeCmd(cmd) Parameters cmd The shell command to run Blocking Yes Returns boolean Indicates success or failure string The command output 5.12.4.4 register() Description Register a command with the shell. If the command already exists, register() fails. Syntax svc.shell.register (name, handler, description, options) Parameters name The name of the command handler A handler function to invoke description A description of the command options Optional table that might contain any of the following options: hidden Boolean flag to not display the command in the help level  The access required to execute the command if the corresponding password has been defined (integer 0 to 3)  locked  Boolean to indicate that the command cannot be changed or unregistered from the shell  interactive  The command requires interactive serial input, so cannot be used as an over-the-air command (Boolean)  Blocking No Returns boolean true if the operation was successful, false otherwise Note: Once the command is executed, the handler functions will be passed two parameters. The first is a table containing an array of the commandÕs arguments, and the second is a number containing the current access level. Note: Registration of shell commands do not survive an LSF restart. Any registered shell commands will not persist across a stop start, stop reset, power cycle. Typically, shell commands associated with a (core or user) service are registered by the service each time the service starts. 5.12.4.5 unregister() Description Unregister a command from the shell, returning the handler, descriptions and options for later reregistering of the command. Syntax svc.shell.unregister (name) Parameters name The name of the command Blocking No Returns function The handler function of the unregistered command or nil if the command was not found description A description of the command table A table containing the command options, if any. Refer to options parameter of register() for further details. 5.12.5 Posted Events This service does not currently generate any events. 5.13 IDP (SIN 27) The idp service provides access to some of the functionality offered by the IsatData Pro modem. 5.13.1 Properties Description Type Storage Class Default Value 1 model Model string from the String Volatile ÒunknownÓ modem. 2 firmwareRevision Firmware revision of the String Volatile ÒunknownÓ modem 3 mobileID Terminal serial number String Volatile ÒunknownÓ identification 4 networkID Unique network identification Unsigned Volatile 0 number Min. Ð 0 Max. Ð 2147483647 5 hardwareRevision Hardware revision of the String Volatile ÒunknownÓ modem 6 protocolVersion The protocol version of the Unsigned Volatile 0 AT interface Min. Ð 0 Max. Ð 2147483647 9 reserved --.10 powerMode The modem's main power Enum Config MobilePowered operating mode 0 Ð MobilePowered 1 Ð FixedPowered 2 Ð MobileBattery 3 Ð FixedBattery 4 Ð MobileMinBattery 5 Ð MobileParked All other values are reserved 11 wakeUpInterval1 The interval between modem Enum Volatile2 5_seconds wake ups for receiving 0 Ð 5_seconds messages. Valid values 1 Ð 30_seconds differ depending on the 2 Ð 1_minute firmware release. Values not 3 Ð 3_minutes supported are rejected. 4 Ð 10_minutes 5 Ð 30_minutes 6 Ð 60_minutes 7 Ð 2_minutes 8 Ð 5_minutes 9 Ð 15_minutes 10 Ð 20_minutes 1The valid values for this property depend on the modem firmware version. Firmware versions prior to 3.0.x only support options 0, 3, 4, 5 and 6. All other values are rejected. 2New values are saved to the modem's nonvolatile memory. 5.13.2 To-Mobile Messages The following messages allow fairly low-level access to the modem. Refer to [T403] for additional details. 5.13.2.1 getSReg (SIN 27, MIN 1) 5.13.2.2 setSreg (SIN 27, MIN 2) 5.13.2.3 getMetrics (SIN 27, MIN 3) 5.13.2.4 getMetrics2 (SIN 27, MIN 4) 5.13.3 From-Mobile Messages The following messages return fairly low-level data from the modem. 5.13.3.1 getSRegResult (SIN 27, MIN 1) 5.13.3.2 setSRegResult (SIN 27, MIN 2) 5.13.3.3 metricsResult (SIN 27, MIN 3) Name Type Optional Size Comments Network ID Unsigned No 28 bits Refer to [T404] for details timestamp Unsigned No 18 bits class Unsigned No 3 bits subclass Unsigned No 5 bits priority Unsigned No 2 bits metrics Array No ²32 elements An array of all metrics for the block value Signed No 32 bits An individual metric value 5.13.3.4 metricsResult2 (SIN 27, MIN 4) Name Type Optional Size Comments Network ID Unsigned No 28 bits Refer to [T404] for details timestamp Unsigned No 31 bits class Unsigned No 3 bits subclass Unsigned No 5 bits priority Unsigned No 2 bits metrics Array No ²32 elements An array of all metrics for the block value Signed No 32 bits An individual metric value 5.13.4 Constants The idp service defines the following constants. 5.13.4.1 TRANSPORT_ID Description This is the transport number used in the message service to have messages go over the satellite transport. It has the value 1. Syntax svc.idp.TRANSPORT_ID 5.13.5 Functions 5.13.5.1 eventDeregister() Description This function deregisters an application from receiving event updates. Syntax svc.idp.eventDeregister(handle) Parameters handle The handle returned by the call to eventRegister() Blocking No Returns None 5.13.5.2 eventRegister() Description This function registers an application to receive notifications when any number of events is updated. An event is sent immediately after registration with current data at the time of registration; this is to give the application a set of baseline data, not to notify that an event has been updated. Syntax svc.idp.eventRegister(list) Parameters list An array of {class, subclass} pairs Blocking No Returns handle A handle used to deregister, and in the generated events Example Register to receive updates for class 3, subclass 1, and class 4, subclass 1 local handle = svc.idp.eventRegister({{3, 1}, {4, 1}}) 5.13.5.3 getMetrics() Description Returns a block of modem metrics. Syntax svc.idp.getMetrics(class, subclass) Parameters class The class of the desired metrics block subclass The subclass of the desired metrics block Blocking Yes Returns table A table with the following fields, or nil when the metrics are not available for the class/subclass: MTID The forward link ID of the modem, in the range 1 -16777215 timestamp The event timestamp assigned by the modem dateTime The date and time as a string (YYY-MM-DD HH:MM:SS); this is only available in firmware version 4.1 and higher class The event class subclass The event subclass priority The event priority: 1 Ð Critical 2 Ð Major 3 Ð Minor 4 Ð Information metrics An array of tables, each containing the following fields: value The individual metric value (refer to [T404] for details) 5.13.5.4 getNetworkId() Description Returns the modem's network ID. Syntax svc.idp.getNetworkId() Parameters None Blocking No Returns number The modem's network ID 5.13.5.5 getProtocolRevision() Description Returns the modemÕs protocol revision number. Syntax svc.idp.getProtocolRevision() Parameters None Blocking No Returns number The modemÕs protocol revision number 5.13.5.6 getSRegVal() Description Returns an S register value. Some S registers are not accessible, and always returns nil (0, 3-8, 10, 39-41, 50-51, 55-57, 60-64, 80-81, 85, 88-123). Syntax svc.idp.getSRegVal(reg) Parameters reg The S register number (0-255) Blocking Yes Returns number The S register value, or nil for inaccessible S registers. 5.13.5.7 getTemp() Description Returns the modem's temperature. Syntax svc.idp.getTemp() Parameters None Blocking Yes Returns number The modem's temperature 5.13.5.8 gps() Description Requests the GPS fix from the modem. Syntax svc.idp.gps(fixType, keys, age, timeout, callback,É) Parameters fixType The desired fix type 2D or 3D keys An array of the desired NMEA keys (GGA, RMC, GSA and GSV are supported) age Indicates how old of a fix the caller is willing to accept, in seconds (no minimum or maximum) timeout Indicates how long the caller is willing to wait, in seconds (no minimum or maximum) callback The callback function; it is called with an array of NMEA sentences (strings) and any extra arguments; this function must not block É Any extra arguments to be passed to the call to callback Blocking Yes Returns None 5.13.5.9 reset() Description This function resets the modem. Syntax svc.idp.reset(flush, now) Parameters flush Optional Boolean to flush the internal request queue now Optional Boolean to force an immediate hard reset This option has the possibility of corrupting flash on the modem. Blocking Yes Returns None 5.13.5.10 setSRegVal() Description Sets an S register value. Some S registers are not accessible (0, 3-8, 10, 39-41, 50-51, 55-57, 60-64, 80-81, 85, 88-123). Syntax svc.idp.setSRegVal(reg, val) Parameters  reg  The S register number (0-255)  val  The S register value  Blocking Yes Returns None 5.13.5.11 strFlags() Description This function returns a table of strings, with each entry containing the description of a set bit in the given flag mask. Syntax svc.idp.strFlags()(mask) Parameters mask The satellite flags bitmask Blocking No Returns table A list of set flag bit descriptions Example Print the description of all currently set bits in the setFlags property, one per line. local temp = svc.idp.strFlags(svc.idp.properties.satFlags) for i = 1, #temp do print (temp [i]) end 5.13.6 Posted Events 5.13.6.1 Event Update Description This event is posted whenever a registered event is updated. This event can return multiple records. Source <handle> (then handle returned by the call to eventRegister) Event ÒEVENT_UPDATEÓ (string) Arguments table An array of event update records. table Each record is an array of the event-specific fields, plus the following named common fields: dateTime The date and time as a string (YYY-MM-DD HH:MM:SS); this is only available in firmware version 4.1 and higher MTID The forward link ID of the modem, in the range 1 -16777215 subclass The event subclass timestamp The event timestamp assigned by the modem. priority The event priority: 1 Ð Critical 2 Ð Major 3 Ð Minor 4 Ð Information class The event class metrics An array of tables, each containing the following fields: value The individual metric value (refer to [T404] for details) 5.13.6.2 GPS Jamming Description This event is posted when the GPS jamming status changes. Source svc.idp (idp service table) Event ÒJAMMING_UPDATEÓ (string) Arguments table An array with the following fields number  The jamming status:  0 Ð Unknown  1 Ð OK (no significant jamming)  2 Ð Warning (interference visible, but fix OK)  3 Ð Critical (interference visible and no fix)  boolean  Indicates whether or not jamming is detected  number  The raw jamming indicator value for the hardware  5.13.6.3 Modem Comms  Reserved  5.13.6.4 Modem Registered  Reserved  5.13.6.5 Modem Reset Description This event is posted when a reset indication is received from the modem. Source svc.idp (idp service table) Event ÒMODEM_EVENT_RESETÓ (string) Arguments None 5.13.6.6 Satellite Status Change Description Available on satellite-cellular terminals. This event is posted when the value of either the satState or satFlags property changes. Source svc.idp (idp service table) Event ÒSAT_STATUSÓ (string) Arguments args A table containing the following fields satState The value of the satState property satStateNum The numeriv value of the satState property satFlags The value of the satFlags property 5.13.6.7 Wake Up Interval Change Description This event is posted when the modemÕs wake-up interval changes. On changing the property value, the new setting takes a while to take effect; this event is sent after the new value is fully applied. Source svc.idp (idp service table) Event ÒMODEM_EVENT_INTERVAL_CHANGEÓ (string) Arguments table An array with the following fields: wakeUpInterval The new string wakeUpInterval value wakeUpIntervalNum The new numerical wakeUpInterval value 0 Ð 5_seconds 1 Ð 30_seconds 2 Ð 1_minute 3 Ð 3_minutes 4 Ð 10_minutes 5 Ð 30_minutes 6 Ð 60_minutes 7 Ð 2_minutes 8 Ð 5_minutes 9 Ð 15_minutes 10 Ð 20_minutes 5.14 Reserved (SIN 28) 5.15 Cell (SIN 29) This service is only available on satellite-cellular terminals and some of these terminals do not support all the PINs shown in the properties table. The cell service provides support for JSON encoding of messages, allows configuration and monitoring of the module; and also provides a plugin to the message service allowing it to send/receive messages over cellular. 5.15.1 Properties PIN Name Description Type Storage Default Value Class 1 sim1PIN The Personal Identification Number String Config ÒÓ (PIN) to authenticate the first SIM. Must Maximum Ð 8 be a 4 to 8 character alphanumeric value. This property is ignored if no PIN is required. 2 sim1APN The Access Point Name (APN) used to String Config ÒorbcommÓ connect to an IP network using the first Maximum Ð 100 SIM. 3 sim1Username The username required to connect to String Config ÒÓ an IP network using the first SIM (if Maximum Ð 32 any). 4 sim1Password The password required to connect to an String Config "" IP network using the first SIM (if any). Maximum Ð 32 5 sim1DNS1 The first DNS address used on the first String Config "" SIM. Leaving this string empty uses the Maximum Ð 15 dynamically assigned IP address, if any. 1sim1PIN (PIN 1), sim2PIN (PIN 8), and sim3PIN (PIN 51) are used to unlock the SIM on startup and on each subsequent SIM switch, they are used only once, without retries. PIN Name Description Type Storage Default Value Class 51 ÒÓ 52 ÒÓ 53 ÒÓ 54 ÒÓ 55 ÒÓ 56 ÒÓ 57 1 60 targetMode This property controls whether the Enum Config 4 module operates on 2G, 3G and /or LTE. 0Ð 2G 1 Ð Both 1 2Ð 3G 3 Ð LTE 4 Ð 2G_3G_LTE 5 Ð 2G_LTE 6 Ð 3G_LTE 1Both implies 2G and 3G. PIN Name Description Type Storage Default Value Class 61 currentMode Indicates the mode the module is Volatile None currently operating in. Only valid for 3G modules. 62 tcpRetryTimeout This property controls how long (in Config 3 seconds) the TCP stack waits for an acknowledgment before retransmitting a packet. 63 dbgLevel Controls the generation of extra Unsigned Config 0 debugging information. 0 Ð Extra debugging off All other values extra debugging on 64 sim1Present Reports whether a SIM card is currently Boolean Volatile false present in slot 1. 65 sim2Present Reports whether a SIM card is currently Boolean Volatile false present in slot 2. 66 sim3Present Reports whether a SIM card is currently Boolean Volatile false present in slot 3 (external). 67-82 Reserved ----Unsigned Minimum Ð 1 Maximum Ð 60 5.15.1.1 SIM Selection The ST 9100 has three SIMs available; two internal (eSIM) and one external that uses the microSIM format. The cellular service provides two mechanisms to allow user services to control which SIM card should be used at any given point in time. The first is the simSwitch() function. When given an argument (1 or 2 or 3), this function switches to the specified SIM; otherwise it simply switches to the currently inactive SIM. The second mechanism is via the activeSim property (SIM 29, PIN 14). Writing to this property causes the indicated SIM card to be used. Reading this property also allows the currently active SIM to be checked. Saving the property value allows a user to see the default SIM that comes up as active after a framework restart. The terminal SIM hardware allows you to physically detect the presence of SIM cards in the slots. The simXPresent properties contain the information and can be consulted prior to attempting a switch. Finally, the NETWORK_STATUS event allows a user service to receive instant notification when the network status changes, so that it can switch SIM cards in a timely manner if needed. 5.15.1.2 Network Lists The terminal can maintain up to four lists to help determine which networks it can and cannot use; two for each SIM. The first type is the white list, which explicitly specifies all the approved networks. The second type is the black list, which specifies networks on which roaming must not be allowed. The files are stored in /data/svc/cell/, and are named SIM1WhiteList.lua, SIM1BlackList.lua, SIM2WhiteList.lua, SIM2BlackList.lua, SIM3WhiteList.lua, and SIM3BlackList.lua. They contain Lua code, with one entry per line, where each entry has the format shown below. ListEntry(mcc, mnc) Anytime a change of network is detected by the module, the following checks take place: ¥ If a white list is present, the network is allowed only if it is present in the list ¥ If a white list is not present, but a black list is, the network is allowed only if it is not present in the list ¥ If neither list if present, then the network is allowed If the network is not allowed, then no transmit of receive operations are performed, until the module switches to another network. 5.15.1.3 RSSI To convert from the rssi property value to dBm, the formula is dBm = -113 + 2 * value. For example, an rssi property value of 15 translates to -113 + 2 * 15 = -83 dBm. 5.15.2 To-Mobile Messages The following messages allow fairly low level access to the modem. Refer to [T404] for additional details. 5.15.2.1 listOperation (SIN 29, MIN 1) -Deprecated Use listOperation2. Comments Selects which list to modify. Select the operation to perform. The Mobile Country Code of the entry to add/delete. The Mobile Network Code of the entry to add/delete. A value of 0 means it matches all MNCs for the specified MCC. 5.15.2.2 getLists (SIN 29, MIN 2) This message does not contain any fields. 5.15.2.3 listOperation2 (SIN 29, MIN 5) Name Type Optional Size Comments sim Enum The SIM to which the operation applies. 0 Ð SIM1 1 Ð SIM2 2 Ð SIM3 3 Ð Reserved list Enum Selects which list to modify. 0 Ð WhiteList 1 Ð BlackList operation Enum Select the operation to perform. 0 Ð Add 1 Ð Delete mcc Unsigned The Mobile Country Code of the entry to add/delete. mnc Unsigned No 10 bits The Mobile Network Code of the entry to add/delete. A value of 0 means it matches all MNCs for the specified MCC. 5.15.3 From-Mobile Messages 5.15.3.1 operationResult (SIN 29, MIN 1) Name Type Comments list Selects which list to modify Select the operation to perform mcc The Mobile Country Code of the entry to add/delete mnc The Mobile Network Code of the entry to add/delete success Boolean No n/a Whether the operation was successful or not 5.15.3.2 lists (SIN 29, MIN 2) 5.15.3.3 operationResult2 (SIN 29, MIN 5) 5.15.4 Constants The cell service defines the following constants. 5.15.4.1 DataFormat Description This table contains a mapping of the SMS data format values to their numerical value: Ascii  0  AsciiHex  1  Syntax  svc.cell.DataFormat 5.15.4.2 DataFormatStr Description This table contains a mapping of the SMS data format values to their string representation: 0 Ascii 1 AsciiHex Syntax svc.cell.DataFormatStr 5.15.4.3 LinkStability Description This table contains a mapping of the Link Stability values to their numerical value: Normal 0 EarlyWarning 1 Interference 2 Jamming 3 Syntax svc.cell.LinkStability 5.15.4.4 LinkStabilityStr Description This table contains a mapping of the Link Stability numerical values to their string representation: 0  Normal  1  EarlyWarning  2  Interference  3  Jamming  Syntax  svc.cell.LinkStabilityStr 5.15.4.5 ListOp Description This table maps list operations to their numerical values. It has the following fields: Add 0 Delete 1 Syntax svc.cell.ListOp 5.15.4.6 ListOpStr Description This table does the reverse of ListOp. It maps numerical values to the string value. It has the following fields: 0 Add 1 Delete Syntax svc.cell.ListOpStr 5.15.4.7 ListType Description This table maps list types to their numerical values. It has the following fields: WhiteList 0 BlackList 1 Syntax svc.cell.ListType 5.15.4.8 ListTypeStr Description This table does the reverse of ListType. It maps numerical values to the string value. It has the following fields: 0  WhiteList  1  BlackList  Syntax  svc.cell.ListTypeStr 5.15.4.9 NetDescription This table contains a mapping of the Link Stability numerical values to their string representation: 0 Normal 1 EarlyWarning 2 Interference 3 Jamming Syntax svc.cell.LinkStabilityStr 5.15.4.10 Status Description This table contains a mapping of the NetStatus values to their numerical value: Unknown 0 NotRegistered 1 RegistrationDenied 2 Home 3 Roaming 4 Syntax svc.cell.NetStatus 5.15.4.11 NetStatusStr Description This table contains a mapping of the NetStatus numerical values to their string representation: 0 Unknown 1 NotRegistered 2 RegistrationDenied 3  Home  4  Roaming  Syntax  svc.cell.NetStatusStr 5.15.4.12 SimStatus Description This table contains a mapping of the SimStatus values to their numerical value: Unknown 0 Missing 1 Error 2 Inserted 3 Syntax svc.cell.SimStatus 5.15.4.13 SimStatusStr Description This table contains a mapping of the SimStatus numerical values to their string representation: 0 Unknown 1 Missing 2 Error 3 Inserted Syntax svc.cell.SimStatusStr 5.15.4.14 WhichList Description This table contains a mapping of the whichList values to their numerical value: None 0 WhiteList 1 BlackList 2 Syntax svc.cell.WhichList 5.15.4.15 WhichListStr Description This table contains a mapping of the whichList numerical values to their string representation: 0  None  1  WhiteList  2  BlackList  Syntax  svc.cell.WhichListStr 5.15.5 Functions 5.15.5.1 Get White/Black List Description Retrieves the contents of the white or black list for a particular SIM. Syntax svc.cell.getList(sim, type) Parameters sim The SIM number (1, 2, or 3) type A number or string indicating the type of list (see ListType and ListTypeStr) Blocking No Returns table An array of list entries, with each entry a table that contains two fields, or nil in the case of error. mcc -The Mobile Country Code mnc -The Mobile Network Code string An error message or nil 5.15.5.2 simSwitch() Description Switches the currently active SIM to the specified on. Syntax svc.cell.simSwitch(which) Parameters which  The SIM card to switch to 1 2, or 3 selects that SIM, and nil switches to the currently inactive one  Blocking No  Returns boolean  false if which is not 1, 2, 3, or nil; true otherwise  5.15.5.3 Send SMS Message Description Send an SMS message. Syntax svc.cell.sendSmsMsg(destAddr, data, dataFormat) Parameters destAddr A string containing the destination address (typically a telephone number) data A string containing the data dataFormat (optional) A number indicating the data format (section 5.15.4.1). DataFormat, ASCII is assumed if absent. Blocking No Returns boolean Indicates success or failure string In the case of failure, a description of the error 5.15.5.4 White/Black List Operation Description Adds or removes a network from the white or black list for a particular SIM. Syntax svc.cell.listOp(sim, type, op, mcc, mnc) Parameters sim The SIM number (1, 2, or 3) type A number or string indicating the type of list (see ListType and ListTypeStr) op A number or string indicating the operation (see ListOp and ) mcc The Mobile Country Code. mnc The Mobile Network Code. A value of 0 means it matches all MNCÕs for the specified MCC. Blocking No Returns boolean Indicates success or failure string In the case of failure, a description of the error 5.15.6 Posted Events 5.15.6.1 Antenna Cut Description This event applies to cellular terminals. Source svc.cell (cell service table) Event ÒANTENNA_CUTÓ (string) Arguments boolean Indicates whether or not an antenna cut has been detected 5.15.6.2 APN Connected Description Posted when the APNConnected property (PIN 18) value changes. Source svc.cell (cell service table) Event ÒAPN_CONNECTEDÓ (string) Arguments boolean Whether the module is currently connected to the APN 5.15.6.3 IP Ready Description This event is posted when the IP readiness of the module changed. It is able to carry out IP operations when the argument value is true. Source svc.cell (cell service table) Event ÒIP_READYÓ (string) Arguments boolean Whether or not the module is able to carry out IP operations 5.15.6.4 Link Status Description Posted when the current link status changes. Source svc.cell (cell service table) Event ÒLINK_STATUSÓ (string) Arguments  table  A table containing the following fields:  status  The current link status, as defined by linkStability (SIN 29, PIN 33)  mode  2G (GPRS) if jamming as detected on 2G channels, 3G (HSPA) if jamming was detected on 3G channels, or nil if jamming is no longer present  5.15.6.5 Network Status Description Posted when the current network status changes. Source svc.cell (cell service table) Event ÒNETWORK_STATUSÓ (string) Arguments table The message, which is a table containing the following fields: activeSim The currently active SIM (1, 2, or 3) oldStatus The previous network status, which is one of: svc.cell.NetStatus.Unknown(0) svc.cell.NetStatus.NotRegistered(1) svc.cell.NetStatus.RegistrationDenied(2) svc.cell.NetStatus.Home(3) svc.cell.NetStatus.Roaming(4) newStatus The current network status oldMcc The previous Mobile Country Code newMcc The current Mobile Country Code oldMnc The previous Mobile Network Code newMnc The current Mobile Network Code networkAllowed A Boolean to indicate whether the current is allowed or not APNConnected A Boolean to indicate whether the terminal is connected to the APN or not whichList Indicates which list caused the network to be allowed or disallowed, which is one of: svc.cell.WhichList.None (0) svc.cell.WhichList.WhiteList (1) svc.cell.WhichList.BlackList (2) 5.15.6.6 Power Status Description Posted when the power to the module is turned on or off. When the power is off, the simStatus and networkStatus properties are reset to Unknown (0). Source svc.cell (cell service table) Event ÒPOWER_STATUSÓ (string) Arguments boolean Indicates whether or not the power is on 5.15.6.7 SIM Presence Description One of these events is posted when the sim1Present, sim2Present, or sim3Present property changes value. Source svc.cell (cell service table) Event  ÒSIM1_PRESENTÓ Or  (string)  ÒSIM2_PRESENTÓ Or  (string)  ÒSIM3_PRESENTÓ  (string)  Arguments  boolean Indicates whether the corresponding SIM is currently present 5.15.6.8 SIM Status Description Posted when the SIM card status changes. Source svc.cell (cell service table) Event ÒSIM_STATUSÓ (string) Arguments number The current SIM status, which is one of: svc.cell.SimStatus.Unknown(0) svc.cell.SimStatus.Missing(1) svc.cell.SimStatus.Error(2) svc.cell.SimStatus.Inserted(3) 5.15.6.9 SMS Message Received Description This event is posted when an SMS message is received. A concatenated SMS message received by the terminal is presented as multiple individual received SMS messages. Source svc.cell (cell service table) Event ÒSMS_MESSAGE_RXDÓ (string) Arguments table A table containing the following fields: origAddr A string containing the originator address (telephone number) smscAddr A string containing the SMSC address dcs A number representing the data coding scheme reported by the cellular modem, as defined by 3G TS 23.038: 0 -3 Ð ÒDefault alphabetÓ (7 bit) 4 Ð Ò8 bit dataÓ 8 Ð ÒUCS2Ó (16 bit) acsiiData An ASCII string representation of the received message data acsiiHexData An ASCII-Hex representation of the received message data rawHexData A Hex representation of the received message data corresponding to dcs scTs A string containing the SMSC timestamp When dcs indicates 16 bit data, the MS bytes (with value 0x00) will be removed from acsiiHexData and asciiData, and characters with MS bytes with value other than 0x00 will be converted to Ô?Õ. For example,. if rawHexData = Ò00480069263A00310032Ó, then acsiiHexData will be Ò48693F3132Ó acsiiData will be ÒHi?12Ó. 5.16 Reserved (SIN 30) 5.17 Reserved (SIN 31) 5.18 Campaign (SIN 32) The campaign service is a mandatory service that must be running to support software over-the-air updates. The Software Over-the-Air (SOTA) feature uses the campaign service to receive and apply software or firmware updates. For more information on SOTA and campaigns see [N207], which explains terms such as activate, commit, and revert. Note: When updating a user service, the svclist.lua file is updated in its entirety. This means that you cannot update a single user service. The update package includes all user services. Note: This service can only be enabled and disabled. All associated properties are reserved for ORBCOMM use only. 5.18.1 Terminal Campaign States Individual terminals progress through a series of states. Figure 2: Terminal Campaign States Table 7 summarizes the different sates that a campaign can be in at any given moment, as well as the supported state transitions and their triggers. Table 7: Terminal Campaign States Description From State To State Trigger N/A Receive a start message or an event to start a campaign for a previously nonexistent campaign. Starting The current protocol revision is sufficient to carry out the request, and file system space is successfully reserved. Starting The current protocol revision is not sufficient to carry out the request, or file system space is not successfully reserved, or upon receiving a stop message or command. Loading All fragments received, and file passes integrity validation. Loading All fragments received, and file does not pass integrity validation, or upon receiving a stop message or command. Loading A pause operation message is received. Paused A resume operation message is received. Paused An FTP/HTTP transfer that was active prior to being paused completes, and the file passes validation. Validated Immediately after file is completed if the activate flag in the request was set to true, or upon receiving an activation message or command, and the activation process completes successfully. Validated Immediately after file is completed if the activate flag in the request was set to true, or upon receiving an activation message or command, and the activation process does not complete successfully Activated Upon receiving a revert message or command. Activated Committed Upon receiving a commit message or command 5.18.2 Properties 5.18.3 To-Mobile Messages There are no to-mobile messages defined for this service. 5.18.4 From-Mobile Messages There are no from-mobile messages defined for this service. 5.18.5 Functions This service does not export any functions. 5.18.6 Posted Events This service does not generate any events. 5.19 Internet Protocol (ip) (SIN 33) The ip service allows terminals to take advantage of protocols and their associated features available on the internet for the development of IP enabled Lua applications. This service is mandatory on cellular services and cannot be disabled. The protocols for this service include FTP, TCP, HTTP and UDP. Internet protocol support is available over both satellite IsatData Pro transport and Cellular/GSM. Basic SMTP support over satellite is also available. MTWS protocol is a web service interface using a JSON encoding and REST architectural style. The MTWS protocol is defined in [N206]. 5.19.1 Supported Functionality The ip service supports various functionalities with some requirements as specified in this section. 5.19.1.1 FTP The ip service supports FTP functionality with the following requirements: ¥ A remote URL indicating the server ¥ A path ¥ A file name ¥ A successfully allocated channel to store and receive FTP files The terminal acts as an FTP client supporting PUT, GET, DIR, and DEL operations to send and receive files to-and from a target server. Over the IsatData Pro network FTP data is sequenced through the channel infrastructure subsequently. A successfully allocated channel is required to execute FTP service commands. The GPRS terminals do not support 0-byte FTP data. Any attempt to send an empty file is ignored. 5.19.1.2 HTTP Available on satellite-cellular terminals. The ip service supports HTTP functionality with the following requirements: ¥ A remote URL indicating the server ¥ A path ¥ A port ¥ A successfully allocated channel The terminal acts as an HTTP client supporting standard operations to send and receive data to-and from a target server. 5.19.1.3 SMTP The ip service provides properties, functions and events to connect to SMTP servers or send and receive SMTP gateway email. In the case of M2M SMTP, each terminal has its own email address and does not require any authentication because each message originates from a terminal unique email address, or from an optional local email within the terminal. Two types of native email channels are available: ¥ M2M email allows the user to allocate header information for multiple email messages without having to resend that information with each email message. ¥ An SMTP channel replicates true SMTP server functionality (from address, to address and body). Additionally, any SMTP compliant header information can be supplied in the header portion of the message. All message formatting is accomplished within the terminal for from-mobile messages and is passed on from the gateway for to-mobile messages. A successfully allocated channel is required to send and receive email messages via the SMTP channel. M2M and SMTP client functionality is used to send from-mobile messages using a terminal API. SMTP server functionality supported at the gateway is used to receive to-mobile traffic and forward it to the terminal. SMTP messages are limited to a single to-mobile message (about 10 KB). From-mobile messages are split into multiple messages if the data size exceeds 6.4 KB. 5.19.1.4 TCP TCP streams functionality is supported by the ip service however it requires a remote IP address, port and a successfully allocated channel. The terminal acts as a TCP client to send and receive from-and to-mobile data with a designated connection end point. Over the IsatData Pro network TCP packets are sequenced through the channel infrastructure subsequently. 5.19.1.5 UDP The ip service supports UDP packet send-and-receive functionality however, it requires a remote IP address, port and successfully allocated channel. The terminal acts as a UDP client to send from-mobile packets and as a UDP listener to receive to-mobile packets. UDP packets are limited to the size supported by the IP infrastructure, typically 548 bytes. 5.19.2 Cellular Modules Available on cellular or satellite-cellular terminals. When routing channels over cellular, there are limits on the number of allocated channels for each channel type. Table 8: Cellular Channel Limits Each variant of the terminal supports different functionality. The table below includes what is available on each. The GPRS terminals do not support 0 byte FTP data. Any attempt to send an empty file is ignored. 5.19.3 Channel Modes of Operation Two channel modes of operation are available: session and transaction. 5.19.3.1 Session When TCP and UDP channels have the timeout parameter value set to 0, they operate in session mode. In this mode, the channel remains open until explicitly closed. In the intervening time, data can be sent over the channel at any time and is sent immediately. 5.19.3.2 Transaction For TCP and UDP channels that have the timeout parameter value set to something other than 0, and for all other channel types, the channel operates in transaction mode. The channel is automatically closed when the specified amount of time has elapsed without any data being sent or received (TCP and UDP channels), or the operation has completed (all other channel types). An event is posted to the handle when this final close occurs. As a short-cut for read-only operations (FTP GET and HTTP GET) the transaction begins as soon as the open() method is called. Calling the close() method is not necessary. 5.19.4 Secure Connections The ip service supports secure connections via SSL or TLS, within the constraints listed in section 1.1.1.2. Self-signed certificates on any of the servers are usable; however, in order for them to work, the certificate must contain the host name or IP address of the server in either the Common Name (CN) field, or the Subject Alternative Name (SAN) extended field. 5.19.5 Gateway Synchronization The ip service must synchronize with the IsatData Pro gateway when the LSF starts up. This causes both a from-mobile and a to-mobile message to be sent. The ip service can be disabled to avoid these messages. 1Explicit -The ORBCOMM server uses the same port number and the client explicitly needs to request a secure channel. 5.19.6 Compression The terminal indicates its ability to support compression to the gateway, and optionally uses compressed data messages if resources are available. The gateway uses compression if supported by the terminal. An allocated channel supports both compressed and uncompressed messages if the terminal supports compression. A terminal that does not support compression does not see the compressed message types. If compression is supported, a terminal only sends a compressed message if the size of the compressed data is less than the uncompressed size and if the compression ratio meets the minimum configured parameter. Only the data field in a satellite message is compressed. In the event that data submitted exceeds 6,000 bytes, it is split into multiple satellite messages and each message data field is then compressed. 5.19.7 Constants 5.19.7.1 TRANSPORT_IP Description This is the transport number used in the message service to have messages go over IP transports (either MTWS or MTBP). It has the value 2. Syntax svc.ip.TRANSPORT_IP 5.19.7.2 Channel Description This table maps channel types to their numerical value. It has the following fields: TCP  0  UDP  1  HTTP  2  FTP  3  NSMTP  4  SMTP  5  Syntax  svc.ip.Channel 5.19.7.3 ChannelStr Description This table does the reverse of Channel. It maps numerical values to channel types. It has the following indices: 0 TCP 1 UDP 2 3 4 5  HTTP FTP NSMTP SMTP  Syntax  svc.ip.ChannelStr 5.19.7.4 FtpOp Description This table maps FTP operation types to their numerical values. It has the following fields: GET 0 PUT 1 DIR 2 DEL 3 Syntax svc.ip.FtpOp 5.19.7.5 FtpOpStr Description This table does the reverse of FtpOp. It maps numerical values to FTP operation types. It has the following indices: 0 GET 1 PUT 2 DIR 3 DEL Syntax svc.ip.FtpOpStr 5.19.7.6 HttpOp Description Available on satellite-cellular terminals. This table maps HTTP operation types to their numerical values. It has the following fields: GET 0 POST 1 Syntax svc.ip.HttpOp 5.19.7.7 HttpOpStr Description Available on satellite-cellular terminals. This table does the reverse of HttpOp. It maps numerical values to HTTP operation types. It has the following indices: 0  GET  1  POST  Syntax  svc.ip.HttpOpStr 5.19.7.8 Routing Description Some values are only available on cellular or satellite-cellular terminals. This table maps routing types to their numerical values. It has the following fields: CELL_ONLY 0 CELL_SAT 1 SAT_ONLY 2 The CELL_ONLY and SAT_ONLY value indicates that data is only exchanged using the specified communication channel. When the CELL_SAT value is used, the service determines that communication channel to use at the time the channel connection is actually established: when the open() method is called for session mode TCP or UDP channels (timeout = 0), and when the close() method is called for all other channel types. Cellular coverage is used whenever possible. Note that when the selection has been made, no retry or automatic switchover occurs. When the decision has been made to establish a connection over satellite, each message sent has its options set to only use the satellite transport. Note: If an application needs more specific control over how things are performed, two channels can always be allocated: one with CELL_ONLY, the other with SAT_ONLY. Then the decision over which one to use is completely under its control, as are any recovery/switchover actions in case of a failure. Note: Any calls to this function with routing set to 0 or 1 results in an error code. Syntax svc.ip.Routing 5.19.7.9 RoutingStr Description This table does the reverse of Routing. It maps numerical values to routing types. It has the following indices: 0 CELL_ONLY 1 CELL_SAT 2 SAT_ONLY Syntax svc.ip.RoutingStr 5.19.8 Properties This service defines the properties dependent on the mode in which the terminal is acting. 5.19.8.1 M2M SMTP These informational properties apply to the IsatData Pro satellite native symmetrical M2M SMTP channel. 5.19.8.2 Satellite Properties These configuration parameters apply when enabling IP service features over the IsatData Pro satellite network. 5.19.8.3 Messaging Properties Not available on all terminals. The following table summarizes when a change to any of these properties takes effect. 1ÒÓ signifies an empty string. PIN Name Description Type Storage Default Value Class 5 Volatile false 6 Volatile false 46 Volatile false 47 Config true 49 Config false 50 Config "" 51 Config 8080 52 server2 The name, or IP address, of an alternate server to String Config "" connect to for sending/retrieving messages. Max. Ð 64 Ignored if PIN 49 is set to true. 5.19.9 To-Mobile Messages There are no to-mobile messages defined for this service. 5.19.10 From-Mobile Messages There are no from-mobile messages defined for this service. 5.19.11 Functions The ip service functions hide the complexity of dealing with the cell/GSM modem and IsatData Pro satellite messaging that supports IP connectivity and traffic. 5.19.11.1 channelAllocate() Description Associates the requested type and parameters with a newly allocated channel number. The following subsections describe the parameters associated with each value of the type parameter. There can only be up to eight channels allocated at any one time. The dispose() method must be called on the returned handle for it to be freed properly; simply setting it to nil does not free the channel object. If the routing value is not provided, the following default values are assumed: ¥ Routing.SAT_ONLY if the type is Channel.NSMTP, or the terminal does not have a cellular module ¥ Routing.CELL_ONLY in all other cases Note: Any calls to this function with routing set to Routing.0 or 1 results in an error. Note: Any calls to this function with routing set to Routing.CELL_ONLY or Routing.CELL_SAT for an NSMTP channel result in an error. Note: Any calls to this function with routing set to Routing.SAT_ONLY or Routing.CELL_SAT for an HTTP channel result in an error. Syntax svc.ip.channelAllocate(type, <table of type-related parameters>, routing) Parameters type The channel type as defined by Channel parameters The parameters related to the channel type routing The routing type as defined by Routing Blocking No Returns channel A handle for the channel, or nil if the channel cannot be allocated string An error description in the failure case 5.19.11.1.1 FTP Description This function allocates FTP parameters with a channel context. This channel is used to send or receive a file to or from the specified remote host and path. Syntax svc.ip.channelAllocate (svc.ip.Channel.FTP, fileSpec, routing) Parameters  type fileSpec routing  The channel type as defined by Channel(svc.ip.Channel.FTP) A table containing the information about the FTP source/destination: operation FtpOp host Destination host name or IP address (string) port Destination port number (unsigned; optional) login Account login (string; optional) password Account password (string; optional) useSSL Whether to use encrypted communication (Boolean) remotePath The file/directory path on the server The routing type, as defined by Routing  Blocking  No  Returns  channel  A handle to use for sending or receiving a file to or from the given host, or nil if the channel cannot be allocated  string  An error description of the failure case  5.19.11.1.2 HTTP Description Allocates HTTP parameters with a channel context. This channel is used to perform a GET or POST operation on a web server. Note: HTTP channels can only be used over cellular. Calling this function with routing set to Routing.SAT_ONLY or Routing.CELL_SAT causes an error. Syntax svc.ip.channelAllocate(svc.ip.Channel.HTTP, remote, routing) Parameters type remote routing  The channel type as defined by Channel (svc.ip.Channel.HTTP) Table containing information about the HTTP operation: operation One of HttpOp.GET or HttpOp.POST url The web server URL (starting with http or https) (string) content The value for the Content-Type header field; only used for POST requests (string; optional) The routing type, as defined by Routing  Blocking  No  Returns  channel  A handle for sending or receiving a file to-or-from the given host, or nil if the channel cannot be allocated  string  An error description in the failure case  5.19.11.1.3 M2M SMTP Email Description This function allocates an M2M SMTP channel in the ip service for sending email. The channel returned by this function allows the user to send email via the gateway without having to repeatedly pass on the destination, subject, or other header information. When allocating, the function does not check the validity of the destination addresses. If invalid, the service posts a failure event only after a message send fails. To and subject fields missing from the info table are filled with the corresponding default property value (PIN 1-2). Syntax svc.ip.channelAllocate(svc.ip.Channel.NSMTP, info, routing) Parameters type The channel type as defined by Channel (svc.ip.Channel.NSMTP) info Table containing the information specifying the originator and destination addresses as well as the subject: to ÔtoÕ email addresses (comma-separated string; optional) cc ÔccÕ email addresses (comma-separated string; optional) bcc ÔbccÕ email addresses (comma-separated string; optional) subject Email subject (string; optional) headers String containing additional header parameter, CRLF separated (string, optional) from Local sender username (string; optional). If not present, the terminal address is used. routing The routing type, as defined by Routing Returns channel A handle to use for sending an email via the gateway, or nil if the channel cannot be allocated string An error description in the failure case 5.19.11.1.4 SMTP Email Description This function allocates a SMTP channel in the ip service for sending email. The channel returned by this function allows the user to send email via the gateway. When allocating, the function does not check the validity of the destination addresses. If invalid, the service posts a failure event only after a message send fails. Only the last allocated SMTP channel receives to-mobile messages from the gateway. Any previous SMTP channel is only available for from-mobile messages. Syntax svc.ip.channelAllocate(svc.ip.Channel.SMTP, {}, routing) Parameters  type  The channel type as defined by Channel (svc.ip.Channel.SMTP)  routing  The routing type, as defined by Routing  Returns  channel  A handle to use for sending an email via the gateway, or nil if the channel cannot be allocated  string  An error description of the failure case  5.19.11.1.5 TCP Description This function allocates TCP parameters within a channel context. This channel is used to send and receive packets/stream data to and from the specified remote host. Syntax svc.ip.channelAllocate(svc.ip.Channel.TCP, remote, routing, compress) Parameters type The channel type as defined by Channel (svc.ip.Channel.TCP) remote Table containing the information about the TCP destination: host Destination host name or IP address (string) port Destination TCP port number (unsigned) timeout  The inactivity timeout. The amount of time, in seconds, to wait for incoming packets; 0 means wait forever and try to keep the socket alive (unsigned; optional Ð range is 0 .120, default is 60). The timeout window is reset every time a new packet is received.  useSSL  Whether to use encrypted communication (Boolean; optional Ð default is false)  keepalive  Whether to use native TCP keepalive packets on modules that support them (Boolean; optional Ð default is false)  idletime  If native TCP keepalive packets are enabled, specifies the amount of time (in minutes) that the connection must be idle before a keepalive packet is sent (unsigned; optional Ð default is 7200 or 2 hours)  routing  The routing type, as defined by Routing  compress  Boolean indicating whether to use compression or not, optional with default as false. Only used for satellite data -has no meaning for cellular transport. If compression is not supported, allocate fails.  Blocking  No  Returns  channel string  A handle to use for sending and receiving TCP, or nil if the channel cannot be allocated An error description in the case of a failure  5.19.11.1.6 UDP Description This function allocates UDP parameters within a channel context. This channel is used to send and receive datagrams to and from the specified remote host. Syntax svc.ip.channelAllocate(svc.ip.Channel.UDP, remote, routing) Parameters type The channel type as defined by Channel (svc.ip.Channel.UDP) remote Table containing the information about the UDP destination: host Destination host name or IP address (string) port Destination UDP port number (unsigned) timeout The inactivity timeout. The amount of time, in seconds, to wait for incoming datagrams; 0 means wait forever (unsigned; optional Ð range is 0 -120, default is 60). The timeout window is reset every time a new datagram is received. routing The routing type, as defined by Routing Blocking No Returns  channel  A handle to use for sending and receiving UDP datagrams, or nil if the channel cannot be  allocated  string  An error description in the failure case  5.19.11.2 ftp() Description This function transfers a file via FTP. Note that this function blocks until the transfer is complete. Both the src and dest parameters can be a file path or a URL; there must be one of each. If src is a file path and dest is a URL, then the file is transferred from the terminal to the server; otherwise the file is transferred from the server to the terminal. A URL is specified using the following syntax: ftps://[<login>[:<password]@]<host> [:<port>]/remotePath. Syntax svc.ip.ftp(src, dest, routing) Parameters src The source URL or file dest The destination URL or file routing The routing type, as defined by Routing Blocking Yes Returns string An error description in the failure case 5.19.11.3 httpGet() Description This function transfers a file to the terminal via HTTP. Note that this function blocks until the transfer is complete. A URL is specified using the following syntax: http[s]://<host>[:<port>]/remotePath. Syntax svc.ip.httpGet(src, dest, routing) Parameters src The source URL or file dest The destination URL or file routing The routing type, as defined by Routing Blocking Yes Returns string An error description in the failure case 5.19.11.4 pollNow() Description This function triggers a connection attempt to the server to check for to-mobile messages. If configured for MTWS, an HTTP GET request is performed. For MTBP, this function has no effect. Syntax svc.ip.pollNow() Parameters None Blocking No Returns None 5.19.12 Channel Methods The allocate function returns a handle that support the functions documented in this section. 5.19.12.1 close() Description This function indicates that no further writes will be performed on a previously-opened channel. When the channel is operating in transaction mode, it is not fully closed until a SOCKET_CLOSED, UDP_COMPLETE, FTP_ COMPLETE, HTTP_COMPLETE , EMAIL_STATUS, or SMTP_STATUS event is posted to the handle indicating it is closed and cannot be reopened until that time. Syntax <handle>:close() Parameters None Returns boolean Indicates success or failure string An error description in the failure case 5.19.12.2 dispose() Description This function deallocates the channel. The channel is no longer useable subsequent to this call, all locally and gateway cached parameters should be considered cleared. When an unrecoverable error occurs during processing of a channel, it is also automatically disposed. In that case a DISPOSE event is posted to the handle. Syntax <handle>:dispose() Parameters None Blocking No Returns boolean Indicates success or failure string An error description in the failure case 5.19.12.3 info() Description This function returns a table containing statistics for the channel. The statistics include: totalmsgs Ð The total number of messages sent since the channel was allocated totalbytes Ð The total number of bytes (data payload only) sent since the channel was allocated queuedmsgs Ð The total number of messages sending or waiting to be sent queuedbytes Ð The total number of bytes sending or waiting to be sent Syntax <handle>:info() Parameters None Blocking No Returns table A table containing a summary of information about the channel 5.19.12.4 open() Description This function opens a channel for subsequent communication. Syntax <handle>:open() Parameters None Blocking No Returns boolean Indicates success or failure string An error description in the failure case 5.19.12.5 send() Description This function sends data over an established channel. Syntax <handle>:send(data) Parameters  data  Data to be sent over the channel. This is ignored for read-only connections (HttpOp.GET,  FtpOp.GET). This is limited to a maximum of 548 bytes for UDP channels.  Blocking  No  Returns  boolean  Indicates success or failure  string  An error description in the failure case  5.19.12.6 usingCell() Description Available on cellular or satellite-cellular terminals (ST 9100). This function returns whether or not a currently open channel is using cellular. Syntax <handle>:usingCell() Parameters None Blocking No Returns boolean true if the channel is using cellular; false otherwise 5.19.13 Posted Events 5.19.13.1 Cellular Ready Description This event is sent whenever there is a change in the availability of cellular communication for the ip service. Source svc.ip(ip service table) Event ÒCELL_READYÓ (string) Arguments boolean The new value of the cellReady property 5.19.13.2 Channel Disposed Description This event is posted when a channel is automatically disposed due to error. Source <channel>(the handle returned by channelAllocate()) Event ÒDISPOSEÓ (string) Arguments status A table with the following field: error An error description in the failure case 5.19.13.3 Data Received Description This event is posted when data is received on a channel (TCP, UDP, HTTP, and FTP). Source <channel>(the handle returned by channelAllocate()) Event ÒDATAÓ (string) Arguments data The received data (string) 5.19.13.4 Email Status Description This event is posted whenever an M2M email send completes, whether it succeeds or fails. Source <channel>(the handle returned by channelAllocate()) Event ÒEMAIL_STATUSÓ (string) Arguments  status  The completion status, which is one of: svc.message.MsgStatus.Cancelled svc.message.MsgStatus.Success svc.message.MsgStatus.Failure  2 3 4  5.19.13.5 FTP Complete Description This event is posted when an FTP operation completes. Source <channel>(the handle returned by channelAllocate()) Event ÒFTP_COMPLETEÓ (string) Arguments  fileSpec  A table containing the information about the FTP source/destination  operation  FtpOp  host  Destination host name or IP address (string)  port  Destination port number (unsigned; optional)  login  Account login (string; optional)  password  Account password (string; optional)  useSSL  Whether to use encrypted communication (Boolean)  remotePath  The file/directory path on the server (string)  success  Indicates success or failure (Boolean)  error  An error description in the case of failure (string)  5.19.13.6 HTTP Complete Description Available on satellite-cellular terminals. Posted when an HTTP operation completes. Source <channel>(the handle returned by channelAllocate()) Event ÒHTTP_COMPLETEÓ (string) Arguments remote A table with the following fields:containing the information about the HTTP channel operation One of HttpOp.GET or HttpOp.POST url The web server URL (starting with http or https) (string) content The value for the content-type header field; only used for POST requests (string; optional) success Indicates success or failure (Boolean) error An error description in the case of failure (string) 5.19.13.7 M2M Email Received Description This event is posted when one or more new (gateway) emails are received by the terminal. Source svc.ip (ip service table) Event ÒEMAILÓ (string) Arguments email The received email, which is a table containing the following fields: from Sender's email address to Destination addresses cc Cc destination addresses (optional) subject Message subject body Message body 5.19.13.8 Satellite Ready Description This event is sent whenever there is a change in the availability of satellite communication for the ip service. Source svc.ip(ip service table) Event ÒSAT_READYÓ (string) Arguments boolean The new value of the satReady property 5.19.13.9 SMTP Email Received Description This event is posted when a new gateway email is received by the terminal. Source <handle> (the handle returned by channelAllocate()) Event ÒSMTPÓ (string) Arguments from Sender's email address rcpt Recipient addresses (optional) body Message body 5.19.13.10 SMTP Status Description This event is posted whenever an SMTP email send completes, whether it succeeds or fails. Source  <handle>(the handle returned by channelAllocate())  Event  ÒSMTP_STATUSÓ  (string)  Arguments  status  The completion status, which is one of:  svc.message.MsgStatus.Cancelled  2  svc.message.MsgStatus.Success  3  svc.message.MsgStatus.Failure  4  5.19.13.11 Server Connected Description Posted when the serverConnected ip service property changes value. Source svc.ip (ip service table) Event ÒSERVER_CONNECTEDÓ (string) Arguments boolean Indicates whether connection to the server was successfully established or not 5.19.13.12 Socket Closed Description This event is posted when a TCP channel is closed. In one-shot mode, this is useful because the channel is now available for use again. Source <channel>(the handle returned by channelAllocate()) Event ÒSOCKET_CLOSEDÓ (string) Arguments status A table with the following fields: success Indicates success or failure (Boolean) error An error description in the case of failure (string) 5.19.13.13 UDP Complete Description This event is posted when a UDP transfer is complete (i.e., the timeout has elapsed after the datagram was sent or after the last datagram was received). Source <channel>(the handle returned by channelAllocate()) Event ÒUDP_COMPLETEÓ (string) Arguments status A table with the following fields: success Indicates success or failure (boolean) error An error description in the case of failure (string) 5.19.13.14 Application Examples Refer to APPENDIX D for application examples. 5.20 Accelerometer (SIN 34) The accelerometer service (SIN 34) defines the global configuration of the accelerometer API. The accelerometer provides the following features/benefits: ¥ Filtered motion detection generating start/stop events ¥ Multiple thresholds and durations that are independent of the hardware ¥ Accelerometer sample collection and retrieval ¥ Simplified offset compensation ¥ Standardized axes definitions to simplify software development 5.20.1 Global Parameters Note: Changing global parameters permanently requires a restart of the LSF. The accelerometer defines a number of global parameters that are shared by all services using the accelerometer service (Table 9). Global configuration information is stored in configuration properties of the accelerometer service. The values are only applied when the LSF starts. Table 9: Global Configuration 5.20.1.1 Gravity Range Table 10 shows the gravity ranges for the accelerometer. All acceleration values are reported as 16-bit signed values. Note: Some API settings do not directly match what the current hardware supports. Use the getConfig() function to see the configuration actually used by the hardware. 5.20.1.2 Accelerometer Power Modes The accelerometer hardware can be in one of three possible modes. The API switches between these modes without any explicit control by the user. Table 11: Accelerometer Power Modes Operating Mode Description Suspended Mode Suspended mode is the default mode when the accelerometer hardware has nothing to do and no data acquisition is taking place. All event detection is disabled, and it consumes the least amount of current. Suspended mode is automatically entered when no event detectors are enabled, and no sample capturing is taking place. DetectorDescriptionMOTIONGeneratesfilteredSTART/STOPmotionevents.Canmonitoroneormoreaxes.Operating Mode Description Low Power Mode In low power mode, the accelerometer is periodically switching between a sleep phase and a wake-up phase to conserve power. The sleep phase is controlled by the sleepDuration property (PIN 3) To enable low power mode, the sleep duration must be set to a nonzero value. The accelerometer API uses low-power mode unless sample capture is enabled. Note: Low power mode adds up to sleepDuration milliseconds to event detection timing and sample acquisition. Note: When sleepDuration is nonzero, the greater the sleepDuration, the higher the probability that a short duration shock may not be detected by a shock detector. Active Mode In active mode (normal mode), the accelerometer hardware is fully powered up and performing continuous data acquisition at the configured sample rate. Active mode is entered when sample capturing is active, or detectors are enabled and the sleepDuration (PIN 3) is zero. 5.20.1.3 Gravity Compensation The accelerometer supports the following gravity compensation modes: ¥ None In this mode (the default) there is no compensation with respect to gravity performed by the API. The Z-axis of this orientation always contains the gravity component. When hardware offset compensation is performed, the gravity component of the Z-axis is preserved. There is no effect on tilt calculations because gravity is present in the samples. ¥ Fixed Axis In this mode, the gravity component of the standard Z-axis is zeroed if hardware offset compensation is performed. Tilt computations automatically add back the gravity vector of the Z-axis before computing the tilt solution. 5.20.1.4 Offset Compensation An application using the accelerometer needs to be aware of the mapping between each accelerometer axis and the actual direction in the real world. The accelerometer service provides methods to compensate the offsets of each axis to account for hardware variation, and end-of-line trimming with respect to the configured orientation. Both manual and automatic hardware based offset compensation are supported. The offset compensation is limited to ±1000 mg and ±500 mg for ST 9100. 5.20.2 Event Detection The API uses an instance of a detector to manage the detection and posting of acceleration events. A function is used to create an event detector specified by a string identifier. The API currently supports the event detectors shown in Table 12. The returned object handle is then used to control the event detection and generation. The event is generated when the threshold conditions are met on any of the configured axes for the specified minimum time. Table 12: Event Detectors 5.20.2.1 Parameter Guidelines MOTION The default threshold value of 100 milli-g is sufficient for most applications. The start/stop check intervals default to low power operation configuration, which respond slowly (5 minutes) to motion. For a faster response at the expense of power consumption, reduce the startCheckInterval (Table 6). If false starts are acceptable, then the startDebouceCount property can also be reduced. SHOCK Shock threshold can vary greatly depending on the application. Table 13 shows some typical values for detecting various driving exceptions. These are preliminary values that should be verified per application . 5.20.2.2 Motion Detector States The motion detector uses slope (absolute value of acceleration differences) events to determine motion. These are independent of terminal orientation. The motion detector filters slope events to allow for the generation of de-bounced motion start and motion stop events. The detector has two main active states: MOVING and STATIONARY. The MOVING state is defined as the presence of a motion event during a set of consecutive time intervals. The STATIONARY state is defined as an absence of slope events during a set of consecutive time intervals. The startCheckInterval/startDebounceCount parameters (refer to section 1.1.2.3 for further details) are used to define the STATIONARY check time intervals and number of slope events required before switching to the MOVING state. The stopCheckInterval/stopDebounceCount parameters are used to define the MOVING check time intervals and the number of absent slope events required before switching to the STATIONARY state. 5.20.2.3 Detector Parameters Below are the parameters available for each detector for use with the setConfig()/getConfig() methods. MOTION The MOTION detector configuration parameters are defined in Table 14. The motion detector filters slope (absolute value of acceleration differences) events to allow for the generation of de-bounced motion start and motion stop events. The maximum number of active MOTION detectors is 4. Table 14: MOTION Detector Configuration Parameters Parameter Description Type Default Value axisList xy threshold 100 startCheckInterval 60 5 stopCheckInterval 60 stopDebounceCount Number of check intervals with no motion events while in Unsigned 5 MOVING state before determining that motion has stopped Minimum Ð 1 Max. Ð 10000 SHOCK The SHOCK detector configuration parameters are defined in Table 15. The shock detector is used to detect absolute acceleration values on any of the specified axes that exceed the configured threshold for more than a specified number of milliseconds. The SHOCK detector generates a SHOCK_START event when absolute acceleration on any of the monitored axes exceeds the acceleration threshold in milli-g for a minimum of minTime milliseconds. After the event, the detector is rearmed after reArmDelay milliseconds. If the maxTime parameter is greater than zero, then the detector also generates SHOCK_STOP events when either the acceleration value goes below the threshold on all monitored axes or the maxTime timeout is reached. A timeout of .1 indicates an infinite timeout. The maximum number of active SHOCK detectors is 8. FieldTypeDescriptionactiveBooleantrueifthedetectorisenabledmovingBooleantrueifthedetectorisintheMovingstateTable 17: SHOCK State Fields Parameter Description Type Default Value threshold Absolute acceleration threshold in milli-g Unsigned 400 Minimum Ð 0 Max. Ð variable minTime Minimum duration in milliseconds that the threshold must be exceeded Unsigned 1000 before generating a SHOCK_START event Minimum Ð 0 Maximum Ð 5000 maxTime Maximum duration in milliseconds of a SHOCK event. If nonzero, a Signed 0 SHOCK_STOP event is generated when the event condition ends or a Minimum Ð -1 maxTime is reached. Nonzero positive values must be ³ minTime. A Max. Ð 30000 value of -1 indicates an infinite timeout. A value of 0 prevents SHOCK_ STOP events. reArmDelay Delay in milliseconds before reenabling the detector for the next event Unsigned 150 Minimum Ð 1 Maximum Ð 5000 5.20.2.4 Detector State Fields The following state fields can be queried with the getState() method. MOTION Table 16: MOTION State Fields SHOCK 5.20.3 Sample Capture To support advanced post processing, the accelerometer API supports the capture of real-time accelerometer data into sample capture buffers. The captured samples are processed according to the configured gravity compensation mode. During sample capture, sleep duration (low power mode) is automatically disabled. Sample Entries The sample entries consist of the following components: ¥ X axis acceleration in signed milli-g ¥ Y axis acceleration in signed milli-g ¥ Z axis acceleration in signed milli-g Each axis is stored as a signed 16 bit signed integer in big-endian format so a sample entry uses 6 bytes of memory. Memory Segments The API allows for the creation of a sample buffer that internally contains one or more memory segments allocated from the Lua heap, which are used to collect acceleration samples. The size of each segment is determined by the desired sample capture duration specified in seconds. Segments are indexed starting from 1, so the 2nd segment would have index 2. When the end of a segment is reached, sampling switches to the next segment if available. The API also supports the optional generation of a SEGMENT_FULL event when the end of a segment is reached. Wrap Mode The wrap mode determines the behavior of the sample buffer when the end of the last segment is reached. If wrap mode is enabled, then sampling switches back to the beginning of the first segment and continues filling from there. If only one segment is defined, then wrap mode behaves like having a single ring buffer. If wrap mode is disabled, then sampling stops at the end of the last segment and a CAPTURE_STOPPED event is generated. Limits The maximum number of capture buffer handles is 2. The limit on the parameters used to create capture buffers is a maximum of 8 segments with each having a maximum size of 32 KB. 5.20.4 Sample Retrieval A small number of acceleration samples can be obtained at a low rate for orientation confirmation or investigative purposes. Sample retrieval can be performed via the accel getsamples shell command, or over-the-air via the to-mobile getSamples (MIN 2) and from-mobile samples (MIN 2) messages. Only a single sample retrieval session can exist at one time. The accel getsamples shell command can be used to display sample information initiated over-the-air or via the shell. Sample retrieval can not be performed if auto-orientation is in progress. Sample information is available via the shell for 10 minutes after the last sample is obtained, or until auto-orientation is started. Note that if the sleepDuration (PIN 3) property value exceeds the sampling rate corresponding to the specified samplesPerSec value, the sampling rate will correspond to the sleepDuration when an enabled shock or motion detector exists. 5.20.5 Accelerometer Orientation Standard Orientation The figures below show the standard orientation. Figure 3: ST 6000 Accelerometer Axis Ð Standard Orientation FRONT BACK Note: Z axis is vertically off the board, towards the sky, on the antenna side. Figure 4: ST 61xx Accelerometer Axis Ð Standard Orientation FRONT BACK Figure 5: ST 9100 Accelerometer Axis Ð Standard Orientation FRONT BACK The Z-axis is oriented up and down and experiences a constant positive acceleration of 1g upward (normal force). The connector location is considered the back of the terminal. The positive Z-axis points up. Nonstandard Orientation To allow for installations in nonstandard orientations, the accelerometer service supports properties to indicate which axis (and direction) represents forward motion and which axis (and direction) represents upward motion. Two properties, forwardDirection and upwardDirection, are used to specify the configuration. These properties are enumerated ranges with the following values: XPos, XNeg, YPos, YNeg, ZPos, ZNeg. For the standard configuration (see figures above), forward acceleration results in positive values along the Y axis, so the default value for forwardDirection is YPos. Similarly, the default for upwardDirection is ZPos. Table 18 shows some example installation orientations and the corresponding configuration settings. Refer to APPENDIX E for visual details of the various installation orientations and their associated PIN values. When the configured orientation (forwardDirection and upwardDirection) match the actual orientation of the terminal (and the X, Y, and Z offsets are set correctly), the three axes report acceleration values as follows: ¥ X: right (+) and left (-) ¥ Y: forward (+) and backward (-) ¥ Z: up (+) and down (-) Note that acceleration due to gravity is factored in when gravityCompensation=None. 5.20.5.1 Automatic Orientation Detection Automatic orientation detection mode can be entered to attempt to determine a terminalÕs orientation automatically. Auto-orientation can be initiated (or aborted) via the aoActivate (PIN 70) property , the accel autoorient shell command, or the autoOrientation (MIN 1) to-mobile message. PINs 40 to 74 are specific to the automatic orientation detection feature. The auto-orientation status is available via the aoStatus (PIN 71) property. A series of successive states occur during auto-orientation. In order, they are: DetermineUpwardDir, AwaitStationary, PerformCompensation, AwaitMoving, DetermineFwdDir. The current state (when aoStatus is Started), or the last state (when aoStatus is not Started) is available via the aoState (PIN 72) volatile property. The auto-orientation status and state can also be obtained via the accel autoorient shell command, or the autoOrientationStatus from-mobile message. The autoOrientationStatus from-mobile message is sent upon an aoStatus change, or in response to an autoOrientation to-mobile message with operation = GetStatus. Upon successful completion of auto-orientation the following properties are determined and saved: xOffset (PIN 10), yOffset (PIN 11), zOffset (PIN 12), forwardDirection (PIN 20), and upwardDirection (PIN 21). Any other properties with PIN < 40 with pending changes are also saved. While auto-orientation is in progress (aoStatus is Started), any enabled shock and/or motion detectors are temporarily disabled, and their enable() method return an error if called. Any running sample captures are temporarily stopped (immediately), and their start() method return an error if called. Execution of other detector and sample capture methods can be performed while auto-orientation is in progress. You should not change accelerometer properties (other than aoActivate) while auto-orientation is in progress, and accelerometer service function calls may fail, have no effect, or return unexpected values when auto-orientation is in progress. Auto-orientation detection may not be possible (or thresholds may have to be adjusted) on slow moving vehicles that can not decelerate a fast as highway vehicles. For example, slow moving heavy equipment. Auto-orientation fails (aoStatus becomes Failed, and aoActivate becomes NotStarted) if completion of all the states is not successful within aoTimeLimit (60) minutes. The default of 60 minutes should be sufficient to successfully complete auto-orientation under typical conditions. Auto-orientation can be adjusted via PINs 40-69 to meet the requirements of different types of vehicles and power consumption. Auto-orientation can not be started if sample retrieval is in progress. 5.20.5.2 Guidelines for Successful Auto-Orientation Mount the terminal as close to orthogonal as possible (with respect to up/down and forward/backward directions) prior to starting auto-orientation. The AwaitStationary state requires valid GPS fixes. This requires that the terminal's satellite antenna has a clear line-of.sight to multiple GPS satellites. Obtaining GPS fixes requires continuous GPS to be enabled, which occurs when the position serviceÕs continuous property (SIN 20, PIN 15) is nonzero. Continuous GPS is enabled upon entering the AwaitStationary state as the continuous property is temporarily set to aoAwaitStnChkIntvl (2) seconds during this state. Obtaining GPS fixes is delayed (typically under 1 minute) if continuous GPS is not enabled prior to auto-orientation starting. When the terminal first becomes stationary after auto-orientation is started (as determined by the AwaitStationary state) it should be located on a level surface (for example, not parked on a hill). Encountering consecutive minor road bumps is required to detect motion while in the AwaitMoving state. This may not occur on recently paved roads and/or at low speeds. The vehicle on which the terminal is mounted should be subjected to typical city driving on fairly straight roads, with frequent stops and/or reasonably firm decelerations, which are not immediately preceded or followed by a sharp turn. Determining the forward direction may not be possible if the terminal is not near-orthogonally mounted (with respect to the forward/backward direction). Auto-orientation progress can be monitored via the auto-orientation related volatile properties. Auto-orientation related configuration properties can be adjusted to optimize auto-orientation to accommodate vehicle type, driver and road characteristics, and traffic density. 5.20.5.3 Power Considerations If the amount of power consumption during auto-orientation is important, the key properties to consider adjusting are: aoAwaitStnChkIntvl, aoAwaitStnSecTime, aoAwaitStnSecChkIntvl, aoAwaitMovChkIntvl, and aoTimeLimit. There may be trade-offs between, power consumption, time to complete auto-orientation, successful completion of auto-orientation, and/or true/false detection of the to-mobile direction. 5.20.5.4 Low Power Mode The sleep phase durations are shown in Table 19. Table 19: Sleep Phase Durations Sleep Phase Duration Average Current Comsumption Sleep Phase Duration Average Current Comsumption (ms) (µA) (ms) (µA) ST 6000 and ST 6100 ST 9100 None 129 None 180 1 78.8 2.5 172 2 55.0 5 111 4 34.5 10 57 6 25.2 20 30 10 16.4 40 17 25 7.4 80 10 50 4.0 160 6 100 2.3 320 5 The sleepDuration property (PIN 3) values are converted to the following sleep durations: sleepDuration Configured Hardware Sleep Phase Duration sleepDuration Configured Hardware Sleep Phase Duration (PIN 3) (ms) (PIN 3) (ms) ST 6000 and ST 6100 ST 9100 0 None 1 2.5 25 ³3 and²5 10 ³6 and²8 20 ³9 and ²17 40 ³18 and ²38 80 ³39 and ²75 160 ³76 and ²300 320 ³301 and ²750 640 ³751 1000 ³961 1280 5.20.6 Properties Note: The accelerometer service properties with PIN <40 only take effect when the LSF starts; so a restart of the LSF is required after making any changes. To assist in diagnostics, a configPending (PIN 1) property is available to indicate pending changes to the API configuration. The forwardDirection and upwardDirection properties are used for installation orientation configuration. These values must not be set to the same axis. If they are, an error is logged and these two properties are ignored (default configuration is used). When any manual change in forwardDirection,, upwardDirection, and /or gravityCompensation has taken effect, hardware compensation should be performed, and the xOffset, yOffset, and zOffset properties should be manually updated. Note: Property names prefixed with ÒaoÓ relate to the auto-orientation feature. PIN Name Description Type Storage Default Class Value 1 false 24 30 4 63 5 None 10 Config 0 11 Config 0 12 zOffset Z-axis offset compensation in Config 0 milli-g. 47 aoAwaitStnDebounce The number of consecutive valid GPS fixes required to declare the terminal stationary (when PIN 45 threshold is met). Type Storage Default Class Value Enum YPos 0 Ð XPos 1 Ð XNeg 2 Ð YPos 3 Ð YNeg 4 Ð ZPos 5 Ð ZNeg ZPos Unsigned 800 Min. Ð 700 Max. Ð 1000 Unsigned 300 Min. Ð 50 Max. Ð 699 Unsigned 300 Min. Ð 30 Max. Ð 600 30 Unsigned 20 Min. Ð 0 Max. Ð 50 Unsigned 2 Min. Ð 1 Max. Ð 30 Config Unsigned 5 Min. Ð 2 Max. Ð 300 PIN Name Description Type Storage Default Class Value 66 aoFwdDirEventFilterTime Event filter time in seconds. Config 5 forwardDirection events are ignored if events also occur on the other nonupward axis or the maximum heading variance is exceeded this number of seconds before or after an event. 67 aoFwdDirDebounce Number of consecutive times the Config 3 forwardDirection axis and polarity must be determined to be the same before declaring the forwardDirection as being determined. 69 aoTimeLimit Time limit in minutes to perform Config 60 auto-orientation before aoStatus becomes Failed. 70 aoActivate Start or abort auto-orientation. Enum Config NotStarted Setting to NotStarted is ignored. 0 Ð NotStarted Set to NotStarted and saved when 1 Ð Start aoStatus becomes Complete, 2 Ð Abort Aborted, or Failed. 71 aoStatus Automatic orientation status. Enum Volatile n/a 0 Ð NotStarted 1 Ð Started 2 Ð Aborted 3 Ð Failed 4 Ð Complete 72 aoState Automatic orientation state. Volatile n/a 73 aoStateFwdDirDebounceCount Number of consecutive times the Volatile n/a forwardDirection axis and polarity has been determined to be the same. 74 aoStateFwdDirRetryCount Number of retries in attempt to Unsigned Volatile n/a determine the same Min. Ð 0 forwardDirection Max. Ð 65535 aoFwdDirDebounce consecutive times. Unsigned Min. Ð 2 Max. Ð 10 5.20.6.1 Sample Rates The tables below specify the sample rates supported by the accelerometer hardware and the sampleRate property (PIN 3) mapping. Note: Caution must be taken when using sampling rates above 125 Hz. Note: When sleepDuration > 0, the sample rate corresponds to a sample interval equal to the configured hardware sleep phase duration (for example, on ST 6xxx terminals, when sleepDuration = 40 ms, the sample interval is 40 ms, and the sample rate is 1000/40 ms = 25 Hz (regardless of the configured sampleRate)). Table 22: ST 6000 and ST 6100 sampleRate Property Mapping 5.20.6.1.1 Sample Resolution The ST 6xxx terminals support 10-bit signed acceleration data and the ST 9100 supports 16-bit signed acceleration data. The API reports all acceleration values as 16-bit signed values. Offset Compensation The accelerometer service provides methods to compensate the offsets of each axis to account for hardware variation, aging, and end-of-line trimming with respect to the configured orientation. The offset range is -1000mgÉ1000mg on ST 6xxx and -500mgÉ500mg on ST 9100. An error is returned when an offset property is attempted to be set outside the range of -500..500 on ST 9000 terminals. Gravity Compensation The FixedAxis gravity compensation mode is not supported on ST 9000 terminals. An error is returned when the gravityCompensation property is attempted to be set to FixedAxis on ST 9000 terminals. 5.20.7 To-Mobile Messages 5.20.7.1 autoOrientation (SIN 34, MIN 1) 5.20.7.2 getSamples (SIN 34, MIN 2) 5.20.8 From-Mobile Messages 5.20.8.1 autoOrientationStatus (SIN 34, MIN 1) Name Type Optional Size Comments status Enum No 3 bits Current value of aoStatus property (PIN 71). See aoStatus (PIN 71) state Enum Yes 1 + 3 bits Current value of aoState property (PIN 72). See aoStatus Indicates auto-orientation progress when (PIN 71) status=Started, or state when status became Complete, Aborted, or Failed. Absent when status=NotStarted. stateFwdDirDebounceCount Unsigned Yes 1 + 4 bits Current value of aoStateFwdDirDebounceCount property (PIN 73). Absent when status=NotStarted. stateFwdDirRetryCount Unsigned Yes 1 + 16 bits Current value of aoStateFwdDirRetryCount property (PIN 74). Absent when status=NotStarted. forwardDirection Enum No 3 bits Current value of forwardDirection property (PIN see 20). forwardDirection property (PIN 20) 5.20.8.2 samples (SIN 34, MIN 2) Name Type Optional Size Comments zMinimum Signed Yes 15 bits Minimum value of z-axis acceleration samples in milli-g. zMaximum Signed Yes 15 bits Maximum value of z-axis acceleration samples in milli-g. sampleVals Array Yes ²128 A list of acceleration samples. elements x Signed Yes 15 bits x-axis acceleration value in mili-g y Signed Yes 15 bits y-axis acceleration value in mili-g z Signed Yes 15 bits z-axis acceleration value in mili-g 5.20.9 Functions 5.20.9.1 computeTilt() Description This function computes a 3-axes tilt solution given a raw X, Y and Z acceleration vector provided as milli-g. Syntax svc.accelerometer.computeTilt(x, y, z) Parameters  x  Integer acceleration in milli-g along the X-axis  y  Integer acceleration in milli-g along the Y-axis  z  Integer acceleration in milli-g along the Z-axis  Blocking No Returns number The angle of the X-axis in degrees relative to the ground number The angle of the Y-axis in degrees relative to the ground number The angle of the Z-axis in degrees relative to the gravity vector 5.20.9.2 getConfig() Description This global query function returns a table indicating the accelerometer configuration. These values may be different from the current property values because either the property values have been set but the LSF has not been restarted, or a property value specified does not exactly match what the hardware supports. The accelerometer API is designed to accommodate hardware changes. The getConfig() function is used to view the actual hardware configuration. Syntax svc.accelerometer.getConfig() Parameters  None  Blocking  No  Returns  table  A table populated with the following fields:  device  Accelerometer terminal name string  gRange  Gravity range setting (gRange (PIN 2))  sleepDuration  Sleep duration setting (sleepDuration (PIN 3))  sampleRate  Sample rate setting (sampleRate (PIN 4))  sampleInterval  Interval in milliseconds between samples, not including sleep duration  gravityCompensation  Gravity compensation mode(gravityCompensation (PIN 5))  5.20.9.3 getSample() Description This function requests and waits for the next available acceleration sample by calling requestSample() and waiting for the SAMPLE event. This function may block for over a second if the maximum sleep duration is configured. Syntax svc.accelerometer.getSample(timeout) Parameters timeout The optional amount of time to wait for the sample to become available in 1/10 of a second. A default of 50 (5 seconds) is used if the timeout is not provided. Blocking Yes Returns boolean false indicating operation failed string A description of the error in the case of a failure OR boolean true indicating operation was successful integer The acceleration in milli-g along the X-axis integer The acceleration in milli-g along the Y-axis. integer The acceleration in milli-g along the Z-axis. integer Timestamp of the sample (terminal uptime in seconds) 5.20.9.4 getStatus() Description This global query function returns the current global dynamic status of the accelerometer service. Refer to section 1.1.1.2 for a description of the power modes. Syntax svc.accelerometer.getStatus() Parameters  None  Blocking  No  Returns  table  A table populated with the following fields:  powerMode  String describing the current power mode of the accelerometer hardware.  Possible values include:  ÒSuspendedÓ  Lowest power nonoperational standby state  ÒLow PowerÓ  Operating with the currently configured sleep duration  ÒActiveÓ  Always on  activeSampleBuffers  Number of active sample buffers  activeDetectors  Number of active (enabled) detectors  currentSleepDuration  Current sleep duration in effect  5.20.9.5 getTilt() Description This function requests and waits for the next available acceleration sample (using getSample()) and then uses the result to compute a 3 axis tilt solution, adjusting for gravity compensation as required. Just like getSample (), this function may block for over a second if the maximum sleep duration is configured. Note: This function may return unexpected values when automatic orientation is in progress. Syntax svc.accelerometer.getTilt(timeout) Parameters timeout The optional amount of time to wait for the sample to become available in 1/10 of a second. A default of 50 (5 seconds) is used if the timeout is not provided. Blocking Yes Returns boolean false indicating the operation failed string A description of the error in the case of a failure OR boolean true indicating the operation was successful number The angle of the X-axis in degrees relative to the ground number The angle of the Y-axis in degrees relative to the ground number The angle of the Z-axis in degrees relative to the gravity vector Example Display the tilt relative to the gravity vector every second. --Display the current tilt every second while true do local success,_,_,tilt = svc.accelerometer.getTilt() if success then printf("Tilt= %.1f\n", tilt) end sched.delay(10) end 5.20.9.6 offset.clear() Description This compensation method clears any offset compensation, resulting in the accelerometer returning uncompensated values. Note: The xOffset, yOffset, and zOffset properties are not affected by clear(). The offsets to use are obtained from these properties during the next LSF restart. Syntax svc.accelerometer.offset.clear() Parameters None Blocking No Returns None 5.20.9.7 offset.doHWCompensation() Description This compensation method requests that automatic hardware based offset compensation by calling requestHWCompensation() and waits for the HW_COMPENSATION_DONE event. The accelerometer hardware must be idle for this function to work. All detectors sample captures must be disabled. Syntax svc.accelerometer.offset.doHWCompensation(timeout) Parameters  timeout  The (optional) amount of time to wait for the compensation to complete in 1/10 of a second. A  default of 50 (5 seconds) is used if the timeout is not provided  Blocking  Yes  Returns  boolean  Indicates success or failure  string  A description of the error in the case of a failure  5.20.9.8 offset.get() Description This compensation method returns the current offset compensation values. Note: This function may return unexpected values when automatic orientation is in progress. Syntax svc.accelerometer.offset.get() Parameters None Blocking No Returns number The current X-axis signed offset in milli-g number The current Y-axis signed offset in milli-g number The current Z-axis signed offset in milli-g 5.20.9.9 offset.requestHWCompensation() Description This compensation method requests that automatic hardware based offset compensation of all three axes be performed. This function starts the compensation and then returns immediately. A HW_COMPENSATION_ DONE event is generated when the compensation is complete. The hardware compensation uses 16 samples for each axis resulting in a total of 48 samples. At the slowest sample rate, this takes approximately 3 seconds. Hardware compensation is intended for end-of-line trimming, and should only be performed when the vehicle on which the terminal is mounted (if applicable) is stationary and located on a level surface (for example, not parked on a hill), and the terminal's orientation is close to that specified by forwardDirection , upwardDirection and when configPending=false. The offsets determined by this process are available via offset.get() and should be set and saved in xOffset, yOffset, and zOffset in order for these offsets to be applied on an LSF restart. Note: The accelerometer hardware must be idle for this function to work. All detectors and sample captures must be disabled. This function fails when automatic orientation is in progress. Syntax svc.accelerometer.offset.requestHWCompensation() Parameters None Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure 5.20.9.10 offset.set() Description This compensation method allows for manually specifying or loading previously calculated compensation offsets. Note: This function has no effect when automatic orientation is in progress. Syntax svc.accelerometer.offset.set(xOff, yOff, zOff) Parameters  xOff  The X-axis signed offset in milli-g  yOff  The Y-axis signed offset in milli-g  zOff  The Z-axis signed offset in milli-g  Blocking No Returns None 5.20.9.11 requestSample() Description This function requests an accelerometer sample. When the sample is available, the SAMPLE event is posted asynchronously. Requests are not queued, so multiple calls before the sample is ready result in one SAMPLE event. Note: This function may return unexpected values when automatic orientation is in progress. Syntax svc.accelerometer.requestSample() Parameters None Blocking No Returns None 5.20.10 Posted Events 5.20.10.0.1 Auto Orientation Status Description This event is posted when automatic orientation detection is completed, aborted, or failed. Source "_ACCEL" (string) Event "AUTO_ORIENTATION_STATUS" (string) Arguments table A table containing the following fields: status The automatic orientation detection status 1 Ð Complete 2 Ð Aborted 3 Ð Failed state The autoOrientState when automatic orientation detection ended. 1 Ð DetermineUpwardDir 2 Ð AwaitStationary 3 Ð PerformCompensation 4 Ð AwaitMoving 5 Ð DetermineFwdDir 5.20.10.1 H/W Compensation Done Description This event is posted when the hardware offset compensation has been completed. Source Ò_ACCELÓ (string) Event ÒHW_COMPENSATION_DONEÓ (string) Arguments None 5.20.10.2 Sample Description This event is posted when accelerometer sample is available following a call to the requestSample() function. Source Ò_ACCELÓ (string) Event ÒSAMPLEÓ (string) Arguments x X-axis acceleration value in milli-g (integer) y Y-axis acceleration value in milli-g (integer) z Z-axis acceleration value in milli-g (integer) ts The timestamp when the sample was captured (integer) 5.20.11 Accelerometer Event Detection 5.20.11.1 createDetector() Description This function is used to create a detector instance. Syntax svc.accelerometer.createDetector (name) Parameters  name  String specifÒMOTIONÓ ÒSHOCKÓ  ying the name of the detector to create. The supported detectors include: Start/Stop Shock acceleration detector  Blocking No Returns handle A handle to the detector, or nil if an error occurred string In the case of a failure, a description of the error Example --Create a shock detector local h,err = svc.accelerometer.createDetector("SHOCK") if h then ... else error() end 5.20.11.2 Detector Methods 5.20.11.2.1 destroy() Description This method destroys the detector, rendering the handle unusable. Destroying a detector (calling the destroy() method or removing all references to the handle and garbage collecting) stops the detector and releases all resources used by the detector. Syntax <handle>:destroy() Parameters None Blocking No Returns None 5.20.11.2.2 disable() Description This method disables event generation. Syntax <handle>:disable() Parameters None Blocking No Returns None 5.20.11.2.3 enable() Description This method enables event detection/generation. Due to resource and hardware limitations, a limited number of any given type of detector can be enabled at the same time. This method may fail due to these restrictions. Note: This function fails when automatic orientation is in progress. Syntax <handle>:enable() Parameters None Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure 5.20.11.2.4 getConfig() Description This method is used to query the current detector parameters. Syntax <handle>:getConfig() Parameters None Blocking No Returns table A table populated with the detector specific fields from section 1.1.2.3. Example --Display the configured threshold local cfg = h:getConfig() printf("Threshold is %d milli-g\n", cfg.threshold) 5.20.11.2.5 getState() Description This method is used to query the dynamic state of the detector. Syntax <handle>:getState() Parameters None Blocking No Returns table A table populated with the detector specific fields from section 1.1.2.4 Example --Display the 'moving' state of a motion detector. local state = mh:getState() print("Motion state: ", state.moving and "MOVING" or "STATIONARY") 5.20.11.2.6 setConfig() Description This method is used to configure the parameters of a detector. The configuration is specified by providing a table populated with fields from section 1.1.2.3. If a field is not provided, the default or last setting is used. Syntax <handle>:setConfig(config) Parameters config A table with one or more detector parameter fields as defined in section 1.1.2.3. Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure Example Create and configure a SHOCK detector. --Create a shock detector local h,errMsg = svc.accelerometer.createDetector("SHOCK") if h then --Configure for harsh cornering. local success success, errMsg = h:setConfig({axisList='x', threshold=450, minTime=2000}) if success then --All setup, so now enable. h:enable() else error(errMsg) end else error(errMsg) end 5.20.11.3 Posted Events 5.20.11.3.1 Motion Start Description This event is posted by the MOTION detector when the start of motion is detected. Source "_ACCEL" (string) Event "MOTION_START" (string) Arguments handle Detector handle that posted the event 5.20.11.3.2 Motion Stop Description This event is posted by the MOTION detector when motion is no longer detected. Source "_ACCEL" (string) Event "MOTION_STOP" (string) Arguments handle Detector handle that posted the event 5.20.11.3.3 Shock Start Description This event is posted by the SHOCK detector when the absolute acceleration along the configured axes exceeds the threshold parameter for the minimum time specified by the minTime parameter. Source "_ACCEL" (string) Event "SHOCK_START" (string) Arguments  handle  Detector handle that posted the event.  integer  X-axis acceleration value in milli-g  integer  Y-axis acceleration value in milli-g  integer  Z-axis acceleration value in milli-g  integer  The timestamp when the shock started  5.20.11.3.4 Shock Stop Description This event is posted by the SHOCK detector after a SHOCK_STOP Event if the maxTime parameter is nonzero and either the acceleration along the axis is no longer above the threshold parameter or the timeout has occurred. Source "_ACCEL" (string) Event "SHOCK_STOP" (string) Arguments handle Detector handle that posted the event integer Duration of the event in samples integer The timestamp when the shock event stopped 5.20.12 Sample Capture Buffer Sample capture buffers can be used to collect accelerometer samples. Each buffer consists of one or more memory segments. The first entry in each segment is time-stamped with the terminal uptime in seconds, which can then be queried later to determine when the segment started filling. Starting a sample capture disables low power operation (sleepDuration (PIN 3) is ignored) until the sample buffer stops. 5.20.12.1 createSampleBuffer() Description This function is used to create a sample buffer consisting of one or more memory segments whose size determined by the desired capture time. The memory used for the segments is allocated from the Lua heap. Note: The maximum size of a single segment is limited to 32 KB. Syntax svc.accelerometer.createSampleBuffer(segCount, captureTime) Parameters  segCount  Number of memory segments to allocate (1 to 8)  captureTime  Desired capture time in seconds used to determine the size of each segment.  Blocking No Returns handle A buffer handle, or nil if an error occurred string A description of the error in the case of failure Default Configuration wrap Disabled segmentFullEvent Disabled for all segments Example Create a sample capture buffer consisting of two segments that are each 30 seconds long (at the current sample rate). --Create a capture buffer with 2 30 second segments. local h,err = svc.accelerometer.createSampleBuffer(2, 30) if h then h:start() ... else error() end 5.20.12.2 Sample Buffer Handle Methods The sample buffer handle methods are used to control the sample capture. Some methods operate on all or specific memory segments. Memory segments are numbered starting from one. A segment of zero specifies the entire buffer. 5.20.12.2.1 clear() Description This method clears the memory segments and resets the sampling to the first segment. Syntax <handle>:clear() Parameters None Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure 5.20.12.2.2 count() Description This method returns the current number of sample entries for all segments or for a specified segment. Syntax <handle>:count(index) Parameters  index  Optional segment index. Zero or no index counts the contents of all segments.  Blocking  No  Returns  integer  Number of sample entries, or nil on failure  string  A description of the error in the case of failure  5.20.12.2.3 currentSeg() Description This method returns the current segment. This is the segment being filled if sampling is enabled or the segment where it stopped if sampling is disabled. Syntax <handle>:currentSeg() Parameters None Blocking No Returns integer Segment index 5.20.12.2.4 destroy() Description This method stops sampling and releases all memory segments, rendering the handle unusable. Destroying a sample buffer (calling the destroy() method or removing all references to the handle and garbage collecting) stops the sample buffer and releases all resources used by the sample buffer. Syntax <handle>:destroy() Parameters None Blocking No Returns None 5.20.12.2.5 getString() Description This method returns the contents of the specified segment as a Lua string. If the specified segment is actively being filled, an error is returned indicating the segment is busy. If no index or an index value of zero is provided, the entire capture is returned as a concatenation of all memory segments. In order to retrieve the entire buffer, the sample capture must be stopped. If the segment or segments are empty, an empty string is returned. Syntax <handle>:getString(index) Parameters  index  Optional segment index. Zero or no index extracts the contents of all segments if sampling is  disabled.  Blocking  No  Returns  boolean  Indicates success or failure  string  A string containing the samples or an error message  Example Take a capture buffer and print the acceleration samples as comma separated values. --Print sample values in capture buffer ÔcbÕ local success, s = cb:getString() if success then local function signExt(x) return bit32.band(x, 0x8000) ~= 0 and bit32.bor(x, 0xFFFF0000) or x end local sampleCount = cb:count() local offset = 1 for i = 1,sampleCount do local x = signExt((s:byte(offset + 0) * 256) + s:byte(offset + 1)) local y = signExt((s:byte(offset + 2) * 256) + s:byte(offset + 3)) local z = signExt((s:byte(offset + 4) * 256) + s:byte(offset + 5)) printf("%d,%d,%d\n",x,y,z) if (i % 100) == 0 then sched.delay(5) --Be friendly to the system end offset = offset + 6 end end end 5.20.12.2.6 running() Description This method returns if the sample capture is running or not. If a stop() request has been issued but the sample capture is still running, this method returns true. Syntax <handle>:running() Parameters None Blocking No Returns boolean true if sample capture running, false otherwise. 5.20.12.2.7 segFullEvent() Description This method controls the generation of SEGMENT_FULL events when a segment is filled. If a segment identifier is not provided, then the command applies to all segments. Syntax <handle>:segFullEvent(enable, index) Parameters  enable  Boolean that enables/disables the generation of SEGMENT_FULL events.  index  Optional segment index (1, 2, 3, and so on). Zero or no index implies all segments.  Blocking  No  Returns  boolean  Indicates success or failure  string  A description of the error in the case of a failure  5.20.12.2.8 start() Description This method starts the sample capture at the beginning of the current segment. Note: This function fails when automatic orientation is in progress. Syntax <handle>:start() Parameters None Blocking No Returns boolean Indicates success or failure string A description of the error in the case of a failure 5.20.12.2.9 stop() Description This method stops the sample collection. There are two options: Stop at the end of the current segment, or immediately. Syntax <handle>:stop(now) Parameters  now  Boolean that if true stops the sample capture immediately, otherwise it stops at the end of the  current segment.  Blocking No Returns None 5.20.12.2.10 timeStamp() Description This method returns the timestamp of the first entry in the specified memory segment. Syntax <handle>:timeStamp(index) Parameters index Segment index or zero for the current segment Blocking No Returns integer Timestamp in seconds of the first sample of the segment, or nil if an error string A description of the error in the case of failure 5.20.12.2.11 wrap() Description This method controls what happens when the end of the last segment is reached. If true, then the sampling continues with the beginning of the first segment, otherwise the sampling stops and a CAPTURE_STOPPED event is generated. Syntax <handle>:wrap(enable) Parameters enable Boolean that enables wrap mode if true, otherwise disables it. Blocking No Returns None 5.20.12.3 Posted Events 5.20.12.3.1 Capture Stopped Description This event is posted when the last segment is full and wrap mode has not been enabled or if the sample capture is stopped asynchronously at the end of the current segment. Source "_ACCEL" (string) Event "CAPTURE_STOPPED" (string) Arguments handle Sample buffer handle that posted the event integer The timestamp when the capture stopped 5.20.12.3.2 Segment Full Description This event is posted when a segment is full and the segment full event has been enabled for the segment. Source "_ACCEL" (string) Event "SEGMENT_FULL" (string) Arguments  handle  Sample buffer handle that posted the event  integer  Index of the segment that is full  integer  The timestamp of the first sample in the segment  5.21 Bluetooth (SIN 35) This service is only available on terminals (for example, ST 9100) that support Bluetooth hardware. The Bluetooth service provides global management and control over the Bluetooth operations. For a list of common Bluetooth terms, refer to section 5.21.18. 5.21.1 Properties 5.21.2 To-Mobile Messages There are no to-mobile messages for this service. 5.21.3 From-Mobile Messages 5.21.3.1 centralConnectAlarm (SIN 35, MIN 1) 5.21.3.2 serialConnectAlarm (SIN 35, MIN 2) 5.21.4 Global Constants 5.21.4.1 addrType Description This table maps Bluetooth address type to their numerical values. It has the following fields: Public  0  RandomStatic  1  PrivateResolvable  2  PrivateNonResolveable 3 Syntax svc.bluetooth.addrType 5.21.4.2 addrTypeStr Description This table does the reverse of addrType. It maps numerical values back to the string value. It has the following fields: 0 1 2 3  ÒPublicÒ ÒRandomStaticÒ ÒPrivateResolvableÒ ÒPrivateNonResolveableÓ  Syntax  svc.bluetooth.addrTypeStr 5.21.5 Server Constants 5.21.5.1 MAX_SHORT_MSG_SIZE This defines the maximum short message size. 5.21.6 GAP Client Constants 5.21.6.1 MAX_ADV_FILTERS Defines the maximum number of total advertising filters allowed at the same time. 5.21.6.2 MAX_ADV_FILTERS_PER_SCANNER Defines the maximum number of advertising filters per scanner. 5.21.7 GATT Client Constants 5.21.7.1 MAX_PERIPHERAL_CONNECTIONS This defines the maximum number of peripheral connections that are allowed at the same time. 5.21.7.2 MAX_SERVICES_PER_CONNECTION This defines the maximum number of services that is cached from a connection discovery. 5.21.7.3 MAX_CHARACTERISTICS_PER_SERVICE This defines the maximum number of characteristics that cached for each service. 5.21.7.4 propertyBits Supported property characteristic bit values that are used in bit masks: 5.21.8 Server Functions (Peripheral Role) These functions are used for the peripheral role of the terminal. 5.21.8.1 getDeviceLabel() Description Gets the Bluetooth asset ID / label of the device. This string could be different than the activeLabel (PIN 13) property, depending on whether or not an SP label has been configured. Syntax svc.bluetooth.getDeviceLabel() Parameters None Returns label The device label string 5.21.8.2 setDeviceLabel() Description Sets the label of the device. The label is advertised as part of the scan response and it is also available as one of the fields of the device descriptor service. If the label is NOT set, then scan responses are not generated. Changes to the label take effect the next time advertising is enabled. Note: An error is returned if the SP label has been set via the shell Ôsetcfg btlabelÕ command, as it has priority. Syntax svc.bluetooth.setDeviceLabel(label) Parameters  label  The device label string (maximum of 25 characters)  Returns  true  OR  If successful  false If unsuccessful errMsg String description of the error 5.21.8.3 getBondedCentralDevices() Description Query the addresses of the central devices that are currently bonded with the terminal. Syntax svc.bluetooth.getBondedCentralDevices() Parameters None Returns bondList Array of zero or more tables with the following fields: addr table with the following fields: addrType svc.bluetooth.addrType address String of 6 hexadecimal octets the form AA:BB:CC:DD:EE:FF Example Display the bonded central devices local bd = svc.bluetooth.getBondedCentralDevices() if #bd > 0 then for i=1,#bd do local addr = bd[i].addr printf("#%d -type: %d addr: %s\n", i, addr.addrType, addr.address) end else print("No bonded central devices") end --RESULT: #1 -type: 0 addr: 5C:F3:70:88:EE:1D 5.21.8.4 deleteBondedCentralDevice() Description Deletes the bonding information for the specified device address. Syntax svc.bluetooth.deleteBondedCentralDevice(addr) Parameters addr table with the following fields: addrType svc.bluetooth.addrType address String of 6 hexadecimal octets the form AA:BB:CC:DD:EE:FF Returns true If successful OR false If unsuccessful errMsg String description of the error Example Delete a bonded central device local addr = { addrType = svc.bluetooth.addrType.Public, address = "5C:F3:70:88:EE:1D" } local success, err = svc.bluetooth.deleteBondedCentralDevice(addr) if success then print("Device deleted") else print("*** error: Unable to delete device: ", err) end Delete all bonded central devices local bd = svc.bluetooth.getBondedCentralDevices() for i=1,#bd do local addr = bd[i].addr local success, err = svc.bluetooth.deleteBondedCentralDevice(addr) if not success then printf("*** error: Unable to delete device '%s', err=%s\n", addr.address, err) end end 5.21.8.5 startFastAdvertising() Description Starts fast advertising for the specified time duration. This command will fail if a central device is already connected or advertising or Bluetooth is disabled. Syntax svc.bluetooth.startFastAdvertising(duration) Parameters  duration  Fast advertising duration in seconds (optional, default is 30 seconds, maximum 300 seconds)  Returns  true false errMsg  OR  If successful If unsuccessful String description of the error  5.21.9 Short Message Functions (Peripheral Role) The terminal supports a general-purpose short message service, which allows a connected central to exchange short messages with the terminal. 5.21.9.1 createShortMessageHandle() Description Creates a handle for sending and receiving short messages from the connected central device. Syntax svc.bluetooth.createShortMessageHandle(_SIN) Parameters _SIN Service Identification Number of the service being registered Returns handle A short message handle OR nil Indicates an error occurred errMsg String description of the error 5.21.9.2 Message Handle Methods 5.21.9.2.1 send() Description Send a binary short message to the connected central. Syntax <handle>:send(msg) Parameters msg Binary data string of up to MAX_SHORT_MSG_SIZE bytes Returns  true  If successful  OR  false  If unsuccessful  errMsg  String description of the error  Example --Create the short message handle local handle, err = svc.bluetooth.createShortMessageHandle(_SIN) if handle then --Send the message local success success, err = handle:send("Hello world") if success then print("Bluetooth short message sent") else print("Unable to send short message, err= ", err) end else print("Unable to create short message handle, err= ", err) end 5.21.10 GAP Client Functions (Central Role) GAP Client functions are using to scan and discover peripheral devices. 5.21.10.1 Filtering Advertisement Reports The interface provides an API to scan for Bluetooth advertisements from nearby devices. Due to the potential of a high rate of advertising traffic, the interface uses a combination of filtering and queuing to capture the advertising reports. Advertising reports are composed of filterable and non-filterable components. Advertising report filtering consists of three components: signal strength filter, advertising content filters, and message rate filter. Global Signal Strength Filter is controlled by the scannerRSSIFilter property Per Scanner Content Filter (Global total of 16) Global Message Rate Filter is controlled by the scannerRateFilter property Each scanner instance can optionally specify one or more content filter configurations. Each configuration can filter on one or more of the following: ¥ Device address type ¥ Device address ¥ Advertising type ¥ Advertising data The report is compared against all the components and only passes if all conditions match. For example, a filter configuration that specifies both a device address type of Ô1Õ (RandomStatic) and an advertising data type of Ô9Õ (ÒComplete Local NameÓ) will only match ÔRandomStaticÕ addresses with complete local names. Each scanner can have up to MAX_ADV_FILTERS_PER_SCANNER content filters. A report is accepted if it matches any of the content filters. For example, to capture reports with both a ÒComplete Local NameÓ and ÒShortened Local NameÓ would require at least two content filters. Note: Filtering does not apply to scan responses, as they are merged with the primary advertising packet. 5.21.10.2 createScanner() Description Creates a scanner handle that provides methods to scan for a list of peripheral devices with optional filtering. The handle is also the source for all events coming from the scanner. Syntax svc.bluetooth.createScanner(config) Parameters  config  optional table with the any of the following fields:  name  Optional string which names the scanner for debug/logging support.  qSize  Optional integer which specifies the size of the advertising report match queue (Default: 32)  qTrigger  Optional integer which specifies the number of entries that must be in the advertising report  queue before triggering an event (Default: 1)  event  Optional boolean that if true, generates the TRIGGER event when the ÔqTriggerÕ threshold is  reached. (Default: false)  Returns handle A scanner handle OR nil Indicates an error occurred errMsg String description of the error Example --Create a new peripheral scanner with a 50 entry match queue which generates events local scanH,err = svc.bluetooth.createScanner({name="sensors" qSize = 50, event=true}) if scanH then --Do something with scanner else print(err) end 5.21.10.3 Scanner Handle Methods 5.21.10.3.1 name() Description Returns the name of the scanner that was specified when createScanner() was called. Syntax <handle>:name() Parameters None Returns name string name of the scanner 5.21.10.3.2 active() Description Returns a Boolean that indicates if the scanner is active or not. Syntax <handle>:active() Parameters None Returns active Boolean that is true if active, false otherwise 5.21.10.3.3 setFilters() Description Sets zero, 1 or more filters to limit the number of advertising reports received by the scanner. If the provided filter table is empty, the filters are cleared. A scanner can have a maximum of MAX_ADV_FILTERS_PER_SCANNER filters and there can be a maximum of MAX_ADV_FILTERS in the entire system. All advertising reports must first pass the global signal strength (RSSI) and message rate filters defined by the ÔscannerRSSIFilterÕ and ÔscannerRateFilterÕ properties respectively. The scan filters allow collecting of specific addresses, advertising types and advertising type data. Each advertising report is compared with each of the specified filters and if any filter matches, the advertising report will be captured in the match queue. Advertising reports that match are placed in the match queue in a first in, first out order. If the queue is full, the oldest reports are replaced. If no filter is provided, the default is to capture all advertising reports. Note: ORBCOMM recommends that filters be setup before starting the scanner. figures here Syntax <handle>:setFilters(filters) Parameters filters Array of tables that defines zero or more filter tables containing: addr table with the following fields: addrType If present, filter on the address type address If present, filter on the Bluetooth 48-bit address. The format is a 6 octet hexadecimal string of the form AA:BB:CC:DD:EE:FF advertisingType If present, filter on the 8-bit advertising type advertisingData If advertisingType is defined, filter on the first n bytes of the advertising type data Returns  true  If successful  OR  false  If unsuccessful  errMsg  String description of the error  Example Scan for device ORBCOMM devices for 10 seconds local scanH, err = svc.bluetooth.createScanner() if scanH then --Only need one filter local filter1 = { addr = { addrType = svc.bluetooth.addrType.RandomStatic }, advertisingType = 0xFF, --Manfacturing Specific Data advertisingData = string.char(0x71, 3) --ORBCOMM ID (0x0371) in little endian } local success, err = scanH:setFilters({filter1}) if success then scanH:start(10) else print("set filter error: ", err) end else print("Scanner creation error: ", err) end Scan for two specific device addresses --Scan for two specific addresses local scanH, err = svc.bluetooth.createScanner({name = "Device Finder", qSize = 5}) if scanH then --Use one filter for each address local filter1 = { addr = { addrType = svc.bluetooth.addrType.RandomStatic, address = "E2:49:B3:06:92:D1" } } local filter2 = { addr = { addrType = svc.bluetooth.addrType.RandomStatic, address = "CA:61:65:D1:AA:F1" } } --Set the two filters local success, err = scanH:setFilters({filter1, filter2}) if success then scanH:start(10) else print("set filter error: ", err) end else print("Scanner creation error: ", err) end 5.21.10.3.4 start() Description Start the advertising scanner using the currently configured filters with an optional duration in seconds. Each detected advertising packet and associated scan response, if any, is queued. If events are enabled and the queue trigger level is reached, a TRIGGER event is generated. When the scanner stops, either manually or when the optional duration expires, a SCAN_STOPPED event is generated. Syntax <handle>:start(duration) Parameters duration Optional duration in seconds. (Default is ÔzeroÕ, which means run untilstop() is called) Returns  true  If successful  OR  false  If unsuccessful  errMsg  String description of the error  Example --Start the scanner for 30 seconds scanH:start(30) Triggered Events ÒTRIGGERÓ ÒSCAN_STOPPEDÓ 5.21.10.3.5 stop() Description Stops the advertising report scanner and generates a SCAN_STOPPED event. The filters are unaffected by this operation. Syntax <handle>:stop() Parameters None Returns true If successful OR false If unsuccessful errMsg String description of the error Example --Stop the scanner scanH:stop() Triggered Events ÒSCAN_STOPPEDÓ 5.21.10.3.6 dequeue() Description The reports are removed from the head (oldest first) of the match queue, so if multiple reports are removed, they are in the order of oldest to newest. Syntax <handle>:dequeue(count) Parameters  count  Optional integer which specifies the maximum number of advertising reports to return. A negative  value means return all reports in the queue. (default: -1)  Returns reports Array of zero or more tables containing report data. Each report consists of a table with the following fields: addr Table with the following fields: addrType svc.bluetooth.addrType address String of 6 hexadecimal octets the form AA:BB:CC:DD:EE:FF rssi Integer signal strength in dBm timestamp Table with an uptime based time stamp which was set when the report was queued. It is composed of the with the following fields: sec integer number of seconds (signed 32-bit value) msec integer fraction of a second in milli-seconds advertisingData Table of advertising data with the following possible fields: rawData string representing the 31-byte advertising report < Decoded fields defined in Table 25> scanResponseData Table of scan response data with the following possible fields: rawData string representing the 31-byte scan response report < Decoded fields defined in Table 25> The ÔadvertisingDataÕ and ÔscanResponseDataÕ tables have some of the advertising types decoded into fields as shown in Table 25. Only advertising types that were found in the ÔrawDataÕ have corresponding fields decoded. If a ÔManufacturer Specific DataÕ type is present, then a ÔManufacturerDataÕ table is present inside the ÔadvertisingDataÕ/ ÔscanResponseDataÕ tables and is decoded according to Table 26 Field Type Type Value Type Name UUID Incomplete List of 16-bit Service Class UUIDs Complete List of 16-bit Service Class UUIDs Incomplete List of 32-bit Service Class UUIDs Complete List of 32-bit Service Class UUIDs Incomplete List of 128-bit Service Class UUIDs Complete List of 128-bit Service Class UUIDs name Shortened local name Complete local name txPowerLevel Tx Power Level slaveConnectionIntervalMin Slave Connection Minimum Interval slaveConnectionIntervalMax Slave Connection Maximum Interval ManufacturerData table 0xFF Manufacturer Specific Data (See Table 26) Table 26: Manufacturer Specific Data Fields Field Type Manufacturer Description companyID Integer defining the company identifier as defined here: https://www.bluetooth.com/specifications/assigned-numbers/company.identifiers/ ORBCOMM is company ID is 881. rawData String representing the raw manufacturer specific data txPowerLevel Tx power level with range of -127 to 127 dBm batteryPercentage Device battery charge as a percentage (0 to 100) deviceCategoryID Defines the category of the device label Customer definable device asset ID or label terminalVariant ST terminal variant modemVariant integer ORBCOMM ST modem variant Example Display formatted list of devices sorted by RSSI --Dequeue and display all devices ordered by RSSI local ScanReports = scanH:dequeue() table.sort(ScanReports, function(a, b) return a.rssi > b.rssi end) if #ScanReports > 0 then for i=1,#ScanReports do local ar = ScanReports[i] local name = ar.advertisingData.name or "" printf("#%02d: %-20s [%d -%s] RSSI= %d\n", i, name, ar.addr.addrType, ar.addr.address, ar.rssi) end else print("No devices found") end --Output example: #01: JCAB418150014 [1 -DB:A0:94:D4:14:92] RSSI= -49 #02: 01000024SKY99F5 [1 -DF:E0:D6:92:9A:1F] RSSI= -53 #03: FCAC619070170 [1 -D1:F1:E9:8D:72:87] RSSI= -67 #04: ABCD121000206 [1 -D5:A2:57:8B:A3:35] RSSI= -67 #05: EWAB617300089 [1 -DE:F1:6E:35:22:7C] RSSI= -70 #06: JSAB619300020 [1 -CF:6C:BC:A3:AD:1B] RSSI= -72 #07: FCBC619130100 [1 -E9:C4:85:6F:C7:77] RSSI= -73 Display raw report data --Dequeue and dump 2 reports from the scanner local t = scanH:dequeue(2) dumpvar(t) --Output example: result = { --table: 60171a20 (count= 2) [1] = { --table: 601e7058 (count= 0) timeStamp = { --table: 601e7188 (count= 0) sec = 120 msec = 260 } advertisingData = { --table: 601e7290 (count= 0) flags = 6 rawData = "\2\1\6\7Øq\3\1\4a\1\14\9EWAB619110095" ManufacturerData = { --table: 601e73f0 (count= 0) deviceCategoryID = "Wireless Sensor Tag" txPowerLevel = 4 companyID = 881 rawData = "\1\4a\1" batteryPercentage = 97 } name = "EWAB619110095" } rssi = -54 addr = { --table: 601e71f8 (count= 0) addrType = 1 address = "CE:05:A2:EE:21:36" } [2] = { --table: 601ddf18 (count= 0) timeStamp = { --table: 601de048 (count= 0) sec = 121 } msec = 167 } advertisingData = { --table: 601de150 (count= 0) flags = 6 rawData = "\2\1\6\7Øq\3\1\4d\0\14\9CCJA617280049" ManufacturerData = { --table: 601de2b0 (count= 0) deviceCategoryID = "Mobile Terminal" txPowerLevel = 4 companyID = 881 rawData = "\1\4d\0" batteryPercentage = 100 } name = "CCJA617280049" } scanResponseData = { --table: 601de408 (count= 0) rawData = "\21Øq\3\2\0GT1100 BLE122345" ManufacturerData = { --table: 601de568 (count= 0) deviceCategoryID = "Mobile Terminal" label = "GT1100 BLE122345" companyID = 881 rawData = "\2\0GT1100 BLE122345" } } rssi = -58 addr = { --table: 601de0b8 (count= 0) addrType = 1 address = "C2:C8:62:02:76:33" } } } 5.21.10.3.7 flush() Description Clears out the match queue and all metrics of the scanner and acknowledges posted events. Syntax <handle>:flush() Parameters None Returns None Example --Flush the scanner scanH:flush() 5.21.10.3.8 matchInfo() Description Returns a table with match information of the scanner. Syntax <handle>:matchInfo() Parameters None Returns Table with the following fields matchCount  Integer that indicates the total number of advertising reports that matched the filters.  qCount  Integer that indicates the number of advertising reports currently in the match queue  acknowledged  Boolean that indicates if the last GAP TRIGGER event has been acknowledged by using  dequeue() or flush().  Example local mi = ScanH:matchInfo() printf("qCount: %d\n", mi.qCount) printf("matchCount: %d\n", mi.matchCount) printf("acknowledged: %s\n", mi.acknowledged and "YES" or "NO") --Output example: qCount: 23 matchCount: 76 acknowledged: YES 5.21.10.3.9 config() Description Returns a table with the static configuration of the scanner. Syntax <handle>:config() Parameters None Returns Table with the following fields: name  String name of the scanner  active  Boolean that indicates if the scanner has started if true.  event  Boolean that if true, generates a TRIGGER event if the trigger level is reached.  gSize  Integer which specifies the size of the advertising report match queue  gTrigger  Integer which specifies the number of entries that must be in the match queue before triggering an  event if event generation is enabled  filters  Array of zero or more tables which indicate the current filter configuration. Each table contains some  of the following optional fields:  addr  table with some of the following fields:  addrType  integer svc.bluetooth.addrType  address  string address filter  advertisingType integer advertising type filter  advertisingData string advertising data  Example Dump the configuration of a scanner --Display the configuration of a scanner local cfg = scanH:config() dumpvar(cfg, 'cfg') --Output: cfg = { --table: 6022f130 (count= 0) active = false qTrigger = 5 name = "Device Scanner" filters = { --table: 6022f360 (count= 3) [1] = { --table: 6022f3c0 (count= 0) addr = { --table: 6022f470 (count= 0) addrType = 1 } advertisingType = 255 advertisingData = "q\3" } [2] = { --table: 6022f4e0 (count= 0) addr = { --table: 6022f590 (count= 0) addrType = 1 address = "E2:49:B3:06:92:D1" } } [3] = { --table: 6022f600 (count= 0) addr = { --table: 6022f6b0 (count= 0) addrType = 1 address = "CA:61:65:D1:AA:F1" } } } event = false qSize = 20 } 5.21.11 GATT Client Functions (Central Role) These functions are used in a Central Role to connect to Bluetooth peripherals (sensors). The API is inherently asynchronous, with GATT Client Events occurring at almost any time. For example, the peripheral device might disconnect (powered off, blocked, etc.) at any time. To simplify this, the connection handle methods which require communication with the peripheral device can operate in either a blocking (synchronous) mode or a non-blocking (a-synchronous) mode by using different versions of the same method. Asynchronous (non-blocking) methods are identified with an ÔAsyncÕ suffix. Blocking Mode ¥ Methods without the ÔAsyncÕ suffix are used ¥ Most events are consumed by the call and not generated from the handle, so the user does not have to process the events ¥ Some eventÕs like ÒDISCONNECTÓ events can occur at any time, even when using blocking mode API calls, since it can occur between API calls Non-blocking Mode ¥ ÔxxxAsync()Õ form of method is used ¥ The API function returns immediately ¥ The user must handle events that use the connection handle as the source 5.21.11.1 allocatePeripheralConnection() Description Allocates a Bluetooth peripheral (server) connection handle with an optional name. This handle is then used for all subsequent operations with the device. The handle is also the source for all events coming from the sensor. Syntax svc.bluetooth.allocatePeripheralConnection(name) Parameters name Optional string name to give the handle Returns  handle  A peripheral connection handle  OR  nil  Indicates an error occurred  errMsg  String description of the error  Example local sensorH, err = svc.bluetooth.allocatePeripheralConnection("SensorTest") if sensorH then --Create queue for sensor events BTSensorQ = sched.createEventQ(10, sensorH) BTSensorQ:name('Sensor') ... else print(err) end 5.21.11.2 Connection Handle Methods 5.21.11.2.1 connect() / connectAsync() Description Connects the handle to a specified peripheral device. A maximum of MAX_PERIPHERAL_CONNECTIONS devices can be connected to at once. The call is rejected if an existing connection is in progress. If a ÔpassKeyÕ is provided in the argument table, then the connection will automatically respond to ÒAUTH_KEY_ REQÓ events and call replyAuthKey() with the specified ÔpassKeyÕ. If the ÔpassKeyÕ is not accepted, the a ÒAUTH_ FAILEDÓ event will be generated followed by a ÒDISCONNECTÓ event. Syntax <handle>:connect(args) (blocking) <handle>:connectAsync(args) (non-blocking) Parameters args Table with the following fields: addrType svc.bluetooth.addrType of the address address String of 6 hexadecimal octets the form AA:BB:CC:DD:EE:FF passKey Optional 6-digit string to be used for automatic authentication reply Returns  true  If successful  OR  false  If unsuccessful  errMsg  String description of the error  errCode  Integer error code (see APPENDIX L)  Example --Connect to a specific address local arg = { addrType = svc.bluetooth.addrType.RandomStatic, address = "E2:49:B3:06:92:D1", } --Use a blocking call local success, errMsg, errCode = sensorH:connect(arg) if success then print("Connected to sensor") else printf("*** error: Connect error, err=%s, errCode=%d\n", errMsg, errCode) end Triggered Events (Async) ÒCONNECTÓ ÒDISCONNECTÓ ÒAUTH_KEY_REQÓ 5.21.11.2.2 name() Description Returns the name of the peripheral connection that was specified when allocatePeripheralConnection() was called. Syntax <handle>:name() Parameters None Returns name String name of the peripheral connection 5.21.11.2.3 connected() Description Returns true if the handle is currently connected with a peripheral device. Syntax <handle>:connected() Parameters None Returns active Boolean is true if connected, false otherwise 5.21.11.2.4 state() Description Returns a string that represents the internal state of the handle. The handle can be in one of the following states: ÔDISCONNECTEDÕ Not connected (initial state) ÔCONNECTINGÕ Connection and discovery is in progress ÔCONNECTEDÕ Connected to a peripheral device ÔDISCONNECTINGÕ Disconnection sequence in progress Syntax <handle>:state() Parameters None Returns state Connection state string 5.21.11.2.5 lastErrorCode() Description Returns the error code fo the last operation on the handle Syntax <handle>:lastErrorCode() Parameters None Returns errorCode Integer error code (see APPENDIX L) 5.21.11.2.6 getDiscoveredServiceAndChar() Description Retrieve the cached services and characteristics discovered after connection. Each connection can have up to MAX_SERVICES_PER_CONNECTIONservices, and each service can have up to MAX_CHARACTERISTICS_PER_SERVICE characteristics. Limitations: Returned UUID hex strings can be 16, 32, or 128 bits in length. Each service includes itÕs UUID and number of available characteristics. Each characteristic includes the following: valueHandle  Used to read/write/notify from/to the server  property  Bit mask of svc.bluetooth.propertyBits  cccdHandle  If exists, used to enable/disable characteristic notification or indication.  If services or characteristics are duplicated, the GATT server generates unique handles for each duplicate up to a maximum of 0xFFFF. Syntax <handle>:getDiscoveredServiceAndChar() Parameters None Returns svcList nil if error, or array of tables with the following fields: UUID Serivice UUID string characteristics Array of tables with the following fields: UUID Characteristic UUID string valueHandle Used to read/write/notify/indicate the characteristic OR nil errMsg errCode  property CCCDHandle Indicates an error occurred String description of the error Integer error code (see APPENDIX L)  Bit mask of svc.bluetooth.propertyBits. ÔnilÕ if property not ÒPROP_NOTIFYÓ or ÒPROP_INDICATEÓ  Example List of discovery of services and characteristics  --Get connection services and characteristics local svcList,err = conH:getDiscoveredServiceAndChar() if svcList then for i = 1, #svcList do printf("\nService(%d) UUID: %s\n",i, svcList[i].UUID) for j= 1, #svcList[i].characteristics do local chInfo = svcList[i].characteristics[j] local props = svc.bluetooth.propertyBits printf(" Characteristic(%2d) UUID: %s\n",j,chInfo.UUID) printf(" Value handle: %d\n",chInfo.valueHandle) printf(" Property(0x%02X): ", chInfo.property) if chInfo.property & props.PROP_READ ~= 0 then printf("READ, ") end if chInfo.property & props.PROP_WRITE ~= 0 then printf("WRITE, ") end if chInfo.property & props.PROP_WRITE_WITHOUT_RESP ~= 0 then printf("WRITE WITHOUT RESP, ") end if chInfo.property & props.PROP_NOTIFY ~= 0 then printf("NOTIFY, ") end if chInfo.property & props.PROP_INDICATE ~= 0 then printf("INDICATE") end printf("\n") if chInfo.property & (props.PROP_NOTIFY|props.PROP_INDICATE) ~= 0 then printf(" CCCD handle: %d\n",chInfo.CCCDHandle) end end end else print(err) end --RESULT: Service(1) UUID: 1800 Characteristic( 1) UUID: 2A00 Value handle: 3 Property(0x02): READ, Characteristic( 2) UUID: 2A01 Value handle: 5 Property(0x02): READ, Characteristic( 3) UUID: 2A04 Value handle: 7 Property(0x02): READ, Characteristic( 4) UUID: 2AA6 Value handle: 9 Property(0x02): READ, Service(3) UUID: 180F Characteristic( 1) UUID: 2A19 Value handle: 16 Property(0x12): READ, NOTIFY, CCCD handle: 17 Service(4) UUID: F21200005F0011E68B7786F30CA893D3 Characteristic( 1) UUID: F21200015F0011E68B7786F30CA893D3 Value handle: 20 Property(0x1E): READ, WRITE, WRITE WITHOUT RESP, NOTIFY, CCCD handle: 21 Characteristic( 2) UUID: F21200025F0011E68B7786F30CA893D3 Value handle: 23 Property(0x1E): READ, WRITE, WRITE WITHOUT RESP, NOTIFY, 5.21.11.2.7 readCharacteristic() / readCharacteristicAsync() Description Read the characteristic value from the peripheral/server. The characteristic must have the svc.bluetooth.propertyBits.PROP_READ bit set. This function can also be used to read the CCCD setup value if a CCCD handle is provided as a parameter. Syntax <handle>:readCharacteristic(valueHandle) (blocking) <handle>:readCharacteristicAsync(valueHandle) (non-blocking) Parameters valueHandle Characteristic value handle or CCCD handle Returns (Blocking) value  Binary string value  OR  nil  Indicates an error occurred  errMsg  String description of the error  errCode  Integer error code (see APPENDIX L)  Returns (Async) true If successful OR false If unsuccessful errMsg String description of the error errCode Integer error code (see APPENDIX L) Example Read all the characteristics of the first ÒDevice DescriptorÓ of an ORBCOMM sensor --Allocate our peripheral connection handle local success, rc local sensorH, err = svc.bluetooth.allocatePeripheralConnection() if sensorH then --Connect to the sensor success, err, rc = sensorH:connect({address = "e2:49:b3:06:92:d1"}) if success then --Get the service and characteristic database local discDB discDB, err = sensorH:getDiscoveredServiceAndChar() if discDB then --Look for the "Device Descriptor" entry for i = 1,#discDB do local service = discDB[i] if service.UUID == "298200006BA611E68B7786F30CA893D3" then --Loop over all the characteristics for j=1,#service.characteristics do --Now read the characteristic local ch = service.characteristics[j] local val val, err, rc = sensorH:readCharacteristic(ch.valueHandle) if val then --Quick guess of the format local fmt = 'z' if #val <= 2 then fmt = 'I2' elseif #val <= 4 then fmt = 'I4' end printf("UUID= %35s, Value= '%s'\n", ch.UUID, string.unpack(fmt, val)) end end --Found the service, so break out break end end end --Disconnect, ignoring the event sensorH:disconnectAsync() else printf("*** error: Unable to connect, err=%s, rc=%d\n", err, rc) end sensorH = nil end --Example Output UUID= 2A25, Value= 'EWAB619060014' UUID= 298200016BA611E68B7786F30CA893D3, Value= 'My Sensor' UUID= 298200026BA611E68B7786F30CA893D3, Value= '' UUID= 2A26, Value= 'SENS.002.001.0002' UUID= 298200056BA611E68B7786F30CA893D3, Value= 'S132.6.001.001' UUID= 2A27, Value= 'BA101098-001' UUID= 2A29, Value= 'ORBCOMM' UUID= 2A24, Value= 'DS300' UUID= 298200066BA611E68B7786F30CA893D3, Value= '2' Triggered Events (Async) ÒREAD_RESULTÓ ÒRW_ERRORÓ ÒDISCONNECTÓ 5.21.11.2.8 writeCharacteristic() / writeCharacteristicAsync() Description Write the specified characteristic value to the peripheral / server. The characteristic must have the svc.bluetooth.propertyBits.PROP_WRITE and/or svc.bluetooth.propertyBits.PROP_WRITE_WITHOUT_RESP bit set. Syntax <handle>:writeCharacteristic(valueHandle, data) (blocking) <handle>:writeCharacteristicAsync(valueHandle, data) (non-blocking) Parameters valueHandle Characteristic value handle for write data Binary data string Returns  true  If successful  OR  false  If unsuccessful  errMsg  String description of the error  errCode  Integer error code (see APPENDIX L)  Example Flash the LED on the ORBCOMM DS 300 door sensor --Allocate our peripheral connection handle local ok, rc local sensorH, err = svc.bluetooth.allocatePeripheralConnection() if sensorH then --Connect to the sensor ok, err, rc = sensorH:connect({address = "e2:49:b3:06:92:d1"}) if ok then --Get the service and characteristic database local discDB discDB, err = sensorH:getDiscoveredServiceAndChar() if discDB then --Look for the "Binary Output" entry for i = 1,#discDB do local service = discDB[i] if service.UUID == "B30200006F0C11E68B7786F30CA893D3" then --Loop over all the characteristics for j=1,#service.characteristics do local ch = service.characteristics[j] --Check for "Activate Binary Output" characteristic if ch.UUID == "B30200056F0C11E68B7786F30CA893D3" then --Write a binary 1 to trigger the LED ok,err,rc = sensorH:writeCharacteristic(ch.valueHandle, string.char(1)) if ok then print("DS300 LED should be flashing") else printf("*** error: Write failed, err=%s, rc=%d\n", err, rc) end end end --Found the service, so break out break end end end --Disconnect, ignoring the event sensorH:disconnectAsync() else printf("*** error: Unable to connect, err=%s, errCode=%d\n", err, rc) end sensorH = nil end Triggered Events (Async) ÒWRITE_DONEÓ ÒRW_ERRORÓ ÒDISCONNECT 5.21.11.2.9 configCCCD() / configCCCDAsync Description Enable/disable the specified CCCD. If the CCCD is not enabled, any change of the characteristic value at the server would not notify or indicate to the client (central). The characteristic must have the sys.bluetooth.gatt.propertyBits.PROP_NOTIFY and/or sys.bluetooth.gatt.propertyBits.PROP_INDICATE bit set. Syntax <handle>:configCCCD(cccdHandle, enable) (blocking) <handle>:configCCCDAsync(cccdHandle, enable) (non-blocking) Parameters cccdHandle CCCD handle of characteristics descriptor enable Boolean that if true, enables the CCCD, otherwise disables it Returns  true  If successful  OR  false  If unsuccessful  errMsg  String description of the error  errCode  Integer error code (see APPENDIX L)  Example --Allocate our peripheral connection handle local ok, rc local sensorH, err = svc.bluetooth.allocatePeripheralConnection() if sensorH then --Connect to the sensor ok, err, rc = sensorH:connect({address = "e2:49:b3:06:92:d1"}) if ok then --Get the service and characteristic database local discDB discDB, err = sensorH:getDiscoveredServiceAndChar() if discDB then --Look for the "Binary Input" entry for i = 1,#discDB do local service = discDB[i] if service.UUID == "F21200005F0011E68B7786F30CA893D3" then --Loop over all the characteristics for j=1,#service.characteristics do local ch = service.characteristics[j] --Check for "Raw Binary Value" characteristic if ch.UUID == "F21200065F0011E68B7786F30CA893D3" then --Enable notifications when this characteristic changes ok,err,rc = sensorH:writeCharacteristic(ch.CCCDHandle, true) if ok then print("Sensor will now generate magnet NOTIFICATION events") else printf("*** error: CCCD config failed, err=%s, rc=%d\n", err, rc) end end end --Found the service, so break out break end end end --Disconnect, ignoring the event sensorH:disconnectAsync() else printf("*** error: Unable to connect, err=%s, errCode=%d\n", err, rc) end sensorH = nil end Triggered Events (Async) ÒWRITE_DONEÓ ÒRW_ERRORÓ ÒDISCONNECTÓ 5.21.11.2.10 replyAuthKey() Description Respond to an authentication request with a pass key as part of the paring procedure. After the GATT Client Events AUTH_KEY_REQUEST is received, the application must reply with the pass key using this function within 20 seconds otherwise the link will be disconnected. If a pass key was provided with the connect() / connectAsync() call, this function will be called automatically in the background when the AUTH_KEY_REQUEST event is received. If the pass-key was not accepted, the a GATT Client Events AUTH_FAILED event will be generated followed by a DISCONNECT event. Once the peer device is bonded, no more passkey responses will be required for future connections. Syntax <handle>:replyAuthKey(passkey) Parameters passkey String of 6 numeric digits Returns true If successful OR false If unsuccessful errMsg String description of the error errCode Integer error code (see APPENDIX L) Example Flash the LED on the ORBCOMM DS 300 door sensor --Received AUTH_KEY_REQUEST from connection --Set passkey, it must be 6 digits local success, err = conH:replyAuthKey("000000") If not success then print(err) end Triggered Events ÒAUTH_FAILEDÓ ÒDISCONNECT 5.21.11.2.11 disconnect() / disconnectAsync() Description Disconnect from the peripheral. In non-blocking mode, a successful disconnect will always result in a ÒDISCONNECTÓ event with the ÔerrorCodeÕ set to 790 (Òhost terminated connectionÓ). In blocking mode, this errorCode is specifically used to indicate a successful disconnect. Syntax <handle>:disconnect() (blocking) <handle>:disconnectAskync() (non-blocking) Parameters None Returns  true  If successful  OR  false  If unsuccessful  errMsg  String description of the error  errCode  Integer error code (see APPENDIX L)  Example Blocking disconnect --Disconnect from connection local success, errMsg, rc = conH:disconnect() If not success then printf("*** error: Disconnect, err=%s, rc=%d\n", errMsg, rc) end Triggered Events (Async) ÒDISCONNECT" 5.21.11.3 getConnectedPeripheralDevices() Description Query what peripheral devices are connected. Each entry includes address, synchronization interval, latency and re-connect timeout. Syntax svc.bluetooth.getConnectedPeripheralDevices() Parameters None Returns  connList  Array of zero or more tables with the following fields:  addr  Table with the following fields:  addrType  svc.bluetooth.addrType  address  String of 6 hexadecimal octets the form AA:BB:CC:DD:EE:FF  interval  Connection synchronization interval in 1.25 ms units  latency  Count of connection intervals skipped from peripheral  timeout  Supervision timeout in 10ms units. Shows how many seconds to wait if connection is lost  OR  nil  Indicates an error occurred  errMsg  String description of the error  Example Display the connected peripheral devices --Get the connected device list local connList, err = svc.bluetooth.getConnectedPeripheralDevices() if connList then --Loop over the connection list for i = 1, #connList do local ci = connList[i] printf("Connection #%d:\n", i) printf(" Addr _type: %ds\n", ci.addr.addrType) printf(" Address: %s\n", ci.addr.address) printf(" Interval(ms): %d\n", ci.interval * 1.25) printf(" Latency: %d\n", ci.latency) printf(" Timeout(ms): %d\n", ci.timeout * 10) end else print(err) end --Output: Connection #1: Addr _type: 1 Address: E2:49:B3:06:92:D1 Interval(ms): 400 Latency: 4 Timeout(ms): 8000 5.21.11.4 getBondedPeripheralDevices() Description Query the address of the peripheral devices that are currently bonded with the terminal. Syntax svc.bluetooth.getBondededPeripheralDevices() Parameters None Returns  bondList addr  Array of zero or more tables with the following fields: Table with the following fields: addrType svc.bluetooth.addrType address String of 6 hexadecimal octets the form AA:BB:CC:DD:EE:FF  Example  Display the connected peripheral devices local bd = svc.bluetooth.getBondedPeripheralDevices() if #bd > 0 then for i=1,#bd do local addr = bd[i].addr printf("#%d -type: %d addr: %s\n", i, addr.addrType, addr.address) end else print("No bonded peripheral devices") end --RESULT: #1 -type: 1 addr: C2:F3:80:88:EE:1D 5.21.11.5 deleteBondedPeripheralDevice() Description Deletes the bonding information for the specified device address. Syntax svc.bluetooth.deleteBondPeripheralDevice(addr) Parameters addr  Table with the following fields: addrType svc.bluetooth.addrType address String of 6 hexadecimal octets the form AA:BB:CC:DD:EE:FF  Returns  true false errMsg  OR  If successful If unsuccessful String description of the error  Example  Delete a bonded peripheral device local addr = { addrType = svc.bluetooth.addrType.RandomStatic, address = "C2:F3:80:88:EE:1D" } local success, err = svc.bluetooth.deleteBondedPeripheralDevice(addr) if success then print("Device deleted") else print("*** error: Unable to delete device: ", err) end Delete all bonded peripheral devices --Delete all bonded peripheral devices local bd = svc.bluetooth.getBondedPeripheralDevices() for i=1,#bd do local addr = bd[i].addr local success, err = svc.bluetooth.deleteBondedPeripheralDevice(addr) if not success then printf("*** error: Unable to delete device '%s', err=%s\n", addr, err) end end 5.21.12 GATT Client Error Codes Refer to .APPENDIX L 5.21.13 Posted System Events The following system events are generated by the Bluetooth module. 5.21.13.1 RESET Description This event is posted when the Bluetooth hardware module resets for any reason. A reset cases all connected centrals and connections to peripheral devices to be disconnected. Any running device scanners will stop. Source Ò_BT_SYSÓ (string) Event ÒRESETÓ (string) Arguments Table with the following fields: reason Bluetooth reset reason that can have one of the following values 0 -power on 1 -soft reset 2 -reset pin 3 -watchdog 4 -wakeup 5 -lockup 6 -other 5.21.14 Server Global Events Description Server are events triggered via external devices (Centrals) connecting/disconnecting to the terminal to support peripheral role operation. Source Ò_BT_SERVERÓ (string) Events 5.21.15 GAP Client Events The following events can be generated when scanning for peripheral devices. 5.21.15.1 SCAN_STOPPED Description This event is posted when the GAP device scanner stops Source Scanner handle returned by createScanner() Events ÒSCAN_STOPPEDÓ (string) Arguments None 5.21.15.2 TRIGGER Description This event is posted when the scanner trigger level is reached, and events are enabled. Source Scanner handle returned by createScanner() Events ÒTRIGGERÓ (string) Arguments None 5.21.16 GATT Client Events Description GATT events are generated when using GATT client functions to communicate with a peripheral / sensor. Source GATT connection handle returned by allocatePeripheralConnection(). Events Cause Connection to peripheral result. If ÔerrorCodeÕ is zero, the connection is successful Disconnection from the peripheral. When data is received from the peripheral Write to the peripheral has succeeded Error occurred either reading or writing to the peripheral Peripheral is requesting a passkey Peripheral authorization failed, likely due to an errorCode APPENDIX L incorrect passkey 5.21.17 Short Message Events 5.21.17.1 RX_MSG Description This event is posted when a new central message has been received. Source Short message handle returned by createShortMessageHandle() Events  ÒRX_MSTÓ  (string)  Arguments  table  A table containing the following fields:  rawData  Binary string containing the message  5.21.18 Common Bluethooth Terminology 5.22 Reserved (SIN 61, SIN 62, and SIN 63) APPENDIX A SIN VALUES Terminal Core Services SIN Service Name Description 16 System Provides general management and control of the terminal, such as service identification, metrics, and status query/response. 17 Power Provides a unified interface to terminal power management at the Lua level. 18 Message This service is responsible for building and delivering both to-and from-mobile messages to the appropriate service. 19 Report Basic event or status reports either prescheduled or on demand (polled). 20 Position This service provides access to positioning information, either from the internal GPS or external high precision GPS. 21 Geofence The geofence service provides the ability to define geographical regions based on circles or polygons, as well as reporting entry and exit from these regions. 22 Serial Manages communication through the terminal's various serial ports (that is RS-232 and RS-485), including their configuration and status. 23 Log Stores data in nonvolatile storage. The data can be application data that can be retrieved at later date, or diagnostic information for troubleshooting. This service also provides auto upload capabilities. 24 File System Provides an interface for the file system that is in the application firmware. 25 External Configures and reports the status of the terminal's general purpose I/O. In addition, it is used to Input/Output monitor the internal temperature . Alarms can be configured if thresholds are exceeded. 26 Shell Provides access to a command-line interface (CLI) over the serial port. It also provides the ability to execute the same commands over-the-air and allows you to change the access level of the shell. 27 IDP Provides access to some of the functionality offered by the IDP modem. 28 Reserved .29 Cell Provides support for JSON encoding of messages, allows configuration and monitoring of the module; and also provides a plugin to the message service allowing it to send/receive messages over cellular (satellite-cellular terminals). 30 Reserved .31 Reserved .32 Campaign A mandatory service that must be running to support software over-the-air updates. 33 Internet Protocol Allows terminals to take advantage of protocols and their associated features for the development of (ip) IP enabled Lua applications. 34 Accelerometer Defines the global configuration of the accelerometer. APPENDIX B ISATDATA PRO MESSAGE STRUCTURE The ST terminal packs messages in a bit-efficient binary format to minimize payload space. The structure is represented by the following Backus-Naur syntax diagram. Each line defines a logical element, represented by a regular rectangle. Actual bits that are carried in the message payload are represented by rounded rectangles. The variable ÒXÓ denotes a size that is dictated by the message meta-data. Figure 6: Message Structure Syntax Diagram * When designing a property or message field with the type Unsigned Int, the Lua restriction is 31 bits. Refer to the Unsigned Integer section in [T404]. APPENDIX C POSTED EVENTS SUMMARY System (SIN 16) Source: svc.system (System Service Table) Power (SIN 17) Source: svc.power (Power Service Table) Source: _POWER (string) Message (SIN 18) Source: Handle from register() Position (SIN 20) Source: svc.position (Position Service Table) Geofence (SIN 21) Source: svc.geofence (Geofence Service Table) ALARM This event is posted when a fence entry or exit is detected, or when a fence status changes from undefined to inside/outside, regardless of the fence's alarm condition setting, and regardless of the sendAlarm and logAlarm property values. ALARMS This event is posted when one or more fence entry or exit events are detected, or when a fence status changes from undefined to inside/outside, regardless of the fence's alarm condition setting, and regardless of the sendAlarm and logAlarm property values. FENCE_CHECK_DONE This event is posted when the fence check completes and the checkDoneEvents (PIN 23) property is true. HYST_CHECK_DONE This event is posted when the hysteresis check completes and the checkDoneEvents (PIN 23) property is true. Serial (SIN 22) Source: <handle>:source() BREAK  Event posted that a break condition has been detected on the RS-232 port.  BYTE  Event that is posted when a byte has been received by the RS-232 UART.  FRAME  Event posted that a protocol frame of binary data has been received by the RS-232  UART.  LINE  Event posted that a line has been received by the RS-232 UART.  Source: Ò_RS232MAINÓ DTECONNECTED  Event posted that a DTE device has been either connected or disconnected from the RS-232 port.  Source: Ò_RS232AUXÓ External I/O (SIN 25) Source: svc.eio (EIO Service Table) ANALOG_ALARM This event is posted every time an analog alarm is triggered. DIGITAL_ALARM This event is posted every time a digital alarm is triggered. FULL_REPORT This event sends a list containing the last pulse counter sampling values with the exact sampling interval in milliseconds. THRESHOLD_CROSSING This event notifies the application that the sampling interval crossed a user specified threshold. IDP (SIN 27) Source: svc.idp (IDP Service Table) ANTENNA_CUT This event is posted when the antenna cut status changes. EVENT_UPDATE This event is posted whenever a registered event is updated. JAMMING_UPDATE This event is posted when the GPS jamming status changes. MODEM_EVENT_COMMS This event is posted when there is a change in the communications status. MODEM_EVENT_REGISTERED This event is posted when an indication is received that the satellite modem has registered with the network. MODEM_EVENT_RESET This event is posted when a reset indication is received from the modem. SAT_STATUS This event is posted when the value of either the satStat or satFlags property changes. Cellular (SIN 29) Source svc.cell (Cellular Service Table) Internet Protocol (SIN 33) Source <channel> handle returned by channelAllocate() Source svc.ip (IP Service Table) Accelerometer (SIN 34) Source Ò_ACCELÓ (string) AUTO_ORIENTATION_STATUS This event is posted when automatic orientation detection is completed, aborted, or failed. CAPTURE_STOPPED This event is posted when the last segment is full and wrap mode has not been enabled or if the sample capture is stopped asynchronously at the end of the current segment. HW_COMPENSATION_DONE This event is posted when the hardware offset compensation has been completed. MOTION_START This event is posted by the MOTION detector when start of motion is detected. MOTION_STOP This event is posted by the MOTION detector when motion is no longer detected. SAMPLE This event is posted when accelerometer sample is available following a call to the requestSample() function. SEGMENT_FULL This event is posted when a segment is full and the segment full event has been enabled for the segment. SHOCK_START This event is posted by the SHOCK detector when the absolute acceleration along the configured axes exceeds the threshold parameter for the minimum time specified by the minTime parameter. SHOCK_STOP This event is posted by the SHOCK detector after a SHOCK_STOP Event if the maxTime parameter is nonzero and either the acceleration along the axis is no longer above the threshold parameter or the timeout has occurred. Bluetooth (SIN 35) Source Ò_BT_SYSÓ (string) Source createScanner() Source creteShortMessageHandle APPENDIX D IP SERVICE APPLICATION EXAMPLES TCP/UDP (session) Use a TCP channel in session mode, with data going over satellite. The same structure can be used with UDP. local tcpH, err = svc.ip.channelAllocate(svc.ip.Channel.TCP, {host=Õswlab.skywave.comÕ, port=55555, timeout=0}, svc.ip.Routing.SAT_ONLY) if not tcpH then print(ÔError creating channel: Ô, err) else local res res, err = tcpH:open() if not res then print(ÔError opening channel: Ô, err) else local disposed = false local tcpQ = sched.createEventQ(1, tcpH) for i = 1, 3 do res, err = tcpH:send(Ôsome dataÕ) if not res then print(ÔError sending data: Ô, err) else local q, ev, args = tcpQ:wait(someTimeoutValue) if q == tcpQ then if ev == ÔDATAÕ then print(ÔGot data: Ô, data) elseif ev == ÔDISPOSEÕ then print(ÔChannel disposed: Ô, args.errorCode) disposed = true break end else print(ÔNo response receivedÕ) break end end end if not disposed then tcpH:dispose() end tcpQ:destroy() end end TCP/UDP (Transaction) Use a UDP channel in transaction mode, with data going over satellite. The same structure can be used with TCP. local udpH, err = svc.ip.channelAllocate(svc.ip.Channel.UDP, {host=Õswlab.skywave.comÕ, port=55555, timeout=15}, svc.ip.Routing.SAT_ONLY) if not udpH then print(ÔError creating channel: Ô, err) else local res res, err = udpH:open() if not res then print(ÔError opening channel: Ô, err) else local disposed = false local udpQ = sched.createEventQ(1, udpH) res, err = tcpH:send(Ôsome dataÕ) if not res then print(ÔError sending data: Ô, err) else udpH:close() while true do local q, ev, args = udpQ:wait(someTimeoutValue) if q == udpQ then if ev == ÔDATAÕ then print(ÔGot data: Ô, data) elseif ev == ÔUDP_COMPLETEÕ then print(ÔTransaction completeÕ) break elseif ev == ÔDISPOSEÕ then print(ÔChannel disposed: Ô, args.errorCode) disposed = true break end else print(ÔNo response receivedÕ) break end end end if not disposed then udpH:dispose() end udpQ:destroy() end end FTP DEL To perform an FTP DEL operation, delete the remote file. local ftpH, err = svc.ip.channelAllocate(svc.ip.Channel.FTP,local ftpH, err = svc.ip.channelAllocate(svc.ip.Channel.FTP,{host=Õftp.skywave.comÕ, operation=svc.ip.FtpOp.DEL,login=Õbob_bÕ password=Õ****Õ, remotePath=Õ/test.txtÕ},svc.ip.Routing.CELL_SAT) if not ftpH then print(ÔError creating channel: Ô, err) else local res local ftpQ = sched.createEventQ(5, ftpH) res, err = ftpH:open() if not res then print(ÔError opening channel: Ô, err) else local disposed = false while true do local q, ev, args = ftpQ:wait(someTimeoutValue) if q == ftpQ then if ev == ÔFTP_COMPLETEÕ then print(ÔTransaction completeÕ) break elseif ev == ÔDISPOSEÕ then print(ÔChannel disposed: Ô, args.errorCode) disposed = true break end else print(ÔNo response receivedÕ) break end end if not disposed then ftpH:dispose() end ftpQ:destroy() end end FTP DIR To perform an FTP DIR operation, retrieve the list of files in the supplied remote path. local ftpH, err = svc.ip.channelAllocate(svc.ip.Channel.FTP,{host=Õftp.skywave.comÕ, operation=svc.ip.FtpOp.DIR,login=Õbob_bÕ password=Õ****Õ, remotePath=Õ/Õ},svc.ip.Routing.CELL_SAT) if not ftpH then print(ÔError creating channel: Ô, err) else local res local ftpQ = sched.createEventQ(5, ftpH) local f = io.open(Ô/test.txtÕ, ÔwÕ) res, err = ftpH:open() if not res then print(ÔError opening channel: Ô, err) else local disposed = false while true do local q, ev, args = ftpQ:wait(someTimeoutValue) if q == ftpQ then if ev == ÔDATAÕ then f:write(data) elseif ev == ÔFTP_COMPLETEÕ then print(ÔTransaction completeÕ) break elseif ev == ÔDISPOSEÕ then print(ÔChannel disposed: Ô, args.errorCode) disposed = true break end else print(ÔNo response receivedÕ) break end end if not disposed then ftpH:dispose() end ftpQ:destroy() end end FTP GET Perform an FTP GET operation, preferably over cellular with fallback to satellite. local ftpH, err = svc.ip.channelAllocate(svc.ip.Channel.FTP, {host=Õftp.skywave.comÕ, operation=svc.ip.FtpOp.GET, login=Õbob_bÕ password=Õ****Õ, remotePath=Õtest.txtÕ}, svc.ip.Routing.CELL_SAT) if not ftpH then print(ÔError creating channel: Ô, err) else local res local ftpQ = sched.createEventQ(5, ftpH) local f = io.open(Ô/test.txtÕ, ÔwÕ) res, err = ftpH:open() if not res then print(ÔError opening channel: Ô, err) else local disposed = false while true do local q, ev, args = ftpQ:wait(someTimeoutValue) if q == ftpQ then if ev == ÔDATAÕ then f:write(data) elseif ev == ÔFTP_COMPLETEÕ then print(ÔTransaction completeÕ) break elseif ev == ÔDISPOSEÕ then print(ÔChannel disposed: Ô, args.errorCode) disposed = true break end else print(ÔNo response receivedÕ) break end end if not disposed then ftpH:dispose() end ftpQ:destroy() end end FTP PUT Perform an FTP PUT operation, with data going over satellite and assumes that the file size is fairly small. Similar code can be used to send email messages, via NSMTP. local ftpH, err = svc.ip.channelAllocate(svc.ip.Channel.FTP, {host=Õftp.skywave.comÕ, operation=svc.ip.FtpOp.PUT, login=Õdan_zÕ password=Õ****Õ, remotePath=Õtest.txtÕ}, svc.ip.Routing.SAT_ONLY) if not ftpH then print(ÔError creating channel: Ô, err) else local res local ftpQ = sched.createEventQ(5, ftpH) local f = io.open(Ô/test.txtÕ, ÔrÕ) res, err = ftpH:open() if not res then print(ÔError opening channel: Ô, err) else local disposed = false res, err = ftpH:send(f:read(Ô*allÕ)) if not res then print(ÔError sending data: Ô, err) else ftpH:close() while true do local q, ev, args = ftpQ:wait(someTimeoutValue) if q == ftpQ then if ev == ÔFTP_COMPLETEÕ then print(ÔTransaction completeÕ) break elseif ev == ÔDISPOSEÕ then print(ÔChannel disposed: Ô, args.errorCode) disposed = true break end else print(ÔNo response receivedÕ) break end end end if not disposed then ftpH:dispose() end ftpQ:destroy() end end SMTP Examples Basic SMTP message: \0somebody@somewhere.com\0\r\n\r\nThis is the message body. Headers supplied 01234567SKY1234\0somebody@somewhere.com\0\r\nTo: somebody@somewhere.com\r\nSubject: Example message\r\n\r\nThis is the message body. Note: Headers must comply with the email specification or your message can be rejected by the SMTP server. To-mobile messages contain all the headers in a raw format followed by the body. Memory Management When dealing with large transactions such as FTP, applications must be aware of the memory impact on the ST product. The ip service caches data until it can be sent, so if the rate at which data is queued exceeds the rate at which the service is able to send it, memory usage increases. The following example shows how to control memory consumption by limiting the rate at which the send() method is called and by periodically running garbage collection. By pausing between invocations of send(), the code is system-friendly because other applications are allowed to run more frequently and for longer periods of time. local function ftpTransfer(routing, args, file) local ftpH ftpH, ftpErr = channelAllocate(Channel.FTP, args, routing) local ioCount = 0 if ftpH then local disposed = false local ftpQ = sched.createEventQ(10, ftpH) local res res, ftpErr = ftpH:open() if res then local usingCell = ftpH:usingCell() if args.operation == FtpOp.PUT then repeat local data = file:read(6000) if data then ftpSize = ftpSize + #data ftpH:send(data) ioCount = ioCount + 1 if ioCount == usingCell and 10 or 1 then if usingCell then sched.delay(5) collectgarbage('step') ioCount = 0 else sched.delay(3000) end end end until data == nil end ftpH:close() while true do local q, ev, args = ftpQ:wait(36000) if q == ftpQ then if ev == 'DATA' then ftpSize = ftpSize + #args file:write(args) ioCount = ioCount + 1 if usingCell and ioCount == 10 then sched.delay(5) collectgarbage('step') ioCount = 0 end elseif ev == 'FTP_COMPLETE' then ftpErr = not args.success and args.error or nil break elseif ev == 'DISPOSE' then ftpErr = string.format('Channel disposed: error code %d', args.error) disposed = true break end else ftpErr = 'Operation timed out' break end end end if not disposed then ftpH:dispose() end end file:close() end APPENDIX E ACCELEROMETER ORIENTATION EXAMPLE Table 27: ST Terminal Orientation Mapping Example (SIN 34) Position Orientation forwardDirection upwardDirection PIN 20 PIN 21 top (Z) facing up -.1 YPos (2) ZPos (4) ST 61xx ST 61xx Bottom Connector ST 6000 ST 9100 2 XPos (0) ZPos (4) ST 61xx ST 61xx Bottom Connector Logo facing Right ST 6000 ST 9100 Position Orientation forwardDirection upwardDirection PIN 20 PIN 21 3 YNeg (3) ZPos (4) ST 61xx facing left ST 61xx Bottom Connector ST 6000 ST 9100 4 Main connector XNeg (1) ZPos (4) ST 61xx ST 61xx Bottom Connector Logo facing left ST 6000 ST 9100 APPENDIX F SUPPORTED 1-WIRE FAMILIES This feature is supported on some ST models. APPENDIX G 1-WIRE SAMPLE CODE --Service: One Wire interface example --Created: 2014-6-25 -. -.-. Copyright (c) 2014 This material is Confidential and sha ll not be disclosed  -. to a third party without the written  consent.  --In this demo, commands can be used to test most 1-Wire devices. --We also test the following two devices(iButtons) --DS1920 temperature sensor with alarm trips (DS18S20 IC) --DS1972 1024 bit, 1-Wire EEPROM module(..., package.seeall) --Version information (required) _VERSION = "1.0.0" --Table of sub-commands within the 'onewire' CLI command local OneWireCmdTable = {} --Module Globals local onewire = sys.onewire local owHdl local overdrive = false --Device Commands and defines --DS1972 1024bit EEPROM local DS1972_FAMILY_CODE = 0x2D --DS1972 Commands local DS1972_WRITE_SCRATCHPAD = 0x0F local DS1972_READ_SCRATCHPAD = 0xAA local DS1972_COPY_SCRATCHPAD = 0x55 local DS1972_READ_MEMORY = 0xF0 --DS1920 Temperature sensor local DS1920_FAMILY_CODE  =  0x10  local DS1920_SCRATCHPAD_SIZE =  8  --DS1920 Commands  local DS1920_WRITE_SCRATCHPAD = 0x4E local DS1920_COPY_SCRATCHPAD = 0x48 local DS1920_READ_SCRATCHPAD = 0xBE local DS1920_CONVERT_TEMPERATURE = 0x44 local err_ds1920 = "Not a DS1920 family temperature sensor\n" local err_ds1972 = "Not a DS1972 1024 bit EEPROM\n" --FUNCTION: checkhdl() --DESCRIPTION: Check if 1-Wire is connected --ARGUMENTS: none --RETURNS: 1, valid handle. nil, no handle function checkhdl() if (owHdl == nil) then print(_NAME, ":Bus is not opened") return nil else return 1 end end --FUNCTION: devID() --DESCRIPTION: Get device ID parameter --ARGUMENTS: parm --RETURNS: id buffer or nil function devID(idParm) if string.len(idParm) < 16 then print("Device ID length error\n") return nil end local idbuf="" for i=1,16,2 do idbuf = idbuf .. string.char(tonumber(idParm:sub(i,i+1),16)) end return idbuf end --FUNCTION: onTermination() --DESCRIPTION: Termination handler that does clean ups -. -. ARGUMENTS:  none  -. -. RETURNS:  none  -. function onTermination() --Disconnect 1-Wire if checkhdl() then print(_NAME, ":terminating Service") owHdl:disconnect() owHdl = nil end end --FUNCTION: OneWireSearchCmd() --DESCRIPTION: Search all devices on bus --ARGUMENTS: none --RETURNS: none local function OneWireSearchCmd(args) if checkhdl() then local idTbl,errStr = owHdl:search() if (idTbl) then print("Device list:") for _,id in ipairs(idTbl) do print(toHex(id)); end end if (errStr) then print(errStr) end end end --FUNCTION: OneWireAlarmCmd() --DESCRIPTION: Search Alarmed devices on bus -. -. ARGUMENTS:  none  -. -. RETURNS:  none  -. local function OneWireAlarmCmd(args) if checkhdl() then local idTbl,errStr = owHdl:search(true) if (idTbl) then print("Alarmed Device:") for _,id in ipairs(idTbl) do print(toHex(id)); end end if (errStr) then print(errStr) end end end --FUNCTION: OneWireReadRomCmd() --DESCRIPTION: Read ROM code from single drop bus -.-. ARGUMENTS:  crc error if multidrop bus none  -. -. RETURNS:  none  -. local function OneWireReadRomCmd(args) if checkhdl() then --Read Device Serial ID from single drop bus. --Reset + Read ROM + 8 bytes Rom code local romCode,errStr = owHdl:readRom() --Print device ID if (romCode) then print("Device ID:") print(toHex(romCode)); else print(errStr) end end end --FUNCTION: OneWireSkipRomCmd() --DESCRIPTION: Send skip search command --ARGUMENTS: none --RETURNS: none local function OneWireSkipRomCmd(args) if checkhdl() then --Reset + Skip ROM print("Skip ROM, adding device command...") owHdl:skipRom() end end --FUNCTION: OneWiresMatchRomCmd() --DESCRIPTION: send Match Rom command -. -. ARGUMENTS: ROM code is in ascii  -. -. RETURNS:  none  -. local function OneWireMatchRomCmd(args) if checkhdl() then if #args < 1 then print("Usage: onewire match [device ID]\n") return end local idbuf = devID(args[1]) if idbuf == nil then return end --Reset + Match ROM print("Match ROM:", args[1]," adding device command...") local ok,errStr=owHdl:matchRom(idbuf) if not ok then print(errStr) end end end --FUNCTION: OneWireWriteByteCmd() --DESCRIPTION: Send a byte to bus -. -. ARGUMENTS: byte to send  -. -. RETURNS:  none  -. local function OneWireWriteByteCmd(args) if checkhdl() then --Reset + Skip ROM print("write:",args[1]) local ok,errStr = owHdl:writeByte(tonumber(args[1])) if not ok then print(errStr) end end end --FUNCTION: OneWireWriteBytePowerCmd() --DESCRIPTION: Send a byte and pull up bus with strong power --ARGUMENTS: byte to send --RETURNS: none local function OneWireWriteBytePowerCmd(args) if checkhdl() then --Reset + Skip ROM print("write and strong power:",args[1]) local ok,errStr = owHdl:writeBytePower(tonumber(args[1])) if not ok then print(errStr) end end end --FUNCTION: OneWireReadByteCmd() --DESCRIPTION: Read a byte from bus -. -. ARGUMENTS:  none  -. -. RETURNS:  none  -. local function OneWireReadByteCmd(args) if checkhdl() then local rbyte,errStr = owHdl:readByte() if (errStr) then print(errStr) else printf("read:%02X\n", rbyte) end end end --FUNCTION: OneWireSetDS1920Cmd() --DESCRIPTION: Set DS1920 thresholds --ARGUMENTS: high threshold, low threshold in degree C --RETURNS: none local function OneWireSetDS1920Cmd(args) if checkhdl() then if #args < 3 then print("Usage: onewire threshold [device ID] [high degree C] [low degree C]\n") return end local idbuf = devID(args[1]) if idbuf == nil then return end local highc = tonumber(args[2]) local lowc = tonumber(args[3]) if (idbuf:byte(8) ~= DS1920_FAMILY_CODE) then print(err_ds1920) return end --Reset + Match ROM print("Sensor ID:", args[1]," high:",highc," low:",lowc) local ok,errStr=owHdl:matchRom(idbuf) if not ok then print(errStr) return end if highc < 0 then highc = 256 + highc end if lowc < 0 then lowc = 256 + lowc end --Write scratchpad local buf= string.char(DS1920_WRITE_SCRATCHPAD) .. string.char(highc) .. string.char(lowc) --Set new thresholds owHdl:writeBlock(buf) --Start a new sequence, save new thresholds to EEPROM. owHdl:matchRom(idbuf) --Send Copy command and enable strong pull-up for 10 ms by spec owHdl:writeBytePower(DS1920_COPY_SCRATCHPAD,10) --transaction is done owHdl:reset() end end --FUNCTION: OneWireTempDS1920Cmd() --DESCRIPTION: DS1920 temperature conversion -. -. ARGUMENTS:  none  -. -. RETURNS:  none  -. local function OneWireTempDS1920Cmd(args) if checkhdl() then if #args < 1 then print("Usage: onewire temperature [device ID] \n") return end local idbuf = devID(args[1]) if idbuf == nil then return end if (idbuf:byte(8) ~= DS1920_FAMILY_CODE) then print(err_ds1920) return end --Reset + SkipROM, for all DS1920 on the bus local ok,errStr=owHdl:skipRom() if not ok then print(errStr) return end --Temperature conversion --Strong Pull-up for 750ms defined by spec owHdl:writeBytePower(DS1920_CONVERT_TEMPERATURE,750) --Read Scratchpad to check temperature reading --Reset + Match ROM local ok,errStr=owHdl:matchRom(idbuf) if not ok then print(errStr) return end owHdl:writeByte(DS1920_READ_SCRATCHPAD) local rbuf = owHdl:readBlock(DS1920_SCRATCHPAD_SIZE) local rcrc8 = owHdl:readByte() owHdl:reset() --Check CRC8 local ccrc8 = onewire:crc8(rbuf) if (ccrc8 == rcrc8) then --CRC8 calculation matched, get temperature reading local degree = bit32.bor( bit32.lshift(rbuf:byte(2),8), rbuf:byte(1)) print("\n data:",toHex(rbuf)," temperature:", degree * 0.5) else print('DS1920 data page crc8 error\n') end end end --FUNCTION: OneWireWriteDS1972Cmd() --DESCRIPTION: Write a string(8 bytes) to DS1972 -. -. ARGUMENTS:  a  string  -. -. RETURNS:  none  -. local function OneWireWriteDS1972Cmd(args) if checkhdl() then if #args < 3 then print("Usage: onewire store [device ID] [address(0-127)%8] [a 8 string(8 byte long)]\n") return end local idbuf = devID(args[1]) if idbuf == nil then return end address = bit32.band(tonumber(args[2]),0x78) local wstr = args[3] if wstr:len() ~=8 then print("String length shall be 8\n") return end if (idbuf:byte(8) ~= DS1972_FAMILY_CODE) then print(err_ds1972) return end --Scratchpad data size shall be: 8 local wbuf=string.char(DS1972_WRITE_SCRATCHPAD) .. string.char(address).. '\000' wbuf = wbuf .. wstr --Calculate CRC16 local wcrc16 = onewire:crc16(wbuf) --Reset + Match ROM print("Device ID:", args[1]," address:",address," string:",toHex(wstr)) local ok,errStr=owHdl:matchRom(idbuf,overdrive) if not ok then print(errStr) return end --Write a string of maximum 8 bytes owHdl:writeBlock(wbuf) --Check CRC16, read inverted CRC16 local temp = owHdl:readBlock(2) local rcrc16 = bit32.bor( bit32.lshift(temp:byte(2),8), temp:byte(1)) if (wcrc16 + rcrc16 == 0xffff) then --CRC16 calculation matched --Copy scratchpad to EEPROM ok,errStr = owHdl:matchRom(idbuf,overdrive) if not ok then print(errStr) return end owHdl:writeByte(DS1972_COPY_SCRATCHPAD) --Send Authorization code --End offset:7 owHdl:writeByte(address) owHdl:writeByte(0) owHdl:writeByte(0x7,10) --delay 10 ms --Check AA state. local status = owHdl:readByte() if (status == 0xAA) then print('Write EEPROM OK\n') else print('Write EEPROM Failed\n', status, " ", address) end else print('Write CRC16 error\n') end end end --FUNCTION: OneWireReadDS1972Cmd() --DESCRIPTION: Dump DS1972 EEPROM memory (128 Bytes, 1024 bit) -. -. ARGUMENTS:  none  -. -. RETURNS:  none  -. local function OneWireReadDS1972Cmd(args) if checkhdl() then if #args < 1 then print("Usage: onewire dump [device ID]\n") return end local idbuf = devID(args[1]) if idbuf == nil then return end if (idbuf:byte(8) ~= DS1972_FAMILY_CODE) then print(err_ds1972) return end --Reset + Match ROM local ok,errStr=owHdl:matchRom(idbuf,overdrive) if not ok then print(errStr) return end --Setup read memory command and address 0 local buf= string.char(DS1972_READ_MEMORY) .. '\000\000' --Send command to read memory from address 0 owHdl:writeBlock(buf) --Read 128 bytes local rbuf,errStr = owHdl:readBlock(128) --Transaction Done, owHdl:reset() if (rbuf) then print("Memory data:") print(toHex(rbuf)); --print(rbuf); else print( errStr) end end end --FUNCTION: OneWireOdWriteDS1972Cmd() --DESCRIPTION: Write a string(8 bytes) to DS1972, overdrive speed with shorter cable -. -. ARGUMENTS:  a  string  -. -. RETURNS:  none  -. local function OneWireOdWriteDS1972Cmd(args) if checkhdl() then if #args < 3 then print("Usage: onewire odstore [device ID] [address(0-127)%8] [a 8 byte long string]\n") return end overdrive = true OneWireWriteDS1972Cmd(args) overdrive = false end end --FUNCTION: OneWireOdReadDS1972Cmd() --DESCRIPTION: Dump DS1972 EEPROM memory (128 Bytes, 1024 bit),overdrive speed with shorter cable -. -. ARGUMENTS:  none  -. -. RETURNS:  none  -. local function OneWireOdReadDS1972Cmd(args) if checkhdl() then if #args < 1 then print("Usage: onewire oddump [device ID]\n") return end overdrive = true OneWireReadDS1972Cmd(args) overdrive = false end end --FUNCTION: OneWireConnectCmd() --DESCRIPTION: Turn on 1-Wire bus --ARGUMENTS: none --RETURNS: none local function OneWireConnectCmd(args) local errMsg --Power on one wire bus owHdl, errMsg= onewire.connect() if (owHdl) then --success print(_NAME,": 1-Wire bus is connected") else --opened by others print(_NAME,":",errMsg) end end --FUNCTION: OneWireDisonnectCmd() --DESCRIPTION: Turn off 1-Wire bus --ARGUMENTS: none --RETURNS: none local function OneWireDisconnectCmd(args) if checkhdl() then owHdl:disconnect() owHdl = nil print(_NAME,":1-Wire bus is disconnected") end end --FUNCTION: OneWireCmd() --DESCRIPTION: This is the main CLI command, which is used to invoke -. sub-commands.  -. -. ARGUMENTS: args  the arguments given on the command line  -. -. RETURNS: none  -. local function OneWireCmd(args) if #args > 0 then local cmdStr = table.remove(args, 1) local cmd = OneWireCmdTable[cmdStr] if cmd then cmd[1](args) else printf("*** error: Unknown 1-Wire test command '%s'\n", cmdStr) end else print("*** error: Missing command\n") end end --FUNCTION: entry() --DESCRIPTION: Entry point for the service thread. -. -. ARGUMENTS:  none  -. -. RETURNS:  none  -. function entry() local errMsg if (onewire) then --Checking if 1-Wire is supported print(_NAME, ":service started") end sched.delay(-1) end --FUNCTION: init() --DESCRIPTION: Initialize service resources. --ARGUMENTS: none --RETURNS: none function init() --Register the CLI commands if (onewire) then --Checking if One Wire is supported by HW svc.shell.register("onewire", OneWireCmd, "One wire test command") OneWireCmdTable.connect = {OneWireConnectCmd, "Connect to 1-Wire bus"} OneWireCmdTable.search = {OneWireSearchCmd, "Search devices"} OneWireCmdTable.alarm = {OneWireAlarmCmd, "Search alarmed devices"} OneWireCmdTable.readrom = {OneWireReadRomCmd, "Read single drop device code"} OneWireCmdTable.skiprom = {OneWireSkipRomCmd, "Send skip rom sequence"} OneWireCmdTable.matchrom = {OneWireMatchRomCmd, "Send skip rom sequence"} OneWireCmdTable.writebyte = {OneWireWriteByteCmd, "Write a byte to 1-Wire bus"} OneWireCmdTable.bytepower = {OneWireWriteBytePowerCmd, "Write a byte and strong power"} OneWireCmdTable.readbyte = {OneWireReadByteCmd, "Read a byte from 1-Wire bus"} OneWireCmdTable.threshold = {OneWireSetDS1920Cmd, "Set alarm thresholds to first DS1920"} OneWireCmdTable.temperature = {OneWireTempDS1920Cmd, "Read temperature from first DS1920"} OneWireCmdTable.store = {OneWireWriteDS1972Cmd, "Store a 8 bytes string to DS1972"} OneWireCmdTable.dump = {OneWireReadDS1972Cmd, "Dump DS1972 memory"} OneWireCmdTable.odstore = {OneWireOdWriteDS1972Cmd, "Store(Overdrive) a 8 bytes string to DS1972"} OneWireCmdTable.oddump = {OneWireOdReadDS1972Cmd, "Dump(Overdrive) DS1972 memory"} OneWireCmdTable.disconnect = {OneWireDisconnectCmd, "Disconnect 1-Wire bus"} OneWireCmdTable.help = {function() svc.shell.private._dumpHelp (OneWireCmdTable) end, "Display this help"} OneWireCmdTable["?"] = OneWireCmdTable.help end end APPENDIX H 1-WIRE SUPPORTED DEVICES These devices are supported on some ST models. Supported Alarm Search Devices ¥ DS1920, DS18S20 ¥ DS28E04 ¥ DS2450 ¥ DS1921G, DS1921H, DS1921Z ¥ DS1822 ¥ DS18B20 ¥ DS2408 ¥ DS1825 Supported Overdrive Speed Devices ¥ DS28E04 ¥ DS2450 ¥ DS1921G, DS1921H, DS1921Z ¥ DS1973, DS2415 ¥ DS2408 ¥ DS1972, DS2431 ¥ DS1977 (read-only) ¥ DS2413 ¥ DS1922T, DS1922L, DS1922E, DS1923, DS2422 ¥ DS28EA00 ¥ DS28EC20 APPENDIX I 1-WIRE SUPPORTED STRONG PULL-UP DEVICE ¥ DS18B20 ¥ DS1920,DS18S20 ¥ DS1971 ¥ DS1972,DS2431 ¥ DS1973,DS2433 ¥ DS1977 ¥ DS2450 ¥ DS28EA20 ¥ DS28EC20 APPENDIX J J1979 INTRODUCTION Available on ST models with CAN bus. OBD-II Most cars and light trucks on the road today have On-Board Diagnostic (OBD) systems. OBD-II, which was introduced in the mid-1990s, provides almost complete engine control. OBD-II also monitors parts of the chassis, body, and accessory devices, as well as the diagnostic control network of the car. OBD was designed primarily to meet the Environmental Protection Agency (EPA) emission standards. The EPA adapted most of their standards from the on-board diagnostic programs and recommendations of the Society of Automotive Engineers (SAE). OBD-II is an expanded set of standards and practices that was developed by the SAE, and adopted by the EPA and the California Air Resources Board (CARB) for implementation by January 1, 1996. J1979 and Related Protocols SAE J1979 is the same as the ISO 15031-5 standard, which defines the data reporting requirements of the OBD-II regulations. The standard specifies message formats for request and response messages, timing requirements, behavior of both the vehicle and external test equipment if data is not available, and a set of diagnostic services. ISO 15765-4 is the protocol for diagnostics on Controller Area Networks (CAN). CAN is the newest protocol added to the OBD-II specification, and it is mandated for all 2008 and newer model years. The protocol supports CAN 500k and 250k baud rates, and 11-bit CAN 2.0A and 29-bit CAN2.0B IDs. Terminals with CAN bus can receive and transmit 11-bit and 29-bit CAN IDs. ECU Addressing Table 28 and Table 29 show the CAN IDs that are used for request and response messages. The CAN IDs are associated with each communicating ECU on the CAN bus. The 29-bit CAN ID defines a fixed addressing format. Table 29: 29-bit OBD CAN IDs Request Response Comments (to ECU) (from ECU) Functional Responses from the matched ECU. 33 is the functional address (broadcast) Address Physical ECU 18DAxxF1 18DAF1xx Engine Control Module (ECM)/Powertrain Control The physical ECU address XX in Address the CAN ID must be unique in each vehicle. 10 Ð ECM (ECU #1) 18 Ð TCM (ECU #2) 28 Ð ABS (ECU #3) ECU Address: 10,18,28,... Service ID and Parameter ID J1979 defines service request IDs to ECUs as shown in Table 30. Each service defines a set of parameter request IDs (PID). Table 31 shows an example of some common PIDs. Refer to ISO 15031-5 for SID and PID definitions. Table 31: Example of Frequently used PIDs Message Format Response Bits 7-4 Bits 3-0 Single Frame 0x0 Data Len (max 4095) First Frame Data Len (max 4095) 6 data bytes Consecutive Frame Seq Number 1 to 7 data bytes Flow Control (to ECU, after the first frame) 0x3 Flow Status Block Size Separation Not used 0 Ð CTS 0-255 frame Time 1 Ð WT 0-127 ms 1 Ð OV APPENDIX K J1979 RESPONSE MESSAGE Available on ST models with CAN bus. The tables below provide examples of response message formats by data types. Table 34: 11 Bit CAN ID Response Message Example (Service 09, PID 02) Data Byte Value (hex) Description #1 Response SID (40 + request SID). Vehicle information. #2 Info type, Get VIN (request PID) #3 Number of data items:01 #4 1st ASCII character of VIN:Õ1Õ #5 2st ASCII character of VIN:ÕGÕ #6 3st ASCII character of VIN:Õ1Õ #7 4st ASCII character of VIN:ÕJÕ #8 5st ASCII character of VIN:ÕCÕ #9 6st ASCII character of VIN:Õ5Õ #10 7st ASCII character of VIN:Õ4Õ #11 8st ASCII character of VIN:Õ4Õ #12 9st ASCII character of VIN:Õ4Õ #13 10st ASCII character of VIN:ÕRÕ #14 11st ASCII character of VIN:Õ7Õ #15 12st ASCII character of VIN:Õ2Õ #16 13st ASCII character of VIN:Õ5Õ #17 14st ASCII character of VIN:Õ2Õ #18 15st ASCII character of VIN:Õ3Õ #19 16st ASCII character of VIN:Õ6Õ #20 37 17st ASCII character of VIN:Õ7Õ Response ECU: 7E8. From ECU#1 ECM (7E0 plus 8) Response ECU: 18DAF118. From ECU#2 TCM (requested 18DA18F1) APPENDIX L GATT CLIENT ERROR CODE These codes are only for devices that use the Bluetooth service. The error codes returned from GATT client functions and the Bluetooth stack come from various layers and overlap other error codes. To address this, error codes have been broken into five categories as shown in Table 36 Table 37 describes the most likely / common error codes that might be encountered.
