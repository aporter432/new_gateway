LSF Developer Guide (FW v4.x) T404, Version 03 Sep 2020 © ORBCOMM® LEGAL NOTICE This documentation is owned by ORBCOMM® and protected by applicable copyright laws and international treaty provisions. Other copyrighted names used are the property of their respective owners. Therefore, you must treat this documentation like any other copyrighted material. This publication, or any part thereof, may not be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording, storage in an information retrieval system, or otherwise, without prior written permission by ORBCOMM, Inc. 395 W Passaic Street, Suite 325, Rochelle Park, NJ 07662 USA Phone 703-433-6325. The information in this document is for information purposes only and contains technical information and descriptions of the ORBCOMM product(s) and is subject to change without notice. No warranty or representation, express or implied, is made with respect to its contents. TRADEMARK NOTICE The ORBCOMM name and the ORBCOMM logo are registered trademarks of ORBCOMM. INMARSAT, the Inmarsat logo and IsatData Pro are trademarks of Inmarsat used under license by SkyWave (an ORBCOMM company). Inmarsat is not responsible for the operation and regulatory compliance of the products and services referred to in this document that connect to the Inmarsat system. The Bluetooth® word mark and logos are registered trademarks owned by the Bluetooth SIG, Inc. EXPORT CONTROL STATEMENT The contents of this document, in whole or in part, shall not be exported from the United States, which export shall include, but not be limited to, transmittal to any non-U.S. citizen wherever said person is located, except in accordance with all United States laws and regulations relating to exports and to all administrative acts of the U.S. Government pursuant to such laws and regulations. Diversion, re-export or transshipment of the contents of this document, in whole or in part, contrary to U.S. law is also strictly prohibited. CONTACT INFORMATION Visit ORBCOMM Online www.ORBCOMM.com Contact Customer Support support@skywave.com +1.613.836.2222 Headquarters 395 W Passaic Street, Suite 325 Rochelle Park, NJ 07662 USA Tel: +1-703-433-6300 Fax: 1-703-433-6400 Email: sales@orbcomm.com TABLE OF CONTENTS Legal Notice 2 Trademark Notice 2 Export Control Statement 2 Contact Information 3 Contact Customer Support 3 TABLE OF CONTENTS 4 List of Figures 11 List of Tables 11 Preface 12 Purpose 12 Notation 12 Audience 12 Reference 12 1 Introduction 13 1.1 Terminals 13 1.2 Programming 13 2 Software Architecture 14 2.1 Boot Loader 14 2.2 Application Firmware 14 2.3 Lua Environment 15 2.3.1 Lua Parser 15 2.3.2 Lua Services Framework 15 2.3.3 Service Basics 15 2.3.3.1 Mandatory and Optional Services 17 2.3.3.2 Service Manager System Startup 17 2.3.4 Lua Shell 17 2.3.5 Scripting Differences Between Lua 5.1 and Lua 5.3.x 18 2.3.6 Recommended Checks 19 2.4 Messaging 20 2.5 Flash File System 20 3 Boot Loader 22 3.1 Startup Sequence 22 3.2 Firmware Download 22 3.3 Boot Commands 22 3.3.1 ? or help 22 3.3.2 baud 23 3.3.3 erase 23 3.3.4 info 24 3.3.5 load 25 3.3.6 reset 26 3.3.7 start 26 4 Application Firmware 28 4.1 User (Console) Commands 28 4.1.1 ? or help 28 4.1.2 baud 29 4.1.3 cd 29 4.1.4 check 30 4.1.5 copy 30 4.1.6 cui 31 4.1.7 del 32 4.1.8 dir 33 4.1.9 dl 33 4.1.10 format 33 4.1.11 info 34 4.1.12 init 37 4.1.13 listv 37 4.1.14 log 38 4.1.15 mem 39 4.1.16 mkdir 39 4.1.17 move 39 4.1.18 rename 40 4.1.19 repeat 40 4.1.20 reset 41 4.1.21 rmdir 41 4.1.22 start 42 4.1.23 tasks 42 4.1.24 tod 43 4.1.25 type 43 4.1.26 ulx 43 4.1.27 uly 44 5 LSF 45 5.1 Service Architecture 45 5.2 Access Levels 45 5.3 Protected Configuration Parameters 46 5.4 Shell Commands 47 5.4.1 ? or help 47 5.4.2 accel 48 5.4.3 accel autoorient 49 5.4.4 accel getsamples 49 5.4.5 access 51 5.4.6 bluetooth 51 5.4.7 bluetooth bond 52 5.4.8 bluetooth bond list 52 5.4.9 bluetooth bond del 53 5.4.10 bluetooth info 54 5.4.11 bluetooth scan 54 5.4.12 bluetooth status 56 5.4.13 campaign 57 5.4.13.1 campaign activate 57 5.4.13.2 campaign commit 57 5.4.13.3 campaign delete 58 5.4.13.4 campaign list 58 5.4.13.5 campaign revert 59 5.4.13.6 campaign stop 59 5.4.14 cd 60 5.4.15 cd 60 5.4.16 copy 61 5.4.17 del 61 5.4.18 dir 62 5.4.19 dl 62 5.4.20 email 62 5.4.21 exit 63 5.4.22 ftp 63 5.4.23 geo 64 5.4.23.1 geo show 65 5.4.24 getcfg 66 5.4.25 idp 66 5.4.25.1 idp getmetrics 67 5.4.25.2 idp getsreg 68 5.4.25.3 idp setsreg 68 5.4.25.4 idp info 69 5.4.25.5 idp status 69 5.4.25.6 idp syslog 70 5.4.26 info 70 5.4.27 listv 73 5.4.28 log 74 5.4.28.1 log count 74 5.4.28.2 log filter 75 5.4.28.3 log next 76 5.4.28.4 log clear 77 5.4.29 lua 78 5.4.30 mem 79 5.4.31 mkdir 80 5.4.32 move 80 5.4.33 msg 81 5.4.33.1 msg add 81 5.4.33.2 msg cancel 82 5.4.33.3 msg list 83 5.4.34 msg override del 84 5.4.35 msg override get 85 5.4.36 msg override set 86 5.4.37 msg store 87 5.4.37.1 msg add 88 5.4.37.2 msg cancel 89 5.4.37.3 msg list 89 5.4.38 prop 91 5.4.38.1 prop get 92 5.4.38.2 prop reset 94 5.4.38.3 prop revert 94 5.4.38.4 prop save 95 5.4.38.5 prop set 96 5.4.39 rename 96 5.4.40 report 97 5.4.41 reset 98 5.4.42 rmdir 98 5.4.43 service 99 5.4.43.1 service disable 99 5.4.43.2 service enable 100 5.4.43.3 service list 101 5.4.43.4 service mem 101 5.4.43.5 service restart 102 5.4.44 setcfg 103 5.4.45 setpass 103 5.4.46 stop 104 5.4.47 threads 105 5.4.48 tod 105 5.4.49 terminaltrace 105 5.4.50 type 106 5.4.51 ulx 107 5.4.52 uly 107 6 Services 108 6.1 Directory Hierarchy 108 6.2 Code 108 6.2.1 Required Components 108 6.2.1.1 entry() 109 6.2.1.2 init() 109 6.2.1.3 _SIN 109 6.2.1.4 _VERSION 109 6.2.2 Optional Components 109 6.2.2.1 onConfigChange() 109 6.2.2.2 onGetVolatile() 110 6.2.2.3 onSetVolatile() 110 6.2.2.4 onTermination() 110 6.2.2.5 validateConfigChange() 111 6.2.3 Extra Code Files 111 7 Properties 114 7.1 Storage 114 7.2 Types 114 7.2.1 Enumeration 114 7.2.2 Boolean 115 7.2.3 Unsigned Integer 115 7.2.4 Signed Integer 115 7.2.5 String 115 7.2.6 Data 116 7.3 Access 116 7.4 Property Values 116 7.4.1 Enumeration 116 7.4.2 Boolean 117 7.4.3 Unsigned Integer 7.4.4 Signed Integer 7.4.5 String 7.4.6 Data 8 Messages 8.1 Definition 8.2 Field Types 8.2.1 Array 8.2.2 Boolean 8.2.3 Contained Message 8.2.4 Data 8.2.5 Dynamic Value 8.2.6 Enumeration 8.2.7 Property Value 8.2.8 Signed Integer 8.2.9 String 8.2.10 Unsigned Integer_field 8.3 Access 8.3.1 Received Message 8.3.2 Sending Message 8.4 Message Values 8.4.1 Array 8.4.2 Dynamic Value 8.4.3 Property Value 8.4.4 Contained Msg 9 Scheduler 9.1 Threads 9.1.1 Thread Management 9.1.2 Thread Yielding 9.1.3 Restarting Threads 9.2 Events 9.2.1 Posting Events 9.2.2 Event Queue Creation 9.2.3 Waiting for Events 9.2.4 Event Queue 10 Low Power Operation 10.1 Processing Mode 10.1.1 Global Configuration 117 117 117 117 119 119 119 119 119 120 120 120 120 120 121 121 121 121 121 122 122 122 123 124 124 126 126 126 126 126 127 127 128 128 129 130 130 130 10.1.2 RS 232 UART Config 130 10.1.3 Low Power Considerations 130 10.1.3.1 Automatic Lua Garbage Collection 131 10.1.3.2 PIN Change Filtering 131 10.1.3.3 Analog Sampling Rates 131 10.1.3.4 RS-232 Transceiver Configuration 131 10.1.3.5 Satellite Modem Configuration 131 10.1.3.6 LED Control 131 10.1.3.7 Modem Properties 135 10.1.4 Diagnostics 135 11 Power Service 136 11.1 Programmed Power off 136 11.2 Power on Reset Reasons 136 12 Tips and Tricks 137 12.1 Memory usage 137 12.1.1 Garbage Collection 137 12.1.2 Tables 137 12.2 Using Buffers 138 12.3 Nonvolatile Data 139 LIST OF FIGURES Figure 1: Terminal Software Architecture 14 Figure 2: Message Format 20 Figure 3: Campaign States 59 LIST OF TABLES Table 1: Command Line Interpreter 15 Table 2: Core Services 16 Table 3: Mandatory and Optional Services 17 Table 4: Access Levels 45 Table 5: Supported Protected Configuration Parameters 46 Table 6: RS232 Main Shutdown Mode Configuration 130 Table 7: LED Device Activity 132 PREFACE Purpose This document provides a list of commands supported by ST terminals running firmware version 4.x or higher, and describes how to design and implement custom applications for the terminals. Where indicated, some commands may also apply to the OGi modem. Terminals and Modems ST 2100, ST 6000, ST 6100, ST 9100, and OGi Modem This document does not describe how to program user services or configure the core services on the terminal. To program user services or configure core services consult with document [T405] Notation A forward message is a message sent to the terminal from the gateway, while a return message is one sent from the terminal. Items listed as reserved are for ORBCOMM use only. Audience This document is for embedded designers and programmers. Reference The content of the following documents may be useful in conjunction with this guide. These documents are available from customer support or from the ORBCOMM Developer Toolkit. [N200]  IsatData Pro Network Services Overview  [T403]  AT Interface Developer Guide  [T405]  IsatData Pro API Reference (FW 4.x)  [T406]  ST 6100 Hardware Guide  [T407]  ST 6000 Hardware Guide  [T408]  Solution Provider Commands  [T413]  ST 9100 Hardware Guide  1 INTRODUCTION The satellite ST terminals use the IsatData Pro service to provide bidirectional messaging services between the terminal and the IsatData Pro Gateway via Inmarsat satellite services. IsatData Pro messaging capabilities make the terminal ideal for applications such as vessel and fleet management and security, remote surveillance, and telematics. Refer to [N200] for a detailed description of the IsatData Pro service. The terminal’s built-in programmability allows it to work as a stand-alone data-messaging terminal, with built-in I/O data collection and processing capabilities. Feature-rich software tools make programming easy and shorten the design and testing time. This document outlines the command line interface. The command lines can be used by developers to configure the terminal. Later sections in this document serve as a basic introduction into writing user services to run on a terminal. They describe what a service is and what it is composed of, and cover all basic tasks that someone might want to accomplish in a custom application, such as accessing properties and message fields, how to receive and send messages, and performing asynchronous processing with threads and events. This document assumes that the reader is already familiar with Lua code, and therefore does not cover any of the language's properties and subtleties. A good Lua textbook is recommended for that purpose. Where appropriate, this document does expand a bit on some of the subtleties of threaded programming, although it is by no means a complete introduction or reference on the subject. 1.1 Terminals Refer to the appropriate hardware guide for additional product details. 1.2 Programming ORBCOMM provides tools to allow the Solution Provider to program the terminals to meet specific application requirements. Terminals can be customized by configuring core services that come with the terminals or by creating new user services. A complete list of core services and their configurable properties and network messaging interfaces is documented in [T405]. 2 SOFTWARE ARCHITECTURE Figure 1 illustrates the software architecture for the terminals. The software architecture is composed of three components: • Boot Loader • Application Firmware • Lua Environment All Lua applications are stored in a flash file and copied into RAM. Figure 1: Terminal Software Architecture 2.1 Boot Loader The boot loader is a small firmware application whose primary purpose is to provide the ability to serially upgrade all the terminal firmware components including the boot loader. 2.2 Application Firmware The application firmware (terminals) provides the Lua compiler and interpreter, Lua extensions that can be implemented more efficiently in firmware, a real-time kernel, a flash file system and drivers for the Lua services to interface with the hardware. 2.3 Lua Environment By default, the ST terminals operate with a Lua environment. The Shell service (SIN 26) in the Lua environment provides a command line interface for users to configure, query and program the terminal. The Lua shell is not the only command line interface on the terminal, although in most cases it is the only command line users require. The other command lines are used for special modes and to configure the terminal, and in most cases hidden from the user by ORBCOMM's development tools. Table 1: Command Line Interpreter 2.3.1 Lua Parser The Lua parser provides direct access to the Lua interpreter. In this mode, advanced users can write and execute Lua code from the command line. Only advanced users should use this mode. Refer to [T405] for more details about Lua programming. 2.3.2 Lua Services Framework The terminals use a Lua based framework for application development. Lua is a robust scripting language that makes efficient use of memory and processor resources. The terminal has three classes of Lua services called core services, terminal apps, and user services. Core services provide basic interfaces to the core functionality of the terminal. Core services include basic functional building blocks like support for sending and receiving messages, logging, requesting GPS information and generating various periodic reports. Core services like geofence and report provide complete standalone applications. Terminal apps are ready-to-use configurable application solutions. Terminal apps are disabled by default. User services are applications that are written by the Solution Provider. These services can be plugged into the services framework of the terminal, allowing for simple or advanced extensions to the terminals core service functionality. 2.3.3 Service Basics Table 2 outlines the core services available with the ST terminals. Further details on the core services including their configurable properties and network messaging interfaces is documented in [T405]. Table 2: Core Services SIN Name Description 16 system Provides general management and control of the terminal, such as service identification, metrics, and status query/response. 17 power Unified interface to terminal power management at the Lua level. 18 message Routes incoming messages to the appropriate service and ensures outgoing messages use the appropriate format. 19 report Sends report messages that consist of properties from other services. Messages can be sent on demand or on a preconfigured schedule. 20 position Interface to GPS position information. Includes position-based accelerometer capabilities. 21 geofence The geofence service provides the ability to define geographical regions based on circles, polygons, rectangles, as well as reporting entry and exit from these regions. 22 serial Manages communication through the terminal's various serial ports (RS-232, RS-485), including their configuration and status. 23 log Stores data in nonvolatile storage. The data can be application data, which can be retrieved at later date, or diagnostic information for troubleshooting. This service also provides auto upload capabilities. 24 filesystem Provides an interface for the file system. 25 eio Configures and reports the status of the terminal's general purpose I/O. In addition, it is used to monitor the internal temperature. Alarms can be configured if thresholds are exceeded. 26 shell Shell command-line interface on the RS-232 interface. It also provides the ability to execute the same commands over-the-air and allows you to change the access level of the shell. 27 idp Provides access to some of the functionality offered by the modem. 28 reserved .29 cell Provides support for JSON and binary encoding of messages, allows configuration and monitoring of the module; and also provides a plugin to the message service allowing it to send/receive messages over cellular. (cellular and satellite-cellular terminals) 30-reserved .31 32 campaign A mandatory service that must be running to support software over-the-air updates. 33 ip Allows terminals to take advantage of protocols and their associated features on the internet for the development of IP enabled Lua applications. 34 accelerometer Defines the global configuration of the accelerometer API 35 bluetooth Provides global management and control over the Bluetooth operations. Only available on terminals that support Bluetooth hardware. 61.reserved -63 2.3.3.1 Mandatory and Optional Services Core services are further divided into two types: mandatory and optional. Mandatory services are critical to the terminals' operation and can never be disabled. Optional services can be disabled if their functionality is not required. Table 3: Mandatory and Optional Services 2.3.3.2 Service Manager System Startup On startup the LSF identifies which services must be loaded. It does so based on a list of currently enabled services, which is kept in nonvolatile storage. This list is maintained by the system service via either the disableService message [T405] or the service disable and service enable shell commands. The LSF also uses a list of mandatory core services to make this determination. Mandatory services are deemed critical to the proper operation of the terminal and can therefore never be disabled (Table 3). 2.3.4 Lua Shell The Lua shell is activated, by default on terminals when the Lua environment starts up. It is possible for the user to disable the Lua shell. The Lua shell can be disabled to 1Power Service is mandatory on the ST 6100 and unavailable on the ST 6000 OEM. • Restrict end user's access to the Lua environment • Allow a user service to access the RS-232 port 2.3.5 Scripting Differences Between Lua 5.1 and Lua 5.3.x This section lists the changes to Lua code to make it work with LUA 5.3.3: • In Lua 5.3, modules() have be deprecated. You can leave the existing module() decelerations in their code but realize that it does nothing. All services are contained in a table. To load services without polluting the global table, the Service Manager no longer uses a require() call, instead it uses loadfile() with a default environment defined. This environment is defined to replicate the following code: module(..., package.seeall) This implementation allows existing services built for Lua 5.1 to be loaded in Lua 5.3 with minimal changes. • To load a library that contains functions that need to be globally available, you need to use the require call in your code. This loads any globally defined functions into the main global table. • You can load additional code within the environment of you service using svcmgr.loadCode(), as with Lua 5.1. The only change is the order of defining the environments. This change and example of loading code is described below. To summarize, once an environment is defined it can no longer be changed externally (without using debug functions). All function environments have to be set up before you load code because setfenv() and getfenv() functions no longer exist. _ENV is a reserved “local global” that defines the global environment for the function. The following example adds the required definitions to _ENV and then calls loadcode. Previously, loading a Lua file such as terminal specific position service code would be done like this: svc.log.addDebugf(_SIN, svc.log.INFO, 'Loading position code for %s device', fname) local code = assert(svcmgr.loadCode(fname .. '.lua')) local env = getfenv(code) env._fw = fw env._api = api setfenv(code, env) primaryModule = code() _M._fw = nil _M._api = nil --Call the module-specific initialization primaryModule.init() The new way to do this is: --Prepare tables of variables used by the module _ENV._api = api _ENV._fw = fw svc.log.addDebugf(_SIN, svc.log.INFO, 'Loading position code for %s device', fname) local func, err = svcmgr.loadCode(fname .. '.lua') if func then primaryModule = func() else svc.log.addDebugf(_SIN, svc.log.ERROR, 'Failed to initialize %s. Error: %s', fname, err) end primaryModule.init() _fw = nil _api = nil • Bit32 functions are deprecated in LUA 5.3 but support for the old library has been added and will work as is. If you want to make use of newer 64-bit integer support, you will need to update your code to use the new bitwise operators. • Support for older math definitions (32 bit) has been added. • Table global functions have been added. • Tonumber The tonumber() function behaves differently in Lua 5.3.x than it did in Lua 5.1.x. Calling tonumber(“0x67”, 16) in Lua 5.1.x returns 103, but it returns nil in Lua 5.3.x. When using a specific base, the “0x” prefix must be omitted. • addDbgLog() has been deprecated. 2.3.6 Recommended Checks The following lists the recommended checks to ensure the existing application functions on the new platform. • If 64-bit integer support is required, update all bitwise references. • Update any references to svcmgr.loadCode(), setfenv() and getfenv() as described in the previous section. • If using pulse counting in the EIO service, ensure source signal is clean or use filtering. Pulse counting in this firmware is sensitive and may end up counting edges from the noise. • Review SIN 25 (EIO) in [T405] for deprecated PINs. • In prior versions of LUA, numbers were treated as floats. In LUA 5.3 numbers can also be integers. Some functions, such as os.time() require integers. If a number was converted to a float internally, ex: x = x + 0.0, this will result in an error when calling the function. 2.4 Messaging The system adds two bytes to the beginning of all messages sent or received by a service. The message format is shown in Figure 2. Figure 2: Message Format The maximum length for to-mobile messages is 10,000 bytes, and 6,399 bytes for from-mobile messages. The first byte is the service identification number (SIN) that is used to uniquely identify a service. SIN values from • 0 through 15 are reserved for the modem • 16 through 63 are for core services and these numbers are fixed and cannot be updated. These services are accessed in the svc.<service name> namespace. • 64 through 127 are for terminal apps and these numbers should remain fixed. These services are also accessed in the svc.<service name> namespace and therefore cannot have the same name as a core service. Note: Terminal apps are disabled by default. • 128 through to 255 are for user services. These services are accessed in the user.<service name> namespace and therefore can have the same name as services in the 16 to 127 range. However, no two user services can have the same name. The second byte in the message is the message identification number (MIN) that identifies the message type that can vary depending on the service. MINs from 1 to 255 are valid and MIN 0 is reserved. 2.5 Flash File System The terminals use a serial flash file system to store the Lua Services Framework, configuration, user services and user data. The file system is structured as a single volume (called sys:) that is structured as follows (example only -only services appropriate for a specific product are shown and therefore vary from terminal to terminal): act/ -Active directory info/ -Package manifest information infra/ -Infrastructure (ORBCOMM Private) svc/ -LSF Core Services (ORBCOMM Private) user/ -User service directory MyService/ -User service 'MyService' folder for code svclist.lua -User service registration file data/ -Data directory svc/ -Most LSF Core Services data directories accelerometer filesystem/  geofence/  - Default  location  for  geofence  data.  idp/  ip/  message/  position/  power/  report/  serial/  shell/  system/  user/  MyService/  - Data  directory  for  'MyService'  config/  svc/  serial.lua  - Saved  serial  service  property  values  user/  MyService.lua  - Saved  user  service  property  values  logs/  - Contains  other  log  service  data  capaign/  - Contains  other  capaign  files  3 BOOT LOADER Boot loader applies to ST 61xx terminals. The boot loader is a small firmware application that takes control of the system after a reset occurs. The boot loader does the following: • Perform basic driver initialization • Display a startup banner if application firmware is present • Perform more hardware tests • CRC validation of firmware image • Allow for break-in on serial port for serial download (if application firmware present) • Auto-starts application firmware The boot loader configures the main RS-232 serial port to 9600 baud, 8 data bits, even parity, and 1 stop bit. 3.1 Startup Sequence On startup, the boot loader displays its banner and then outputs a '.' (period) every second for 5 seconds. If the character sequence <CTRL-B><CTRL-B> is entered, then the normal boot process is interrupted. If a Solution Provider (SP) password is currently configured (Section 5.4.44), the boot loader outputs a unique 128-bit hardware ID of the terminal in hex before it prompts for a password. At this point, a password can be entered. There is a time-out of 30 seconds for entering the password, or a maximum of three (3) attempts, and then the normal boot process resumes. After a valid password is entered, or immediately if no password is configured, the boot loader enters its menu. This optional password controls entry into the Lua command line and helps ensure that the terminal's application cannot be modified in the field. 3.2 Firmware Download From the boot loader menu, commands are available to serially download and upgrade both the boot loader itself and the application firmware image. It is strongly recommended that Console, from the ORBCOMM Developer Toolkit, is used to load packages to program firmware images. 3.3 Boot Commands The general syntax that applies to all boot loader commands1: <command> [<args>|help|?] For example, any command followed by a ? or the keyword help displays the parameter usage of the command. 3.3.1 ? or help Description Display a list of all the available commands and their descriptions. 1Examples vary from product to product. Syntax help Example boot# help General syntax: <command> [<args>|help|?] Available commands: ?  -Display this help  baud  -Change baud rate  erase  -Erase application firmware Image  help  -Display this help  info  -Display boot loader info  load  -Load boot/firmware Image  reset  -Reset terminal  start  -Start application firmware  3.3.2 baud Description Change the baud rate of the serial port. Syntax baud [<baudRate>] Parameters <baudRate> One of 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200 Example Change the baud rate to 115200. boot# baud 115200 Changing baud to 115200 3.3.3 erase Description Erase the terminal application firmware image from program flash. CAUTION: This removes the terminal's firmware and disables normal firmware operation. Syntax erase force|quiet Parameters force Skip the yes/no prompt and immediately perform the erase quiet Suppress the output of information messages Example Erase the terminal firmware without a conformation prompt. boot# erase force === Erasing 476 KB of FLASH === Prompt for a y confirmation before erasing the terminal firmware image. boot# erase Erase FLASH? (y/n) === Erasing 476 KB of FLASH === OK 3.3.4 info Description Display the information about the last reset reason, terminal hardware, clock speeds and loaded software versions, including build date, build time and other info about the boot loader and the loaded terminal firmware. Syntax info Example boot# info Terminal info: Manufacturing ID: ** NOT SET ** H/W Feature mask: 0x0000000000000000 H/W Revision: 3 H/W Reset reason: 6 (SOFTWARE) S/W Reset cause: 23 (LUA SHELL) RTC Clock: Ready SYSCLK: 32 MHz ADCCLK: 4 MHz Boot loader info Status: OK Size: 26632 Software version: x.0.0 (Release) Build date: Aug 29 20xx Build time: 10:07:58 Boot API level: 2 Boot API version: 1 Image CRC32: 0x442608C0 Application firmware info Status: OK Size: 253976 Software version: x.x.x (Release) Build date: Aug 29 20xx Build time: 10:10:03 Boot API version: x Feature mask: 0x0000000000000000 Image CRC32: 0x37D3793D 3.3.5 load Description Load terminal boot loader or application firmware image using X or Y modem serial protocol at the current baud rate. Loading is as follows: • The X/Y modem receiver side protocol is initiated with the output of packet solicitation characters (C or ASCII 0x43) every 2 seconds • The terminal aborts the protocol if no transmitter side protocol is present after 200 seconds. • Two <CTRL-X> characters in a row cancel the X-Modem transfer. • When the transfer is complete, the boot loader displays details (image type, version etc.) of the image and prompts for a confirmation to program the flash • If the CRC is bad or invalid, the programming sequence is aborted Syntax load [force|quiet] Parameters force Skips yes/no confirmation and over-rides CRC validation quiet Suppress the output of information messages Example Start the X/Y modem receive protocol with CRC validation and prompting for write confirmation. boot# load Start X-Modem transfer now! (CTRL-X to cancel) CCCC Successfully received 243484 bytes: Type: Application Firmware Status: OK Size: 243484 Software version: x.x.x (Release) Build date: Jun 6 2011 Build time: 11:10:47 Boot API version: x Feature mask: 0x0000000000000000 Program FLASH? (y/n) y === FLASH Programming === Start the X/Y modem receive protocol while suppressing information output, ignoring invalid CRC values, and skipping the flash write confirmation prompt. boot# load force quiet CCCC Start the X/Y modem receive protocol with minimum output but still prompting for write confirmation. boot# load quiet CCCC Program FLASH? (y/n) y 3.3.6 reset Description Reset the terminal processor. Syntax reset Parameters None 3.3.7 start Description Start execution of the terminal's firmware. This command fails if a terminal firmware image is not present. Syntax start [nolua] [force] [safemode] [factoryreset] [ui=<interface>] Parameters nolua Start the terminal firmware and do NOT automatically start the Lua services framework force Start the terminal firmware even if the CRC of the image is not valid or present safemode Load all the services and their default properties, but no user services (temporary). Start the terminal firmware and the core services. factoryreset Start the terminal firmware after resetting the Lua services framework to factory defaults (persistent) ui=<interface> Start the terminal firmware in the interface specified (refer to section 4.1.6) Example Start the firmware, if the CRC is valid. boot# start Starting application xxx firmware (Version x.x.x (Release)) Starting the Lua Services Framework Attaching shell shell> Start the firmware without starting the Lua services framework. base# start nolua Starting application xxx firmware (Version x.x.x (Release)) Copyright © 2017 # 4 APPLICATION FIRMWARE 4.1 User (Console) Commands Unless noted otherwise, user console commands apply to ST terminals and the OGi modem. The general syntax that applies to all commands: <command> [<args>|help|?] For example, any command followed by a ? or the keyword help displays the parameter usage of the command. The modem uses its own file system, labeled ‘m’ as shown in the example below. In most ‘m’ user commands are read-only. The ST 6000, for example, has an integrated modem and therefore has two file systems, ‘m’ and ‘a’. 4.1.1 ? or help Description Display a list of all the available commands and their descriptions. Syntax #? <command> [<args>|help|?] Example # help General syntax: <command> [<args>|help|?] Available commands: ?  -Display this help  baud  -Change baud rate  cd  -Change the current  working directory  check  -Check file system integrity  copy  -Copy a file  cui......-Change user interface del -Delete a file dir -Display the contents of a directory dl -Start YMODEM download session format -Format a file system volume info – Display terminal information init -Initialize the file system volume listv -List file system volumes log......-Control logging mkdir -Create a directory move -Moves a file and/or directory rename -Rename a file/directory repeat...-Repeat command reset....-Reset terminal rmdir -Remove a directory start -Start Lua services framework tod -Display or set terminal time of day type -Display the contents of a file ulx -X-Modem upload uly -Y-Modem upload 4.1.2 baud Description Change the baud rate of the serial port. The default is stored as an NVM parameter. Syntax baud [<baudRate>] Parameters <baudRate> One of 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200 Example Change the baud rate to 115200. # baud 115200 Changing baud to 115200 4.1.3 cd Description Display the current directory or change to the specified directory. Syntax cd [<dirpath>] Parameters <dirpath> Optional relative or absolute directory path to change to. Example Perform a relative directory change to the directory act/svc. # cd act/svc Change to a higher directory level. # cd .. Show the current active directory. # cd sys:act/svc 4.1.4 check Description Check file system integrity of the specified volume and display any problems. If no volume is provided, the default volume (sys:) is used. Syntax check [<volume>] Parameter <volume> Volume to check (default: sys:) Example Check the default file system for integrity. # check OK 4.1.5 copy Description Copy one file from one location to another. This command does not apply to modem file systems. Syntax copy <scrfile> <dstdir|dstfile> Parameter <scrfile> Source file to copy <dstdir> Destination directory <dstfile> New file name Example Copy the file main.lua to the directory act/svc/test. # copy main.lua act/svc/test 4.1.6 cui Description The cui (change user interface) command allows you to move between the different access levels. A password may be required to access some of the levels. Syntax cui <ui> Parameters With no argument, lists all of the available levels and indicates which one is currently active. <ui>  1  at  AT command interface  2  nmea  NMEA streaming  3  user  User CLI  4  sp  Solution Provider CLI  5  event  Event streaming  6  og  OG binary interface  7  - Reserved  8  - Reserved  9  sptest  Solution Provider test CLI  Example cui at cui 1 Shell Navigation 4.1.7 del Description Delete a file. This command does not apply to the modem file system. Syntax del <file> Parameter <file> File to delete Example Delete the file stuff.lua. # del stuff.lua 4.1.8 dir Description Display the contents of the current or specified directory. The display includes the type of file, the file size, creation time stamp of the file, and the file name.  Syntax dir [<dirpath>]  Parameter  <dirpath> Relative or absolute directory path to d isplay  Example Display the contents of the current directory.  # dir  (Dir) (Dir) (Dir)  --.--.--. 0 0 0  31/03/2011 01/01/1980 01/01/1980  16:50:30 00:00:00 00:00:00  act data logs  4.1.9 dl Description Starts a Y-Modem download session. This command does not apply to the modem file system. Syntax dl Example # dl Start Y-Modem transmit now! CCC 4.1.10 format Description Format a volume for file system operation. This command does not apply to the modem file system. Syntax format <volume> Parameter <volume> Volume name to format Example Format the main file system. # format sys: Formatting volume sys: 4.1.11 info Description Display product and software load information. Syntax info [id|license|reset|sproc|variant] With no argument, displays hardware and software load information. Parameter id Display the processor hardware ID license Display software licenses reset Display the last reset information sproc Display support processor information variant Display the hardware variant Example Display the current terminal information. shell> info Terminal info Manufacturing ID: ABC123 H/W variant: 1 H/W revision: x H/W Processor clock: xx H/W Reset reason: 6 (SOFTWARE) S/W Reset cause: 8 (BOOT IDLE) Lua heap size: 1920K Uptime: 0 days, 0 hours, 3 mins, 28 secs Power save time: 0 days, 0 hours, 0 mins, 0 secs (0.00%) Boot loader info Software version: x.x.x (Release) Build date: Jun 20 20xx Build time: 12:51:20 Application firmware info Software version: x.0.1 (Release) Build date: Jun 20 20xx Build time: 12:55:36 Lua API level: 33 Lua compatibility level: 30 Lua Services Framework Version: x.0.1 Build date: Jun 20 20xx Build time: 14:26:00 API level: 11 Uptime: 0 days, 0 hours, 3 mins, 28 secs Idle time: 0 days, 0 hours, 3 mins, 5 secs Package version: 4.1.0.6174 Display the last reset information. In this example, there is no crash log. shell> info reset Last reset information: Hardware reset reason: 1 (POWER ON) Software reset cause: 0 (NONE) Software crash log: NONE Display the last reset information showing a crash log of an exception. shell> info reset Last reset information: Hardware reset reason: 6 (SOFTWARE) Software reset cause: 2 (EXCEPTION) Software crash log: *** System Fault #5 (Bus Fault) *** MSP = 20003C68 PSP = 20006018 <== Active (Task) Active Task: CmdLine (prio= 22) Stacked Registers: R0= 30000000 R8 = 00000018 R1= 00000001 R9 = 64000534 R2= 00000000 R10= 10101010 R3= 00000075 R11= 11111111 R4= 00000001 R12= 00000075 R5= 20002686 LR = 08033E0B R6= 00000000 PC = 08033E8C R7= 00000005 PSR= 01000000 Fault cause: Imprecise data bus error Status Registers: CFSR= 00000400 (UFSR= 0000, BFSR= 04, MMFSR= 00) HFSR= 00000000 DFSR= 00000000 Display the hardware ID of the terminal. shell> info id 4311741230334632FF31D53E Display information about the last reset. In this case, there is no crash log. shell> info reset Last reset information: Hardware reset reason: 6 (SOFTWARE) Software reset cause: 2 (EXCEPTION) Software crash log: *** System Fault #5 (Bus Fault) *** MSP = 0x20003DC8 PSP = 0x20005FF0 <== Active GMK Active Task: CmdLine (prio= 14) Stacked Registers: R0 = 0x00000000 R12 = 0x00000075 R1 = 0x00000001 LR = 0x0801A06D R2 = 0x00000000 PC = 0x0801A0DC R3 = 0x00000075 PSR = 0x01004000 Fault Status Registers: CFSR = 0x00000400 BFAR = 0xE000ED38 HFSR = 0x00000000 DFSR = 0x00000000 In this example, the last reset was caused by an exception and the details of the exception are displayed in the crash log. 4.1.12 init Description Initialize the file system volume. This command verifies that the volume is formatted and accessible. This command does not apply to the modem file system. Note: This command is used primarily by the automatic tools. Syntax init [<volume>] Parameter <volume> Volume to init (default: sys:) Example Initialize the default file system. # init OK 4.1.13 listv Description List the information about the current file system volumes. Syntax listv Example # listv Volume Label Size Free Used M: Modem 1030656 982080 4% A: System 5744640 4821696 14% *** 67584 bad bytes *** 4.1.14 log Description Enable/disable logging at specified log level for various software modules. Syntax log Set global logging parameters log <option> <val> Enable or disable a logging level for a module for a log location log [serial|sysfile] [module] +|-<level>,[+|-<level>],... Enable or disable a logging level for a module for a log location log [serial] <option> log [sysfile] <option> <val> Parameter Supported Options: channel <channel> -set serial channel to log to color [enable|disable] -enable/disable colorizing of log output baud <baud rate> -set default baud rate msg <string> -add the specified string to the log stats [clear] -display and optionally clear logging statistics [serial] enable|disable -enable or disable the log output [serial] default|verbose|debug -configure global logging [serial] [<mod>] +|-<level> -add/subtract level to specified module or all modules [serial] reset -restore serial logging configuration to default values [sysfile] dump|transfer <fileNumber> -dump or transfer a specified system log file. (Ctrl-X to abort) [sysfile] erase -erase all files used for system logging Example # log Serial: enabled Channel: rs485 Default baud: 115200 Log coloring: enabled 4.1.15 mem Description Displays the current memory usage. Syntax mem [clear] Parameter clear Clears counters (optional) 4.1.16 mkdir Description Creates a directory. This command does not apply to the modem file system. Syntax mkdir <dirpath> Parameter <dirpath> Path of the directory to create Example Create the director test in the current directory. # mkdir test 4.1.17 move Description Moves a file and/or directory. This command does not apply to the modem file system. Syntax move <filename> <destination> Parameter <filename> Source file or directory name, with or without a path <destination> New name of file or directory with or without a path Example Move a debug log to the current directory. # move logs/dbgLog00.dat Rename a file using move. # move main.lua old.lua 4.1.18 rename Description Rename a file or directory. The default access level is 1. This command does not apply to the modem file system. Syntax rename <old> <new> Parameter <old> File or directory to rename <new> New name Example Change the name of main.lua to main_old.lua. shell> rename main.lua main_old.lua 4.1.19 repeat Description Repeat the last command. Syntax repeat <count>[<delay>]<command>[<args>...] Parameter count Number of times to repeat the command delay Delay in mili-seconds before repeating the command command The command to execute args Command arguments Example Repeat the command. # repeat OK 4.1.20 reset Description Reset the device processor. Syntax reset [boot| <channel>] Parameter boot Reset to the boot loader menu channel Serial channel to boot to (main, aux, etc.) 4.1.21 rmdir Description Removes (deletes) a directory. The default access level is 1.This command does not apply to the modem file system. CAUTION: Recursive removal of directories could render the terminal inoperative. Syntax rmdir [-recurse] <dirpath> Parameter [-recurse] Recursively removes all files and directories <dirpath> The directory path to remove Example Remove the directory log. shell> rmdir log Recursively remove the act/svc directory. shell> rmdir -recurse act/svc 4.1.22 start Description Start the Lua Services Framework, which is located on the flash file-system. This allows access to the shell prompt of the shell service if it is enabled. This command does not apply to the modem file system. Syntax start [safemode|factoryreset] Parameter safemode Load all the services and their default properties, but no user services (temporary). Start the terminal firmware and the core services. factoryreset Start the terminal firmware after resetting the Lua Services Framework to factory defaults (persistent) Example Start the LSF. # start Starting the Lua services framework Attaching shell shell> Start the LSF after resetting the configuration of all services to their factory defaults. # start factoryreset Starting the Lua Services Framework *** warning: Restoring to factory defaults Attaching shell shell> 4.1.23 tasks Description Display kernel task information. Syntax tasks [clear] Parameters <clear> Clears counters (optional) 4.1.24 tod Description Display or set the terminal time-of-day. Syntax tod print the date and time : dd/mm/yyyy hh:mm:ss tod date <yyyy> <mm> <dd> set the date tod time <hh> <mm> <ss> set the time tod get print the number of seconds since Epoch tod set <offset> set the date and time using seconds since Epoch Example shell> tod Wed Mar 16 19:15:59 2011 UTC 4.1.25 type Description Display the contents of a file. If the file is a compiled Lua file, then the message “Compiled lua file” is displayed. Syntax type [-hex] <file> Parameter [-hex] Display the file in hexadecimal mode <file> File to display Example Display what happens when attempting to type a compiled Lua file. # type svclist.lua Compiled lua file 4.1.26 ulx Description Upload a file using the X-Modem protocol. This command does not apply to the modem file system. Syntax ulx <file> Parameter <file> File to transmit using the X-Modem Example Start an X-Modem transmit session to send the file data.lua. # ulx data.lua Starting X-Modem upload 4.1.27 uly Description Upload one or more files and/or directories using the Y-Modem protocol. This command does not apply to the modem file system. Syntax uly <file|dir> [… <file|dir>] Parameter <file> File to transmit using the Y-Modem protocol <dir> Directory to transmit files from using the Y-M protocol Example Send the files data/mylog.dat and foo.lua. # uly data/mylog.dat foo.luaStarting Y-Modem upload Send all files from the data directory, foo.lua and all files from the config directory. # uly data foo.lua config Starting Y-Modem upload 5 LSF 5.1 Service Architecture Most end-user functionality on the terminals is implemented by software constructs called services. Services are self-contained, individually-addressable modules each offering well-defined functionality. Services are written in Lua, and can optionally define configurable properties, function interfaces, and network messaging interfaces. As mentioned in section Lua Environment there are three broad classes of services called core services, terminal apps, and user services. The terminal software allows custom application development (Lua scripting). Lua is the scripting language used because it is a proven, robust, embedded scripting language with many applications. Lua is a fast language engine with a small footprint that can easily be embedded into almost any application. The application programming interface (API) allows it to integrate with code written in other languages. 5.2 Access Levels The security model supports the concept of access levels. An access level can be associated with each shell command. Table 4 shows the supported levels. If the description of a shell command does not specifically indicate an access level, then level 0 is assumed. Refer to individual shell commands for more details. Note: An access level allows only commands of that level or lower to be executed. Table 4: Access Levels Level 1 Description 0 Default basic access -no password 1 Solution Provider access level (default is an empty string) CAUTION: For security reasons it is recommended that you immediately change this password. The shell on startup defaults to access level 0, which does not have an associated password. The default level 1 password is an empty string and can be changed via setpass 1. Level 1 commands can be executed from level 0 when the level 1 password does not exist (is an empty string). The command allows you to switch between different access levels. Access levels that have a password require the user to provide the password before a switch is allowed. Shell service (SIN 26) [T405] messages support the execution of access restricted shell commands and allow the changing and querying of access levels over-the-air. Refer to the register() function in [T405] for shell command options (for example, hidden, level, locked, and interactive). The options of an unlocked command can be changed by unregistering the command, and reregistering the command with modified options. Most shell commands do not have options; individual shell commands indicate whether an option is available. 1All other levels are reserved. Locked Some shell commands are locked, meaning that they cannot be unregistered (removed) and therefore their options (hidden, level) cannot be changed (refer to the register() function in [T405]). Interactive An interactive command may prompt for additional input, and therefore cannot be executed over-the-air. 5.3 Protected Configuration Parameters The shell supports access level protected configuration parameters. This allows password control of sensitive hardware and software configurations. The getcfg command displays the parameters and the setcfg command changes the parameters. Table 5: Supported Protected Configuration Parameters Parameter Type Possible Values Level Description Parameter (default in bold) ST 61xx ST 9100 bootchannel String main or aux1 1 Defines the default boot serial ü• channel. bootdelay Integer 0 to 30 1 Boot loader delay in seconds (Zero ü• Default: 5 disables the boot loader prompt) bootlevel Integer 0, 1, or 2 varies Access level of the ü• boot loader. bootbaud Integer 1200, 2400, 4800, 9600, 1 Defines the baud rate for the boot ü• 14400, 19200, 38400, 57600, serial channel. 115200 btroles Integer 0 – disabled 1 Configures the global Bluetooth -• 1 – central only roles. 2 – peripheral only Note: Requires a terminal reset 3– both to take effect. btlabel String “” 1 If set, overrides the Bluetooth -• service advertising label and can be up to 25 characters in length. übtpasskey String “000000” 1 6-digit numeric string used for the -Bluetooth peripheral role passkey. 1Aux is only available on some device models. Parameter Type Possible Values Level Description Parameter (default in bold) ST 61xx ST 9100 btservicemask Integer Bit 0 – Factory support -• Bit 1 – Device description Bit 2 – Console Streaming Bit 3 – Short Messages Default: 0x0F (All services) btserialmask Integer Bit 0 – Main -• Bit1 – Aux firmwareled Boolean true/false 1 Allow global firmware ü• control of the LEDs. Note: Requires a terminal reset to take effect. • üuserled Boolean true/false 1 Allow global user control of the LEDs. 1 Bit mask of available serial channels for console streaming. 5.4 Shell Commands If the shell service is enabled on ST terminals via the attached property of the shell service, then the shell prompt (for example, shell>) is available on the RS-232 serial port. The RS-232 configuration depends on the properties of the serial service, which default to 9600 baud, 8 data bits, no parity, 1 stop bit. This section describes the commands and responses available from the LSF shell interface. Unless noted otherwise, the shell commands apply to ST 61xx terminals. 5.4.1 ? or help Description Display a list of all the available commands and their descriptions. Syntax help | ? Example shell> help Available commands: ? -Display this help access -Change access level campaign -Issue a campaign command cd -Change the current working directory copy  -Copy a file  del  -Delete a file  dir  -Display a directory  exit  -Return to access level zero  geo  -Issue a geofence command  getcfg  -Get configuration  help  -Display this help  idp  -Issue an IDP modem command  info  -Display terminal info  listv  -List file-system volumes  log  -Issue a log command  lua  -Execute Lua expression  mem  -Display free memory  mkdir  -Make a directory  move  -Move a file/directory  msg  -Issue a msg command  prop  -Issue a property command  rename  -Rename a file/directory  report  -Generate a report  rmdir  -Remove a directory  service  -Issue a service command  setcfg  -Set configuration  setpass  -Change a password  stop  -Stop the Lua environment  threads  -Display spawned threads  tod  -Display terminal time-of-day  trace  -Control serial tracing  type  -Display the contents of a file  5.4.2 accel Description Issue an accelerometer command. Syntax accel ?|help|[<command>] Parameter ? or help List the available accelerometer commands [<command>] The accelerometer command 5.4.3 accel autoorient Description Start, abort, or display the status of automatic orientation detection. When the operation is start or abort, the aoActivate property is set accordingly. Syntax accel autoorient [<operation>[save]] Parameter <operation> start Start automatic orientation detection abort Abort an automatic orientation detection that is in progress If <operation> is omitted, displays the current status of automatic orientation detection. save If present, the aoActivate property value is saved Example shell:1> accel autoorient ? Syntax: autoorient [start|abort [save]] shell:1> accel autoorient aoStatus: NotStarted aoState: None shell:1> accel autoorient start shell:1> accel autoorient aoStatus: Started aoState: DetermineUpwardDir shell:1> accel autoorient abort shell:1> accel autoorient aoStatus: Aborted aoState: DetermineUpwardDir shell:1> 5.4.4 accel getsamples Description Start collecting or display accelerometer sample information or progress. Syntax accel getsamples [start [<numSamples> [<samplesPerSec>]]] Parameter start Start the acceleration sampling <numSamples> Total number of acceleration samples to obtain. Range 1-50. 5 is used if no value is specified. The minimum/maximum value will be used for values below/above the range. <samplesPerSec> Number of acceleration samples that are obtained each second. Range 1-10. 1 is used if no value is specified. The minimum/maximum value will be used for values below/above the range. Example shell:1> accel getsamples ? Syntax: getsamples [start [<numSamples> [<samplesPerSec>]]] shell> accel getsamples no recent sample information exists shell> accel getsamples start shell> accel getsamples sampling in progress -4 of 5 samples collected shell> accel getsamples XYZ Avg 93 31 937 Min 93 31 937 Max 93 31 937 Samples: 93 31 937 (age 8s) 93 31 937 93 31 937 93 31 937 93 31 937 (age 4s) shell> accel getsamples start 3 10 shell> accel getsamples XYZ Avg 93 31 937 Min 93 31 937 Max 93 31 937 Samples: 93 31 937 (age 2s) 93 31 937 93 31 937 (age 2s) shell> 5.4.5 access Description Changes the current access level of the shell and prompt for a password if required. This command is locked and interactive. Syntax access [<level>] Parameter <level> Access level to set (0 to 1). Other access levels are reserved. Example Change to level 1 when a level 1 password is defined. shell> access 1 Enter level 1 password: shell:1> Display the current access level. shell> access Access level: 0 5.4.6 bluetooth Description Issue a Bluetooth command. Syntax bluetooth ?|help|<command> Parameter ? or help List the available Bluetooth commands <command> Bluetooth command Example shell> bluetooth ? Available commands: ? -Display this help bond -Bonded device management help -Display this help info -Display Bluetooth information scan -Scan for peripheral devices status -Display the current Bluetooth status 5.4.7 bluetooth bond Description Displays and removes central and peripheral device bonding information. Syntax bluetooth bond ?|help|<command> Parameter ? or help List the available Bluetooth commands <command> Bluetooth bonding command Example shell> bluetooth bond ? Available commands: ? -Display this help del -Delete bonded device help -Display this help list -List bonded devices 5.4.8 bluetooth bond list Description Displays a list of all bonded central and peripheral Bluetooth devices. Syntax bluetooth bond list Parameter None Example shell> bluetooth bond list ID  Device type  Address  Addr Type  1  Peripheral  CA:61:65:D1:AA:F1  RandomStatic  2  Central  00:16:A4:56:59:BE  Public  5.4.9 bluetooth bond del Description Displays a list of all bonded central and peripheral Bluetooth devices. Syntax bluetooth bond del <id>]all Parameter <id> Specifies the identification number of the device to delete from the ‘bluetooth bond list’ output all Delete all bonded devices Example shell> bluetooth bond list ID Device type Address Addr Type 1 Peripheral CA:61:65:D1:AA:F1 RandomStatic 2 Central 00:16:A4:56:59:BE Public shell> bluetooth bond del 3 Device ID 3 is invalid. Range is 1 to 2 shell> bluetooth bond del 1 shell> bluetooth bond list ID Device type Address Addr Type 1 Central 00:16:A4:56:59:BE Public shell> bluetooth bond del all shell> bluetooth bond list No bonded devices 5.4.10 bluetooth info Description Displays static Bluetooth configuration. Syntax bluetooth info Parameter None Example Active roles: CentralAndPeripheral Device address: D4:4D:3F:87:8D:6C (RandomStatic) Device name: 01173416SKY1485 Boot S/W version: 2.1.0 SVN revision: 20832 Build date: Jan 30 2020 Build time: 17:32:19 Appl S/W version: 2.5.0 SVN revision: 20971 Build date: Feb 14 2020 Build time: 09:54:07 5.4.11 bluetooth scan Description Scans for peripheral devices that are advertising and lists them in order of strongest to weakest signal strength based on the devices received RSSI. Syntax bluetooth scan [<duration>]all Parameter <duration> Optional duration in seconds to scan for. (Default: 10 seconds) all =Include all devices (Default: Only ORBCOMM devices) Example shell> bluetooth scan Scanning for ORBCOMM Bluetooth devices for 10 seconds Found 14 devices: # Manuf. ID Name Address Addr Type RSSI 1 ORBCOMM JCAB418150014 DB:A0:94:D4:14:92 RandomStatic -46 2 ORBCOMM EWCB618060128 F2:45:A4:3A:3F:0C RandomStatic -51 3 ORBCOMM EWAB817030569 FE:23:B9:87:1E:F4 RandomStatic -56 4 ORBCOMM FCBC818420093 E1:35:7E:ED:07:C4 RandomStatic -59 5 ORBCOMM 01173415SKY9080 F3:FB:AA:46:77:83 RandomStatic -60 6 ORBCOMM 01174839SKYEC50 FE:B2:79:5F:24:D5 RandomStatic -61 7 ORBCOMM EWBB617450093 EB:02:EF:A8:F3:C4 RandomStatic -62 8 ORBCOMM 01008820SKYB5C1 F3:23:BD:54:33:27 RandomStatic -64 9 ORBCOMM FCAC619070170 D1:F1:E9:8D:72:87 RandomStatic -66 10 ORBCOMM JCAB618440048 CB:CD:3D:3F:D8:04 RandomStatic -69 11 ORBCOMM EWAB619110145 F5:B7:F5:37:35:FD RandomStatic -71 12 ORBCOMM ABCD121000206 D5:A2:57:8B:A3:35 RandomStatic -71 13 ORBCOMM JSAB619300019 E7:F6:AD:50:1D:50 RandomStatic -72 14 ORBCOMM EWBB617450049 CA:E2:59:E6:D9:CB RandomStatic -77 SCAN ALL shell> bluetooth scan 5 all Scanning for all Bluetooth devices for 5 seconds Found 19 devices: # Manuf. ID Name Address Addr Type RSSI 1 Unknown Bluetooth Device D4:CA:6E:B0:78:67 Public -42 2 ORBCOMM EWAB619060014 E2:49:B3:06:92:D1 RandomStatic -45 3 Microsoft Unknown 4F:69:54:09:FE:39 PrivateResolvable -46 4 Unknown P T EN 80016B D0:1E:D0:4B:E2:08 RandomStatic -50 5 Apple Unknown 41:B8:8E:EF:14:3D PrivateResolvable -51 6 Microsoft Unknown 58:33:2E:B8:0B:6F PrivateResolvable -53 7 Apple Unknown 57:B7:8D:F7:1C:52 PrivateResolvable -54 8 ORBCOMM EWBB617450093 EB:02:EF:A8:F3:C4 RandomStatic -58 9 ORBCOMM EWBB619010002 E9:23:BE:17:14:41 RandomStatic -60 10 ORBCOMM 01008820SKYB5C1 F3:23:BD:54:33:27 RandomStatic -62 11 Microsoft Unknown 6C:64:5E:D4:0A:A0 PrivateResolvable -63 12 ORBCOMM FCAC619070170 D1:F1:E9:8D:72:87 RandomStatic -64 13 Apple Unknown 5B:6C:47:E2:9F:B4 PrivateResolvable -64 14 ORBCOMM EWAB619110145 F5:B7:F5:37:35:FD RandomStatic -65 15 ORBCOMM ABCD121000206 D5:A2:57:8B:A3:35 RandomStatic -65 16 Microsoft Unknown 13:1E:29:3F:F4:13 PrivateNonResolveable -72 17 ORBCOMM EWAB617340470 C6:56:F9:7B:FB:EE RandomStatic -73 18 Microsoft Unknown 4B:AC:66:29:D1:B1 PrivateResolvable -76 19 Microsoft Unknown 18:90:8F:0A:AD:C6 PrivateNonResolveable -77 5.4.12 bluetooth status Description Displays dynamic Bluetooth status including advertising status, connected centrals and connected peripherals. Syntax bluetooth status Parameter None Example shell> bluetooth status Active label: "Test" Advertising status: Normal Connected central: None Connected serial channel: None Connected peripherals: 0 shell> bluetooth status Active label: "Test" Advertising status: Suspended Connected central: 00:16:A4:56:59:BE (Public) Connected serial channel: “rs232aux” Connected peripherals: 0 shell> bluetooth status Active label: "Test" Advertising status: Suspended Connected central: 00:16:A4:56:59:BE (Public) Connected serial channel: None Connected peripherals:  3  #  Address  Addr Type  Interval(ms) Latency Timeout(ms)  1  E2:49:B3:06:92:D1  RandomStatic  400  4  8000  2  E9:23:BE:17:14:41  RandomStatic  30  0  8000  3  D0:1E:D0:4B:E2:08  RandomStatic  30  0  8000  5.4.13 campaign Description Issues a campaign related command. Campaign is a term used to refer to the task of communicating with multiple terminals to perform software over-the-air updates. Syntax campaign ?|help|<command> Parameter ? or help List the available campaign commands. <command> A campaign command. Example shell> campaign ? Available commands: ? -Display this help activate -Activate a validated campaign commit -Commit an activated campaign delete -Delete a campaign help -Display this help list -Display a list of campaigns revert -Revert an activated campaign stop -Stop a campaign 5.4.13.1 campaign activate Description Activate a campaign that was previously loaded and validated. Syntax campaign activate <id> Parameter <id> The identification number of the campaign. 5.4.13.2 campaign commit Description Commit a campaign that was previously activated. Syntax campaign commit <id> Parameter <id> The identification number of the campaign. 5.4.13.3 campaign delete Description Delete a campaign from the database, and its associated update file. Syntax campaign delete <id> Parameter <id> The identification number of the campaign. 5.4.13.4 campaign list Description List all campaigns in the database, including the state and time of the last update. Syntax campaign list Parameter None Example The state column contains the current state of the campaign as defined Figure 3, or when the file transfer is in progress, it indicates the number of fragments received out of the total number of fragments. Refer to [T405] for additional details.  ID  Name  Size  State  Last Update  10000  Hello  World  4608  validated  10/10/12  21:46:46  10001  Quick  Test  885  2 of 9  10/12/12  19:47:51  Figure 3: Campaign States 5.4.13.5 campaign revert Description Revert a campaign that was previously activated. Syntax campaign revert <id> Parameter <id> The identification number of the campaign 5.4.13.6 campaign stop Description Stop a campaign. When a campaign is stopped, it can never be started again, but remains visible for query purposes. Syntax campaign stop <id> Parameter <id> The identification number of the campaign 5.4.14 cd Description Display the current directory or change to the specified directory. Syntax cd [<path>] Parameter <path> Relative or absolute directory path (change location) Example Perform a relative directory change to the directory act/svc. shell> cd act/svc Change to a higher directory level. shell> cd .. Show the current active directory. shell> cd sys:act/svc 5.4.15 cd Description Display the current directory or change to the specified directory. Syntax cd [<path>] Parameter <path> Relative or absolute directory path (change location) Example Perform a relative directory change to the directory act/svc. shell> cd act/svc Change to a higher directory level. shell> cd .. Show the current active directory. shell> cd sys:act/svc 5.4.16 copy Description Copy one file from one location to another. The default access level is 1. Syntax copy <sfile> <dpath|dfile> Parameter <sfile> Source file to copy <dpath> Destination path to copy the file to <dfile> New file name Example Copy the file main.lua to the directory act/svc/test. # copy main.lua act/svc/test 5.4.17 del Description Delete a file. The default access level is 1. Syntax del <file> Parameter <file> File to delete Example Delete the file stuff.lua. # del stuff.lua 5.4.18 dir Description Display the contents of the current or specified directory. Syntax dir [<dirpath>] Parameter <dirpath> Relative or absolute directory path to display Example Display the contents of the current directory. shell> dir D-----0 01/01/2010 00:00:00 act D-----0 01/01/2010 00:00:00 data D-----0 01/01/2010 00:00:00 logs Found 0 files using a total of 0 bytes. 5.4.19 dl Description Starts a Y-Modem download session. Syntax dl [baud=<baud rate>] Parameter <baud rate> The baud rate to use for the transfer. The baud rate is reset to its current value following the transfer. 5.4.20 email Description Sends an email via M2M SMTP. If the command is invoked without any parameters while an email is being sent, displays the status. Syntax email [<destination address> <subject> <body>] Parameter <destination address> Specify the email address of the recipient <subject> Specify the text used for the subject line <body> Specify the text used in the main body of the email Example Show an email being sent, followed by periodically querying the status. shell> email john.doe@orbcomm.com test "This is a test" Sending email. shell> email Sending email in progress; cannot send another. shell> email Sending email in progress; cannot send another. shell> email Sending email has completed with status Success. 5.4.21 exit Description Changes to access level 0. Equivalent to the command ‘access 0’ Syntax exit Parameter None Example Show exiting from level 1. shell:1> exit shell> 5.4.22 ftp Description Starts an FTP transfer. If the command is invoked without any parameters while a transfer is outgoing, displays the transfer status. Syntax ftp [<source> <destination>] Parameter [sat | cell] Select whether the operation is carried out over satellite or cellular. If neither is specified, cellular is used if available, but falls back to satellite otherwise. <source> Specify an FTP URL or a file path. If an FTP URL is specified, the operation is a GET; otherwise, a PUT if performed. The syntax of the FTP URL is as follows: ftp[s]://[<login>[:<password]@]<host>[:<port>]/<remotePath> <destination> Specify an FTP URL or a file path. If an FTP URL was specified as the source, then this must be a file path, and vice-versa Example Show an FTP PUT operation, followed by periodically querying the status of the transfer. shell> ftp /test.txt ftp://bob_t:****@ftp.orbcomm.com/test.txt Transfer started. shell> ftp FTP transfer in progress; cannot start another. 37 bytes have been transferred so far. shell> ftp FTP transfer in progress; cannot start another. 37 bytes have been transferred so far. shell> ftp FTP transfer has completed; 37 bytes were transferred. 5.4.23 geo Description Issue a geofence command. Syntax geo ?|help|<command> Parameter ? or help List the available geo commands <command> Geo command Example shell> geo ? Available commands: ? -Display this help help -Display this help show -Display geofence information 5.4.23.1 geo show Description Display geofence configuration information. Depending on the arguments provided, it can show either configuration of the geofence service as a whole, or for individual fences or all fences. Syntax geo show [all|[<fence number> [<fence number> …]]] Parameter all Displays all the defined fences. <fence number> The number of the fence we wish to display (0-127). If none are specified, it displays configuration for the geofence service. Example Display geofence service information. shell> geo show There are 2 fence(s) defined, of which 2 are enabled. Next fence check in 58 seconds. Status of last fence or hysteresis check: Success Last successful fence check: fixTime=1457621049 lat,long=42.7749,-78.7894 speed=50.3km/h heading=8.0 fixAge=5s Display information for fences 0, 1, and 2. shell> geo show 0 1 2 Fence #000: enabled=y type=Circle alarm=Both status=Outside t0="Depot" Fence #001: enabled=y type=Polygon alarm=Entry status=Inside t2="USA" Fence #002: not defined t0="restricted area" t2="Canada" Display all the defined fences. shell> geo show all Fence #000: enabled=y type=Circle alarm=Both status=Outside t0="Depot" Fence #001: enabled=y type=Polygon alarm=Entry status=Inside t2="USA" 5.4.24 getcfg Description Display the current configuration parameters. Refer to protected parameters for more details. Aux is only available on some device models. Syntax getcfg Parameter None Example Display the current configuration parameters. shell> getcfg Parameter bootchannel userled  Value main true  DescrBoot User  iption channel LED enable  configuration (main|aux)  bootlevel  1  Boot menu acc ess  level  firmwareled  true  Firmware LED  enable  5.4.25 idp Description Issue an IsatData Pro modem command. Syntax idp ?|help|<command> Parameter ? or help List the available IsatData Pro commands <command> IsatData Pro commands Example shell> idp ? Available commands: ? -Display this help getmetrics -Get a metrics block getsreg -Get an S-register value help -Display this help info -Display IDP modem information setsreg -Set an S-register value status -Display IDP modem status syslog -Display the IDP modem syslog 5.4.25.1 idp getmetrics Description Query the IsatData Pro modem event metrics. Syntax idp getmetrics <class> <subclass> Parameter <class> Specify the class of the event metrics <subclass> Specify the subclass of the event metrics Example shell> idp getmetrics 3 1 MTID = 1028076 timestamp = 515015520 class = 3 subclass = 1 priority = 4 metric  01  =  143039  metric  02  =  6  metric  03  =  2  metric  04  =  2  metric  05  =  1  metric  06  =  0  metric  07  =  0  metric  08  =  0  metric  09  =  0  metric  10  =  0  metric  11  =  0  metric  12  =  0  metric  13  =  0  metric  14  =  0  metric  15  =  20  metric 16 = 35 metric 17 = 4820 metric 18 = 4000 metric 19 = 29300 metric 20 = 273 metric 21 = 863211 metric 22 = 91 metric 23 = 10 metric 24 = 0 5.4.25.2 idp getsreg Description Get the contents of an IsatData Pro modem S register. Gets an S register value. Some S registers are not accessible (0, 3-8, 10, 39-41, 50-51, 55-57, 60-64, 80-81, 85, 88-123). Syntax idp getsreg <register #> Parameter <register #> S register number to get Example Get and display the contents of S register 54 (S54). shell> idp getsreg 54 S-register 54 = 5 5.4.25.3 idp setsreg Description Set an IsatData Pro modem S register to a specific value. Sets an S register value. Some S registers are not accessible (0, 3-8, 10, 39-41, 50-51, 55-57, 60-64, 80-81, 85, 88-123). Syntax idp setsreg <register #> <value> Parameter <register #> S register number to set <value> Value to set Example Set S-register 52 (S52) to 1. shell> idp setsreg 52 1 S-register 52 set to 1 5.4.25.4 idp info Description Display the static information about the IsatData Pro modem. Syntax idp info Example shell> idp info Modem model: ST 6XXX Firmware version: 3.001 Mobile ID: 01028076SKY0DD9 Hardware version: 1.0 Protocol version: 8 Reset reason: 6 (software) Release version: 3.1 uC Boot version: 3.1 uC Appl version: 3.1 DSP Boot version: 3.1 DSP Appl version: 3.1 DSP DB version: 0.13 5.4.25.5 idp status Description Display dynamic status information about the IsatData Pro modem. GPS Fix Type: This information is for advanced or diagnostic purposes. The GPS fix type status displayed in the response does not always reflect the most recent GPS position report provided by the position service. The status may also reflect a less accurate GPS fix used internally by the modem. Syntax idp status Example shell> idp status Global Status: Virtual Carrier ID: 6 Subframe number: 143089 Configuration ID: 2 Beam number: 2 SIP/Oper/Var access: 0 / 0 / 0 Average C/No: 48.1 dBHz Control state: 10 (Active) State Flags: Registered Beam search enabled GPS Valid Last GPS info: Fix type: 3 (3D high precision) Latitude: 45.298276666667 Longitude: -75.920025 Number of PRNs: 5 Maximum PRN C/No: 42.0 dBHz 5.4.25.6 idp syslog Description Display the contents of the IsatData Pro modem syslog. Syntax idp syslog Example Display the current IsatData Pro modem syslog. shell> idp syslog 1970/01/01 00:00:12.188 gnss.warn[24]: Cached NMEA buffer full. 1970/01/01 00:00:12.209 gnss.warn[24]: Cached NMEA buffer full. 1970/01/01 00:00:13.104 gnss.warn[24]: Cached NMEA buffer full. 1970/01/01 00:00:13.142 gnss.warn[24]: Cached NMEA buffer full. 1970/01/01 00:00:13.188 gnss.warn[24]: Cached NMEA buffer full. 1970/01/01 00:00:13.208 gnss.warn[24]: Cached NMEA buffer full. 2017/04/27 17:47:10.103 frag.err [18]: No Rx Slot: vcid 6 config 2, beam 3, BHP 1 5.4.26 info Description Display the information about last reset reason, terminal hardware, uptimes, and loaded software versions. Syntax Info [id|reset|variant]  Parameter  id  Display the unique hardware ID of the terminal  reset  Optional -display the reason for the reset variant  Display the reset reason details  Example  Display the current ST terminal information.  shell>  info  Terminal  info  Manufacturing ID: H/W variant: H/W revision: H/W Processor clock: H/W Reset reason: S/W Reset cause: Lua heap size: Uptime: Power save time:  ABC123 1 7 32 6 (SOFTWARE) 8 (BOOT IDLE) 1920K 0 days, 0 hours, 0 days, 0 hours,  3 0  mins, mins,  28 0  secs secs  (0.00%)  Boot  loader  info  Software version: Build date:  x.0.1 Jun 20  (Release) 20xx  Build  time:  12:51:20  Application firmware Software version: Build date:  info  x.0.1 Jun 20  (Release) 20xx  Build  time:  12:55:36  Lua  API  level:  33  Lua  compatibility  level:  30  Lua  Services  Framework  Version:  x.0.1  Build date:  Jun 20 20xx  Build time: 14:26:00 API level: 11 Uptime: 0 days, 0 hours, 3 mins, 28 secs Idle time: 0 days, 0 hours, 3 mins, 5 secs Package version: 4.1.0.6174 Display the last reset information showing a crash log of an exception. shell> info reset Last reset information: Hardware reset reason: 6 (SOFTWARE) Software reset cause: 2 (EXCEPTION) Software crash log: *** System Fault #5 (Bus Fault) *** MSP = 20003C68 PSP = 20006018 <== Active (Task) Active Task: CmdLine (prio= 22) Stacked Registers: R0= 30000000 R8 = 00000018 R1= 00000001 R9 = 64000534 R2= 00000000 R10= 10101010 R3= 00000075 R11= 11111111 R4= 00000001 R12= 00000075 R5= 20002686 LR = 08033E0B R6= 00000000 PC = 08033E8C R7= 00000005 PSR= 01000000 Fault cause: Imprecise data bus error Status Registers: CFSR= 00000400 (UFSR= 0000, BFSR= 04, MMFSR= 00) HFSR= 00000000 DFSR= 00000000 Display the hardware variant of the terminal. shell> info variant ST 6100 Display the hardware ID of the terminal. shell> info id 4311741230334632FF31D53E Display information about the last reset. In this case, there is no crash log. shell>  info  reset  Last  reset  information:  Hardware  reset  reason:  6  (SOFTWARE)  Software  reset  cause:  2  (EXCEPTION)  Software  crash  log:  *** System Fault #5 (Bus Fault) *** MSP = 0x20003DC8 PSP = 0x20005FF0 <== Active GMK Active Task: CmdLine (prio= 14) Stacked Registers: R0 = 0x00000000 R12 = 0x00000075 R1 = 0x00000001 LR = 0x0801A06D R2 = 0x00000000 PC = 0x0801A0DC R3 = 0x00000075 PSR = 0x01004000 Fault Status Registers: CFSR = 0x00000400 BFAR = 0xE000ED38 HFSR = 0x00000000 DFSR = 0x00000000 In this example, the last reset was caused by an exception and the details of the exception are displayed in the crash log. 5.4.27 listv Description List the information about the current file system volumes. Syntax listv Example Sizes Clusters Volume (bytes) Volume  Label  Sector  Cluster  Total  /  Free  Size  Free  Used  A:  System  2112  2112  2720  /  2278  5744640  4811136  16%  5.4.28 log Description Issue a log command of the log service. Syntax log ?|help|<command> Parameter ? or help List the available log commands <command> Log command Example shell> log ? Available commands: ? -Display this help clear -Clear all log files for a specified log type count -Show the number of remaining entries that match the filter filter -Set a new query filter help -Display this help next – Show log entries that match the filter 5.4.28.1 log count Description Display the number of remaining number of log entries that match the current filter. Syntax log count <msg|dbg> Parameter <msg|dbg> Select the message or debug log Example Show the number of remaining message logs. shell> log count msg Number of matching entries : 63 First entry sequence number: 1 First entry timestamp : 1308149795 (Wed Jun 15 14:56:35 2011) Last entry sequence number : 63 Last entry timestamp : 1308237756 (Thu Jun 16 15:22:36 2011) Show the number of remaining message logs again after five logs have been retrieved. shell> log next type=msg maxEntries=5 ... shell> log count msg Number of matching entries : 58 First entry sequence number: 6 First entry timestamp : 1308170026 (Wed Jun 15 20:33:46 2011) Last entry sequence number : 63 Last entry timestamp : 1308237756 (Thu Jun 16 15:22:36 2011) 5.4.28.2 log filter Description Sets a query filter for either the message or debug log. The filter applies to all subsequent count or next commands form the shell for that log. Syntax log filter type=<msg|dbg> [option=<opt>] Parameter <type>=<msg|dbg> Apply the filter to the message or debug log <opt> seqStart=<N> Filter out log records that have a sequence number smaller than N seqEnd=<N> Filter out log records that have a sequence number greater than N timeStart=<N> Filter out log records that have a time stamp smaller than N timeEnd=<N> Filter out log records that have a time stamp greater than N reverse=<true|false> Specifies the direction of the log search (default: false) include=<sin[…,min]> Adds the SIN and optional MIN list to the include list. Multiple includes can be used to specify more than one SIN. This only applies for the message log filter. include=<sin,sin,…> Specifies a list of SIN values to be included. This form only applies for the debug log filter. levels=<bitMask> Specifies debug log levels (default: all). This only applies for the debug log filter. Example Set the message filter to select log entries 100 through 120, in reverse order. shell> log filter type=msg seqStart=100 seqEnd=120 reverse=true Set the message filter to select messages where sin=16, min=1, 2 or 3 after the first 1000 logs. shell> log filter type=msg seqStart=1001 include=16,1,2,3 Set the message filter to select messages where sin=16, min=1, 2 or 3, or sin=18, min=4, 5 or 6 in the first 1000 logs. shell> log filter type=msg seqEnd=1000 include=16,1,2,3 include=18,4,5,6 Set the message filter to select all message logs where sin=20 (all min values). shell> log filter type=msg include=20 Set the debug filter to select all debug logs for time stamps between 1308225600 and 1308229200 (12 pm to 1 pm on June 15th, 2011), where the level is 0, 1, 2 or 3. shell> log filter type=dbg timeStart=1308225600 timeEnd=1308229200 levels=15 Reset the debug filter to include all debug logs shell> log filter type=dbg 5.4.28.3 log next Description Display the next log entry matching a specified filter. Syntax log next type=<msg|dbg> [<option>=<val>] Parameter Type=<msg|dbg> Apply the filter to the message or debug log <option> max=<val> Sets the maximum number of entries detail=<true|false> Controls whether detailed log entries are shown. Default is false. Example Display the next two log entries that match the message log filter. shell> log next type=msg max=2 seq#=1 time=1308149795 sin=16 min=6 dir=RETURN seq#=2 time=1308159594 sin=16 min=6 dir=RETURN Display the next six log entries that match the message log filter, with extra detail. shell> log next type=msg max=6 detail=true seq#=3 time=Wed Jun 15 17:55:44 2011 svc.system:termReset(RETURN) fields: seq#=4 time=Wed Jun 15 18:07:41 2011 svc.system:termReset(RETURN) fields: seq#=5 time=Thu Jan 1 00:00:11 1970 svc.system:termReset(RETURN) fields: seq#=6 time=Wed Jun 15 20:33:46 2011 svc.system:termReset(RETURN) fields: seq#=7 time=Wed Jun 15 20:34:11 2011 svc.system:timeSync(RETURN) fields: time=1308170051 seq#=8 time=Wed Jun 15 20:38:38 2011 svc.system:termReset(RETURN) fields: Display as many log entries as possible that match the debug log filter. shell> log next type=dbg seq#=1 time=1308230577 level=2 SIN=24 log="svcmgr: service 'filesystem' terminated" seq#=2 time=1308230578 level=2 SIN=24 log="svcmgr: spawning filesystem.entry()" seq#=3 time=1308234872 level=2 SIN=24 log="svcmgr: service 'system' terminated" seq#=4 time=1308234873 level=2 SIN=24 log="svcmgr: spawning system.entry()" 5.4.28.4 log clear Description Clear the log files associated with the given log type. Syntax log clear <msg|dbg|both> Parameter <msg|dbg|both> Select the message or debug log, or both 5.4.29 lua Description Execute a Lua expression or enter a Lua interactive environment. If an expression is provided, it is compiled and executed immediately. If the expression is not a complete statement, then the shell drops to the lua+ prompt to ask for more input to complete the Lua expression. A special operator (=) can be placed at the start of an expression that causes the shell to execute the expression, and display the returned value using the dumpvar() utility. The command requires level 1 access and is locked. The Lua end-of-file command is Ctrl-D. Syntax lua [<expression>] Parameter <expression> Optional Lua expression to execute Example Call the Lua function dumpvar() with the Lua table svc.shell as an argument. shell> lua dumpvar(svc.shell) ["table: 6407dcc0"] = { --table: 6407dcc0 (count= 0) properties = { --table: 6407d9c8 (count= 0) }; unregister = function: 64086fd0; _PACKAGE = "svc."; attach = function: 640871a0; detach = function: 640871f0; _VERSION = "1.3.1"; _SIN = 26; register = function: 64086fb0; dumpHelp = function: 64086c98; _NAME = "svc.shell"; init = function: 64087410; entry = function: 64086cd8; _M = ref"table: 6407dcc0"; onTermination = function: 640873d0; onConfigChange = function: 64086cb8; }; Demonstrate the use of the = operator to display the result of an expression. shell> lua os.date() shell> lua =os.date() result = { --table: 6403db20 (count= 1) [1] = "Thu Mar 24 15:23:31 20xx"; }; 5.4.30 mem Description Displays the current size and usage of the Lua system heap. Syntax mem [gc|info] Parameter gc Optionally perform a full garbage collection before displaying the memory info Display detailed information about the free memory and the number of fragmented chunks of memory. This option is available on terminals. Example Display the current memory usage. shell> mem Used heap memory: 1146K of 3584K (32%) Display the current memory usage after forcing a full garbage collection. shell> mem gc Used heap memory: 433K of 960K (45%) Display detailed memory information . shell> mem info Heap size: 3670016 Used heap: 1287088 Total free heap: 2382928 Contiguous free heap: 2228576 Fragmented free list: (154312 bytes) 137 chunks <= 16 bytes 2 chunks > 16 and <= 32 bytes 1 chunks > 64 and <= 128 bytes 36 chunks > 128 and <= 256 bytes 24 chunks > 256 and <= 512 bytes 14 chunks > 512 and <= 1024 bytes 12 chunks > 1024 and <= 2048 bytes 6 chunks > 2048 and <= 4096 bytes 6 chunks > 4096 and <= 8192 bytes 4 chunks > 8192 and <= 16384 bytes 1 chunks > 16384 and <= 32768 bytes 5.4.31 mkdir Create a directory. The parent directory must exist. The default access level is 1. Syntax mkdir <path> Parameter <path> Path of directory to create Example Create the directory test in the current directory. shell> mkdir test 5.4.32 move Description Move a file/directory. The default access level is 1. Syntax move <filename> <destination> Parameter <filename> Source file or directory name with or without path <destination> New name of file or directory with or without path Example Move a debug log to the current directory. shell> move logs/dbgLog00.dat . Rename a file using move. shell> move main.lua old.lua 5.4.33 msg Description Issue a messaging command to send messages via the transport service. Syntax msg ?|help|<command> Parameter ? or help List the available msg commands <command> msg command Example shell> msg ? Available commands: ? -Display this help add -Add a custom message for Tx cancel -Cancel message transmission help -Display this help list -List currently queued Tx messages 5.4.33.1 msg add Description Adds a custom message to the transmit queue for transmission over a transport. If successful, the message is queued for transmit and its reference number is displayed. This function allows you to queue up to 30 messages per minute. Note: Shell commands are limited to 512 characters. A return message with SIN 18 (message) and MIN 1 is used. Syntax msg add [<option>=<val>] <data> Parameter <option> send=<true|false> Specifies if the message should be sent (default: true) log=<true|false> Specifies if the message should be logged (default: false) priority=<n> Sets the message priority (1 -4) (default: 1) retry=< true|false> Specifies if retries are attempted (default: false) lifetime=<N> Specifies the lifetime of the message (1-1440 minutes) (default: 60 minutes) transports=<N1,T1…> Specifies the transport and time-out to use for the message. Values must be in transport/time-out pairs (satellite-cellular terminals). interval=<N> Specifies the retry interval to use for the message, if retry is true multiplier=<N> Specifies the retry multiplier to use for each retry attempt, if retry is true duplicate=<Allow|Replace|Extend> Sets the message replacement policy persistent=<true|false> Specifies if the message should be saved in nonvolatile memory dispersion=<N> Specifies if the message should be delayed <data> Sequence of strings, quoted strings, decimal byte values, or hexadecimal byte values are prefixed with 0x. Example Queue “this is a test” using all the defaults. shell> msg add "this is a test" Custom message queued, reference number is 4 Queue “hello\r\n” at priority 4 and a lifetime of 120 minutes. A copy is also logged. shell> msg add log=true priority=4 lifetime=120 "hello" 0x0D 0x0A Custom message queued, reference number is 5 Queue a message to be logged, but not sent. shell> msg add “This is a log test” send=false log=true Custom message queued, reference number is 8 5.4.33.2 msg cancel Description Cancel a message that has been queued for transmit. Syntax msg cancel <reference #|ALL> Parameter <reference #|ALL> Reference number of the message to cancel Example Cancel message 5. shell> msg cancel 5 Message 5 cancelled 5.4.33.3 msg list Description List information about a specific set of messages or all the messages in the transmit queue along with the last five messages that have been completed. The output is displayed as follows: shell> msg list Ref# SIN MIN Status S L PQ R P Life Age T Att Last Modif. Queued Time 1 18 1 Success N Y N N 3 60 0 0 1 09/15/14 17:49:27 09/15/14 17:49:27 2 19 1 Success Y N N N 3 60 0 1 1 09/15/14 17:49:54 09/15/14 17:49:40 The displayed fields are as follows: • Reference Number • SIN • MIN • Message status can be one of: • Success -message successfully transmitted • XX.XX% or In_progress -message is currently being transmitted • Failure -Failed to transmit the message • Cancelled -Message was cancelled • Invalid -Message is invalid • Corrupted – Persistent message corruption • Delayed – Message is delayed due to dispersion • Send flag (Y or N) • Log flag (Y or N) • Persistent queue flag (Y or N) • Retry flag (Y or N) • Priority (1-4) • Lifetime, in minutes • Age of the message, in minutes. For delayed messages, this value will be negative if the message has not been scheduled yet. • Transport being used • 0 – No transport was used (log only) • 1 – The IDP modem • All other values are reserved • Transmit attempt • Message’s last modification time stamp • Message’s queued time stamp Syntax msg list [<reference #> [<reference #> > …]] Parameter <reference #> Reference number of the message to list Example List all the messages in the transmit queue along with the last five completed messages. shell> msg list Ref# SIN MIN Status S L PQ R P Life Age T Att Last Modif. Queued Time 1 18 1 Success N Y N N 3 60 0 0 1 09/15/14 17:49:27 09/15/14 17:49:27 2 19 1 Success Y N N N 3 60 0 1 1 09/15/14 17:49:54 09/15/14 17:49:40 3 19 2 Success Y N N N 3 60 0 1 1 09/15/14 17:49:54 09/15/14 17:49:40 4 19 2 Success Y Y N N 3 60 0 1 1 09/15/14 17:50:29 09/15/14 17:50:09 5 19 1 Success Y Y N N 3 60 0 1 1 09/15/14 17:50:24 09/15/14 17:50:09 List the information for message two and four. shell> msg list 2 4 Ref# SIN MIN Status S L PQ R P Life Age T Att Last Modif. Queued Time 2 19 1 Success Y N N N 3 60 0 1 1 09/15/14 17:49:54 09/15/14 17:49:40 4 19 2 Success Y Y N N 3 60 0 1 1 09/15/14 17:50:29 09/15/14 17:50:09 5.4.34 msg override del Description Delete the message option overrides for a MIN, all the MINs of a SIN, or all the MINs of all the SINs. Syntax msg override del sin=all|<SIN> [mins=<MIN1>[,<MIN2>]...] Parameter sin=<SIN> SIN of the target service, or all for all SINs mins=<MIN1>[,<MIN2>]...] Optional list of MINs Example Delete all overrides shell> msg override del sin=all Ok Delete overrides for SIN 128 shell> msg override del sin=128 Ok Delete overrides for SIN 128 and MIN 2 shell> msg override del sin=128 mins=2 Ok Delete overrides for SIN 128, MINs 2, 3, and 7 shell> msg override del sin=128 mins=2,3,7 Ok 5.4.35 msg override get Description Query the message option overrides for a MIN, all the MINs of a SIN, or all the MINs of all the SINs.or change the message option overrides of a MIN. Omitted options imply the option is not overridden. Syntax msg override get sin=all|<SIN> [mins=<MIN1>[,<MIN2>]...] Parameter sin=<SIN> SIN of the target service, or all for all SINs mins=<MIN1>[,<MIN2>...] Optional list of MINs Example Display overrides for all SINs and MINs shell> msg override get sin=all SIN MIN Log Send Lifetime Pri Pers Duplicate Disper Retry Intvl Mult Transports 128 1 Yes Yes 120 1 Replace 1,2 128 2Yes No 130 1 60 4No Extend Yes 10 2 Ok Display overrides for SIN 144 shell> msg override get sin=144 SIN MIN Log Send Lifetime Pri Pers Duplicate Disper Retry Intvl Mult Transports 144 11 Yes Yes 120 1 Replace 1,2 144 12 Yes Yes ReplaceOldest 10 1,10,2,1 Ok Display overrides for SIN 128 and MIN 1 shell> msg override get sin=128 mins=1 SIN MIN Log Send Lifetime Pri Pers Duplicate Disper Retry Intvl Mult Transports 128 1 Yes Yes 120 1 Replace 1,2 Ok 5.4.36 msg override set Description Configure or change the message option overrides of a MIN. Omitted options imply the option is not overridden. Syntax msg override set sin=<SIN> min=<MIN> <option1>=<val> [<option2>=<val> …] Parameter sin=<SIN> SIN of the target service. min=<MIN> MIN to configure. <option> Any combination of the following log=<true|false> Specifies if the message should be logged send=<true|false> Specifies if the message should be sent. transports=<N1, T1...> Specifies the transports and time-outs to use for the message. Values must be in transport number / transport time-out pairs priority=<n> Sets the message priority (1-4) lifetime=<minutes> Specifies the lifetime of the message (1-2103840 minutes) persistent=<true|false> Specifies if the message is persistent duplicate=<Allow|Replace|Extend|ReplaceOldest> Sets the message replacement policy dispersion=<minutes> Specifies a delay for sending the message (0-60 minutes) retry=<true|false> Specifies if the message should be sent interval=<minutes> Specifies the retry interval to use for the message, if retry is true multiplier=<n> Specifies the retry multiplier to use for the message, if retry is true Example Set SIN 128, MIN 1 to be logged and sent over satellite only with 120 minutes queue lifetime, priority 1, and replacing any existing message with the same SIN and MIN. shell> msg override set sin=128 min=1 log=true lifetime=120 transports=1,2 priority=1 duplicate=Replace Ok Set SIN 128, MIN 2 to be logged and not to be sent shell> msg override set sin=128 min=2 log=true send=false Ok 5.4.37 msg store Description Performs an action on the message store. Syntax msg store clear|view|rebuild|gc [<sin> <min>] Parameter clear When this keyword is specified, the specified message stores are purged. view When this keyword is specified, the specified message stores are displayed on the console. rebuild When this keyword is specified, the index is rebuilt for the specified message stores. gc When this keyword is specified, the specified message stores are garbage-collected. <sin> The optional Service Identification Number (SIN). If not specified, the action applies to all message stores. <min> The optional Message Identification Number (MIN). If not specified, the action applies to all message stores for the given SIN. 5.4.37.1 msg add Description Adds a custom message to the transmit queue for transmission over a transport. If successful, the message is queued for transmit and its reference number is displayed. This function allows you to queue up to 30 messages per minute. Note: Shell commands are limited to 512 characters. A return message with SIN 18 (message) and MIN 1 is used. Syntax msg add [<option>=<val>] <data> Parameter <option> send=<true|false> Specifies if the message should be sent (default: true) log=<true|false> Specifies if the message should be logged (default: false) priority=<n> Sets the message priority (1 -4) (default: 1) retry=< true|false> Specifies if retries are attempted (default: false) lifetime=<N> Specifies the lifetime of the message (1-1440 minutes) (default: 60 minutes) transports=<N1,T1…> Specifies the transport and time-out to use for the message. Values must be in transport/time-out pairs (satellite-cellular terminals). interval=<N> Specifies the retry interval to use for the message, if retry is true multiplier=<N> Specifies the retry multiplier to use for each retry attempt, if retry is true duplicate=<Allow|Replace|Extend> Sets the message replacement policy persistent=<true|false> Specifies if the message should be saved in nonvolatile memory dispersion=<N> Specifies if the message should be delayed <data> Sequence of strings, quoted strings, decimal byte values, or hexadecimal byte values are prefixed with 0x. Example Queue “this is a test” using all the defaults. shell> msg add "this is a test" Custom message queued, reference number is 4 Queue “hello\r\n” at priority 4 and a lifetime of 120 minutes. A copy is also logged. shell> msg add log=true priority=4 lifetime=120 "hello" 0x0D 0x0A Custom message queued, reference number is 5 Queue a message to be logged, but not sent. shell> msg add “This is a log test” send=false log=true Custom message queued, reference number is 8 5.4.37.2 msg cancel Description Cancel a message that has been queued for transmit. Syntax msg cancel <reference #|ALL> Parameter <reference #|ALL> Reference number of the message to cancel Example Cancel message 5. shell> msg cancel 5 Message 5 cancelled 5.4.37.3 msg list Description List information about a specific set of messages or all the messages in the transmit queue along with the last five messages that have been completed. The output is displayed as follows: shell> msg list Ref# SIN MIN Status S L PQ R P Life Age T Att Last Modif. Queued Time 1 18 1 Success N Y N N 3 60 0 0 1 09/15/14 17:49:27 09/15/14 17:49:27 2 19 1 Success Y N N N 3 60 0 1 1 09/15/14 17:49:54 09/15/14 17:49:40 The displayed fields are as follows: • Reference Number • SIN • MIN • Message status can be one of: • Success -message successfully transmitted • XX.XX% or In_progress -message is currently being transmitted • Failure -Failed to transmit the message • Cancelled -Message was cancelled • Invalid -Message is invalid • Corrupted – Persistent message corruption • Delayed – Message is delayed due to dispersion • Send flag (Y or N) • Log flag (Y or N) • Persistent queue flag (Y or N) • Retry flag (Y or N) • Priority (1-4) • Lifetime, in minutes • Age of the message, in minutes. For delayed messages, this value will be negative if the message has not been scheduled yet. • Transport being used • 0 – No transport was used (log only) • 1 – The IDP modem • All other values are reserved • Transmit attempt • Message’s last modification time stamp • Message’s queued time stamp Syntax msg list [<reference #> [<reference #> > …]] Parameter <reference #> Reference number of the message to list Example List all the messages in the transmit queue along with the last five completed messages. shell> msg list Ref# SIN MIN Status S L PQ R P Life Age T Att Last Modif. Queued Time 1 18 1 Success N Y N N 3 60 0 0 1 09/15/14 17:49:27 09/15/14 17:49:27 2 19 1 Success Y N N N 3 60 0 1 1 09/15/14 17:49:54 09/15/14 17:49:40 3 19 2 Success Y N N N 3 60 0 1 1 09/15/14 17:49:54 09/15/14 17:49:40 4 19 2 Success Y Y N N 3 60 0 1 1 09/15/14 17:50:29 09/15/14 17:50:09 5 19 1 Success Y Y N N 3 60 0 1 1 09/15/14 17:50:24 09/15/14 17:50:09 List the information for message two and four. shell> msg list 2 4 Ref# SIN MIN Status S L PQ R P Life Age T Att Last Modif. Queued Time 2 19 1 Success Y N N N 3 60 0 1 1 09/15/14 17:49:54 09/15/14 17:49:40 4 19 2 Success Y Y N N 3 60 0 1 1 09/15/14 17:50:29 09/15/14 17:50:09 5.4.38 prop Description Issue a property command Syntax prop ?|help|<command> Parameter ? or help List the available property commands <command> Property command Example shell> prop ? Available commands: ? -Display this help get -Get a property value help -Display this help reset -Reset a property to its default value revert -Revert a property to its last saved value save -Save modified property values set -Set a property value 5.4.38.1 prop get Description Get property values. If no arguments are provided, all properties for all SINs are displayed. If only a SIN is given, all properties for that service are displayed. Syntax prop get [<sin> [<pin>|<name>] [?]]] Parameter <sin> Optional service name or service identification number <pin|name> Optional property identification number or name of property. Wildcards using an '*' are supported to display multiple properties ? Optional parameter that queries the metadata for the property Example Display all the properties of all the services. shell> prop get Display all the properties of the shell service. shell> prop get shell SIN=26(shell) PIN=1(attach) val=true SIN=26(shell) PIN=2(tracebackOnError) val=false Display property 2 of service number 137. shell> prop get 137 2 Display the wakeUpInterval property of the idp service. shell> prop get idp wakeUpInterval SIN=27(idp) PIN=11(wakeUpInterval) val=5_seconds Display all the properties starting with port3of the eio service. shell> prop get eio port3* SIN=25(eio) PIN=23(port3Config) val=Disabled SIN=25(eio) PIN=24(port3AlarmMsg) val=false SIN=25(eio) PIN=25(port3AlarmLog) val=false SIN=25(eio) PIN=26(port3EdgeDetect) val=Disabled SIN=25(eio) PIN=27(port3EdgeSampleCount) val=1000 SIN=25(eio) PIN=28(port3EdgeSampleError) val=20 SIN=25(eio) PIN=29(port3AnalogSampleRate) val=0 SIN=25(eio) PIN=31(port3AnalogLowThreshold) val=1000 SIN=25(eio) PIN=32(port3AnalogHighThreshold) val=2000 SIN=25(eio) PIN=33(port3Value) val=0 Display all the eio service properties with “Thres” in their names. shell> prop get eio *Thres* SIN=25(eio) PIN=9(port1AnalogLowThreshold) val=1000 SIN=25(eio) PIN=10(port1AnalogHighThreshold) val=2000 SIN=25(eio) PIN=20(port2AnalogLowThreshold) val=1000 SIN=25(eio) PIN=21(port2AnalogHighThreshold) val=2000 SIN=25(eio) PIN=31(port3AnalogLowThreshold) val=1000 SIN=25(eio) PIN=32(port3AnalogHighThreshold) val=2000 SIN=25(eio) PIN=42(port4AnalogLowThreshold) val=1000 SIN=25(eio) PIN=43(port4AnalogHighThreshold) val=2000 SIN=25(eio) PIN=49(temperatureLowThreshold) val=-30 SIN=25(eio) PIN=50(temperatureHighThreshold) val=60 SIN=25(eio) PIN=56(powerLowThreshold) val=10000 SIN=25(eio) PIN=57(powerHighThreshold) val=20000 Display the metadata of the IDP wakeUpInterval property. shell> prop get idp 11 ? Name: wakeUpInterval Type: ENUM Storage: VOLATILE Values: 0 -5_seconds 1 -30_seconds 2 -1_minute 3 -3_minutes 4 -10_minutes 5 -30_minutes 6 -60_minutes 7 -2_minutes 8 -5_minutes 9 -15_minutes 10 -20_minutes Display the metadata of the system executionWatchdogTimeout property. shell> prop get system 1 ? Name: executionWatchdogTimeout Type: UNSIGNED Storage: CONFIG Default: 10000 Min: 10000 Max: 65535 5.4.38.2 prop reset Description Reset property values to their default values. If no arguments are provided, all properties for all SINs are reset. If only a SIN is given, all properties for that service are reset. Syntax prop reset [<sin> [<pin>]] Parameter <sin> Optional service name or service identification number <pin> Optional property identification number Example Reset all the properties of all the services. shell> prop reset Reset done Reset all the properties of the service with a SIN of 128. shell> prop reset 128 Reset done Reset the first property of the shell service. shell> prop reset shell 1 Reset done 5.4.38.3 prop revert Description Revert property values to their last saved values. If no arguments are provided, all properties for all SINs are reverted. If only a SIN is given, all properties for that service are reverted. Syntax prop revert [<sin> [<pin>]] Parameter <sin> Optional service name or service identification number <pin> Optional property identification number Example Revert all the properties of all the services. shell> prop revert Revert done Revert all the properties of the service with a SIN of 91. shell> prop revert 91 Revert done Revert property #8 of the system service. shell> prop revert system 8 Revert done 5.4.38.4 prop save Description Save modified property values. If no arguments are provided, all properties for all SINs are saved. If only a SIN is given, all properties for that service are saved. Syntax prop save [<sin> [<pin>]] Parameter <sin> Optional service name or service identification number <pin> Optional property identification number Example Save all the properties of all the services. shell> prop save Save done Save all the properties of the service with a SIN of 130. shell> prop save 130 Save done Save property 2 of the shell service. shell> prop save shell 2 Save done 5.4.38.5 prop set Description Set a property value. The value must match the type of the property. For Boolean properties, a true or false must be provided. For enumerated ranges, the value can be either the integer value of the range or the range element itself. or data properties, the value is specified as a series of decimal or hexdecimal values separated by spaces. Syntax prop set [save] <sin> <pin> <value> Parameter save If this optional keyword is specified, the new value is saved after it has been set <sin> Service name or service identification number <pin> Property identification number <value> Value to set Example Configure pin 23 (port3Config) of the eio (SIN 25) service to be InputPullUp. shell> prop set eio 23 InputPullUp Set done Set the first property of the shell (enabled) to be false. shell> prop set shell 1 false Set the second property of the geofence service (interval) to 300 seconds and save it to nonvolatile storage. shell> prop set save geofence 2 300 Set the traceSuppress3 data property to {0x67, 67}, which is equivalent to {0x67, 0x43}. shell> prop set log traceSuppress3 0x67 67 5.4.39 rename Description Rename a file or directory. The default access level is 1. Syntax rename <old> <new> Parameter <old> File or directory to rename <new> New name Example Change the name of main.lua to main_old.lua. shell> rename main.lua main_old.lua 5.4.40 report Description Generate and query report configuration. Syntax report [<option>=<val>] [<SIN>] [<MIN>] Parameter <option> send=<true|false> Specifies if the report should be queued for transmission (default: true) log=<true|false> Specifies if the report should be logged. (default: false) priority=<n> Sets the message priority (1 -4) (default: 1) retry=< true|false> Specifies if retries are attempted (default: false) lifetime=<N> Specifies the lifetime of the message (1 -1440 minutes) (default: 60 minutes) maxAge=<N> Specifies the maximum age for the GPS fix (1 -600 secs) dispersion=<N> Specifies if the message should b delayed <SIN> Optional SIN of report to send (default: 19) <MIN> The MIN of report to send Example Display the current reporting configuration. shell> report # SIN MIN Enabled Offset Interval 119 1 Yes 15 60 219 2 Yes 0 120 3128 1 No 45 60 4 128 5 Yes 0 1440 Queue report 1 (simpleReport) for transmission using default values. Next Report 07/08/11 15:15:26 07/08/11 16:00:26 n/a 07/09/11 00:00:26 shell> report 1 Report will be queued when position 'msg list' to track the report. Log report 2 (fullReport) without transmitting it. shell> report send=false log=true 2 Report will be queued when position 'msg list' to track the report. 5.4.41 reset Description data is available. Please use data is available. Please use Stop the Lua service environment and reset the terminal. This command performs the same action as stop reset. Syntax reset [now|<channel>] Parameter now Resets the terminal immediately <channel> Specifies which serial channel to use as the console following the reset (“main”, “aux” or “aux2”). 5.4.42 rmdir Description Removes (deletes) a directory. The default access level is 1. CAUTION: Recursive removal of directories could render the terminal inoperative. Syntax rmdir [-recurse] <dirpath> Parameter [-recurse] Recursively removes all files and directories <dirpath> The directory path to remove Example Remove the directory log. shell> rmdir log Recursively remove the act/svc directory. shell> rmdir -recurse act/svc 5.4.43 service Description Issue a service command. Syntax service ?|help|<command> Parameter ? or help List the available service commands <command> Service command Example shell> service ? Available commands: ? -Display this help disable -Disable a service enable -Enable a service help -Display this help list -Display a list of services mem -Display the memory usage of services restart -Restart a service 5.4.43.1 service disable Description Disable the specified service. Syntax service disable <sin> Parameter <sin> Service name or service identification number The specified service will be prevented from starting up on the next Lua Services Framework restart. Mandatory services cannot be disabled. Example Disable the eio service. shell> service disable eio Operation succeeded. shell> The message service cannot be disabled. shell> service disable message SIN 18 cannot be disabled, because it is mandatory. shell> 5.4.43.2 service enable Description Enable the specified service. Syntax service enable <sin> Parameter <sin> Service name or service identification number The specified service will be allowed to start up on the next Lua Services Framework restart. Example Enable the eio service. shell> service enable eio Operation succeeded. shell> 5.4.43.3 service list Description List the current services defined in the system. Syntax service list Example Content varies by terminal model. shell> service list  SIN  Name  Version  Mand? Started? Thread  16  system  3.0.4  YES  YES  thread: 601c08d4[system_entry]  18  message  3.2.3  YES  YES  thread: 60169954[message_entry]  19  report  1.11.2  NO  YES  thread: 6015dc44[report_entry]  20  position  3.0.6  YES  YES  thread: 6011138c[position_entry]  21  geofence  4.1.1  NO  YES  thread: 601c473c[geofence_entry]  22  serial  2.5.1  YES  YES  thread: 601961dc[serial_entry]  23  log  3.0.1  YES  YES  thread: 601c5ad4[log_entry]  24  filesystem  1.5.1  NO  YES  thread: 601c4ddc[filesystem_entry]  25  eio  2.2.5  NO  YES  thread: 6018128c[eio_entry]  26  shell  4.1.5  YES  YES  thread: 60173b84[shell_entry]  27  idp  4.0.2  YES  YES  thread: 6015da5c[idp_entry]  32  campaign  2.2.0  YES  YES  thread: 601c2ae4[campaign_entry]  33  ip  3.0.6  NO  YES  thread: 6014de04[ip_entry]  34  accelerometer  1.4.4  NO  YES  thread: 60167fdc[accelerometer_entry]  35  bluetooth  1.1.2  NO  YES  thread: 601821c8[bluetooth_entry]  5.4.43.4 service mem Description List the static memory usage for all services. The meaning of output headings are as follows: Code Size Service 'main.lua' loaded code size in bytes Prop Size Size of the loaded property metadata in bytes Fwd Size Size of the loaded to-mobile message metadata in bytes Rtn Size Size of the loaded from-mobile message metadata in bytes Totals Total of the row in bytes and kilo-bytes Syntax service mem Example shell> service mem SIN Name Enabled Code Size Prop Size Fwd Size Rtn Size Totals 16  system  YES  43243  628  900  580  45351  44.29 KB  17  power  YES  10915  1044  116  212  12287  12.00 KB  18  message  YES  67649  1684  516  484  70333  68.68 KB  19  report  YES  13086  1844  116  292  15338  14.98 KB  20  position  YES  42623  1860  196  212  44891  43.84 KB  21  geofence  YES  47667  1060  516  340  49583  48.42 KB  22  serial  YES  24079  1668  84  148  25979  25.37 KB  23  log  YES  57179  1812  564  596  60151  58.74 KB  24  filesystem  YES  5208  84  212  212  5716  5.58 KB  25  eio  YES  15747  6756  196  148  22847  22.31 KB  26  shell  YES  82103  292  324  196  82915  80.97 KB  27  idp  YES  2071  900  212  292  3475  3.39 KB  29  cell  YES  5323  2356  292  292  8263  8.07 KB  32  campaign  YES  10702  196  212  196  11306  11.04 KB  33  ip  YES  69138  1588  532  692  71950  70.26 KB  34  accelerometer  NO  35  bluetooth  YES  43833  1172  84  148  45237  44.18 KB  Totals: 540566 24944 5072 5040 575622 562.13 KB 5.4.43.5 service restart Description Restart a specific service. Syntax service restart <sin> Parameter <sin> Service name or service identification number (SIN) Example shell> service restart shell shell> Detaching shell Attaching shell shell> 5.4.44 setcfg Description This command allows for protected configuration parameters to be changed. Any access level can read the parameters, but access level 1 or higher is required to change the parameters. This command is locked. Aux is only available on some terminal models. Syntax setcfg <parameter> <value> Parameter <parameter> Parameter to change <value> Value to set the parameter to Example Change the bootchannel parameter. shell> setcfg bootchannel aux *** error: insufficient access level shell> access 1 Enter level 1 password: shell:1> setcfg bootchannel aux shell:1> 5.4.45 setpass Description Change the password for the specified level. The default is level 1 if no level is provided. Passwords are between 5 and 32 characters long. A blank password can be used to remove the level 1 password. Level 0 does not have a password. This command is locked and interactive. CAUTION: For security reasons, it is recommended that you immediately change this default password. Syntax setpass [<level>] Parameter <level> Access level of password to set (1 only, no other level can be set) Example Set the level 1 password. shell> setpass 1Enter the old password: Enter the new password: Enter the new password again: Success shell> 5.4.46 stop Description Stop the Lua service environment and optionally restart it or reset the terminal. The default access level is 1 to exit the shell to the console prompt. When in access level 0 and an access level 1 password exists, you can restart the LSF with stop start or reset the terminal with a stop reset but cannot exit the shell with only stop or stop now. CAUTION: Using the now option to force an immediate stop skips normal shutdown procedures and could result in lost data Syntax stop [now|start|reset [now|<channel>]] Parameter now Stops the environment immediately without a clean shutdown start Restarts the environment after stopping it reset Resets the terminal after stopping the environment now Resets the terminal immediately <channel> Specifies the serial channel to use as the console following the reset (“main”, “aux” or “aux2”). Example Stop the LSF. shell> stop Gracefully restart the LSF. shell> stop start Force an immediate stop of the LSF. shell> stop now Force an immediate reset of the terminal. shell> stop reset now 5.4.47 threads Description Display the currently active threads being managed by the scheduler. Syntax threads Example shell> threads thread: 640764b0 thread: 64075748 thread: 64076b80 thread: 64087e70 thread: 64076b10 thread: 6407e270 thread: 64076c00 thread: 64076088 thread: 6407e2f0 thread: 64076df0 thread: 640756b8 thread: 640757b8 thread: 6406c988 thread: 6403ca70 5.4.48 tod Description shell_entry  suspended  log_entry  suspended  position_entry  suspended  filesystem_entry  suspended  eio_entry  suspended  Shell Cmd Processor  suspended  report_entry  suspended  idp_entry  suspended  Shell CLI  suspended  geofence_entry  suspended  message_entry  suspended  serial_entry  suspended  system_entry  suspended  CMD:threads  running  Display the terminal time-of-day Syntax tod Example shell> tod Wed Mar 16 19:15:59 2011 UTC 5.4.49 terminaltrace Refer to the log console (user) command for details. 5.4.50 type Description Display the contents of a file. If the file is a compiled Lua file, then the message “Compiled lua file” is displayed. Syntax  type [-hex]  <file>  Parameter  [-hex] Display the file in hexadecimal mode  <file>  File to display  Example  Display what happens when attempting to type a compiled Lua file.  shell> type act/svc/svclist.lua Compiled lua file  Display the same file in hex mode.  shell> 000000 000010  type -hex 1B 4C 75 00 00 00  act/svc/svclist.lua 61 51 00 01 04 04 04 00 00 00 00 00 00 00  04 02  04 03  00 2D  00 00  00 00  00 00  .LuaQ........... ............-...  000020 000030 000040 000050 000060 000070 000080 000090 0000A0 0000B0 0000C0 0000D0  05 05 05 05 05 05 05 05 05 05 05 1E  00 00 00 00 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00 00 00 00 80  00 00 00 00 00 00 00 00 00 00 00 00  41 41 41 41 41 41 41 41 41 41 41 17  40 C0 40 C0 40 C0 40 C0 40 C0 40 00  00 00 01 01 02 02 03 03 04 04 05 00  00 00 00 00 00 00 00 00 00 00 00 00  81 81 81 81 81 81 81 81 81 81 81 04  80 00 80 00 80 00 80 00 80 00 80 08  00 01 01 02 02 03 03 04 04 05 05 00  00 00 00 00 00 00 00 00 00 00 00 00  1C 1C 1C 1C 1C 1C 1C 1C 1C 1C 1C 00  40 40 40 40 40 40 40 40 40 40 40 53  80 80 80 80 80 80 80 80 80 80 80 65  01 01 01 01 01 01 01 01 01 01 01 72  ....A@..??...@?. ....A?..?....@?. ....A@..??...@?. ....A?..?....@?. ....A@..??...@?. ....A?..?....@?. ....A@..??...@?. ....A?..?....@?. ....A@..??...@?. ....A?..?....@?. ....A@..??...@?. ..?..........Ser  0000E0  76  69  63  65  00  FE  10  00  00  00  04  07  00  00  00  73  vice.?.........s  0000F0 000100 000110 000120 000130  79 69 73 6C 32  73 64 73 6F 33  74 70 61 67 32  65 00 67 00 00  6D FE 65 FE FE  00 12 00 16 19  FE 00 FE 00 00  1B 00 17 00 00  00 00 00 00 00  00 04 00 04 04  00 08 00 06 04  04 00 04 00 00  04 00 04 00 00  00 00 00 00 00  00 6D 00 72 65  00 65 00 73 69  ystem.?......... idp.?.........me ssage.?......... log.?.........rs 232.?.........ei  000140 000150 000160 000170 000180 000190 0001A0  6F 00 FE 14 00 00 00 04 74 69 6F 6E 00 FE 13 00 65 70 6F 72 74 00 FE 18 66 69 6C 65 73 79 73 74 04 06 00 00 00 73 68 65 04 09 00 00 00 67 65 6F 00 00 00 00 00 00 00 00  09 00 00 65 6C 66 00  00 00 00 6D 6C 65 00  00 04 00 00 00 6E 00  00 07 04 FE FE 63 00  70 00 0B 1A 15 65 00  6F 00 00 00 00 00 00  73 00 00 00 00 00  69 72 00 00 00 00  o.?.........posi tion.?.........r eport.?......... filesystem.?.... .....shell.?.... .....geofence... ..............  Display the content of the file act/user/svclist.lua  shell> type act/user/svclist.lua Service(128,"test")  5.4.51 ulx  Description Upload a file using the X-Modem protocol.  Syntax ulx [baud=<baud rate> <filename>  Parameter  <baud rate>  The baud rate to use for the transfer. The baud rate is reset to its current value following the transfer. <filename> Specifies the file to transfer 5.4.52 uly Description Upload one or more files and/or directories using the Y-Modem protocol. Syntax uly [baud=<baud rate>] <file|dir> [… <file|dir>] Parameter <baud rate> The baud rate to use for the transfer. The baud rate is reset to its current value following the transfer. <file> File to transmit <dir> Directory to transmit files from 6 SERVICES Most of the end-user functionality on the terminal is implemented by software constructs called services. A service packages up all the information, code and data necessary to carry out its intended functionality on a terminal. This is done so that a service can be loaded or upgraded in one operation, without affecting the rest of the system. It is also for this reason that it is a good idea to keep the service's scope fairly narrow; multiple smaller services are usually easier to deploy and maintain than one large service. A service is identified by a unique service identification number (SIN). This number is used by the Lua Services Framework (LSF) primarily for routing purposes, so that incoming messages can be delivered to the appropriate service. It also allows the LSF to directly implement some operations common to all services, such as setting, getting and saving property values, and responding to queries about service status and information. 6.1 Directory Hierarchy The terminal contains a single file system that is named sys. The act directory contains the current (active) Lua code. It is further divided into three subdirectories: infra for the infrastructure modules, svc for core services, and user for user services. Each service has its own subdirectory below either the svc or user directory. This is where a service's code, property definitions and message definitions are placed. Placing files below this directory is normally handled by the tools in the ORBCOMM Developer Toolkit; it must not be modified. The config directory contains the saved property values for all services. It is again divided into two subdirectories: svc for core and terminal apps, and user for user services. Each service has its own subdirectory below either the svc or user directory. This is where the Lua Services Framework (LSF) saves all property values. All read or write operations within this directory structure are handled by the LSF; it must not be touched by any other code. The data directory contains service-specific nonvolatile data. It is divided into two subdirectories: svc for core and terminal apps, and user for user services. Each service has its own subdirectory below either the svc or user directory. This is where services can save their own personal data. For instance, data and debug logs are saved within /logs directory. Services should not hard code this path, as it may change. Instead, they should call svcmgr.dataPath(), which returns the path where the service should store its files. The service can then use relative paths below that one to organize its data, if needed. 6.2 Code The concepts described in this section refer to user services, even though they apply equally to core and user services. A service is implemented as a Lua module, under sys:/act/user/<name>/main.lua. This module is loaded automatically by the LSF on startup and is made available in the Lua namespace as user.<name>. For instance, if a service named keypad exports a function named button1, the function can be invoked by other services as user.keypad.button1(). The following sections described how this module is organized. 6.2.1 Required Components This section describes the components the module must provide for the LSF to be able to interact properly with it. 6.2.1.1 entry() This function represents the main entry point for the service. It is called by the LSF when all services have been initialized. It is run as a thread and must include the service's main processing loop. Should this function ever throw an error or return somehow, the LSF will automatically restart it. 6.2.1.2 init() This function is called by the LSF shortly after the service has been loaded, so that the service can initialize its resources properly. This function is called once at startup. Even if the service is restarted, this function is not run again; the Lua table representing the service remains unchanged in that case, so there's no need to initialize things again. It is called within a thread after the scheduler has started running, so it has access to all LSF services and can even block if needed. This function must return before the LSF can finish its initialization, so care must be taken to avoid infinite loops. 6.2.1.3 _SIN When the service is first loaded, the LSF inserts this variable as a global within the module table. The service can use this integer value to figure what its SIN is, as can others. 6.2.1.4 _VERSION The service must provide this value to identify its version to the outside world. This is done so that external users can see what is currently on the terminal. This is a free-form string value; there is no predetermined format. 6.2.2 Optional Components This section describes module functions that are called by the LSF if available. 6.2.2.1 onConfigChange() Syntax onConfigChange(changeList) Description This function is called whenever some of the service's configuration properties are changed. If multiple properties are changed together, it is called once. It is also called if an actual change occurs (it is not called when setting a property to the current value). This function must not block and should keep things short. Parameters changeList An array of changed properties; each element is a table with the following fields: pin The changed property's PIN name The changed property's name old The changed property's value val The new property value Returns None 6.2.2.2 onGetVolatile() Syntax onGetVolatile(pin, name) Description This function is called whenever another service requests the value of a volatile property from this service. It must return the current value of the volatile property. This function must not block; if getting a value would require a blocking call, the function must return a cached value instead. Parameters  pin  The requested property's PIN  name  The requested property's name  Returns n/a The property value (the type depends on the property) 6.2.2.3 onSetVolatile() Syntax onSetVolatile(pin, name, val) Description This function is called whenever another service sets the value of a volatile property from this service. This function must not block; if setting a value would require a blocking call, the function must spawn a separate thread to perform whatever actions are necessary. Parameters pin The changed property's PIN name The changed property's name val The new property value Returns None 6.2.2.4 onTermination() Syntax onTermination() Description This function is called when the main service thread is about to be terminated or has terminated unexpectedly. The service can then clean up after itself before it gets restarted. This function must not block and should keep things short. Parameters None Returns None 6.2.2.5 validateConfigChange() Syntax validateConfigChange() Description This function is called whenever another service sets the value of a volatile property from this service. This function must not block; if setting a value would require a blocking call, the function must spawn a separate thread to perform whatever actions are necessary. It should return nil if the property value is valid or an error message otherwise. Parameters  pin  The PIN of the property to validate  name  The name of the property to validate  val  The new value  Returns string An error message, or nil if the value is valid 6.2.3 Extra Code Files Normally, the service's Lua code is stored as a module in user/<name>/main.lua. However, for bigger projects where the source file can grow too large to be easily manageable and maintainable, it becomes necessary to split the code between multiple files. The two ways to accomplish this are described below. The easiest way is to load the extra code into the main module, with the help of the svcmgr.loadCode() function. With this method, all the functions and variables exported by the extra code show up directly in the module’s namespace. As an example, assume that the code below is stored in user/demo/main.lua. --Service: demo --Created: 20xx-07-05 --Version information (required) _VERSION = "1.0.0" --Exported function ‘func1’ function func1() ... end --Run service (required) Function entry() sched.delay(-1) end --Initialize service (required) Function init() local f, err = svcmgr.loadCode('extra.lua') if f then f() else printf('%s: could not load extra.lua, error = %s', _NAME, err) end end And the following extra code is stored in user/demo/extra.lua. function func2() … end On terminal startup, the main service module is automatically loaded from user/demo/main.lua and made available in the user.demo table. The call to svcmgr.loadCode(”extra.lua”) in the service's init function loads the extra code. The two functions can now be used by other code as user.demo.func1 and user.demo.func2. Note how, in this instance, the code in extra.lua is not organized as a module; instead, it simply contains the function func2. The second way to split code out is to use submodules, which are loaded with the standard Lua require function. In this case, the previously defined example would have the content of act/user/demo/main.lua modified as shown below. --Version information (required) _VERSION = "1.0.0" --Exported function ‘func1’ function func1() ... end --Run service (required) Function entry() sched.delay(-1) end --Initialize service (required) Function init() extra=require(“act/user/demo/extra”) end The submodule defining the extra functions can be stored in either act/user/demo/extra.lua or act/user/demo/extra/main.lua, and contains the content shown below: function func2() … end On terminal startup, the main service module is again automatically loaded from act/user/demo/main.lua, and made available in the user.demo table. However, the call to require (act/user/demo/extra) in the service's init function is used to load the extra code this time. The two functions can now be used by other code as user.demo.func1 and user.demo.extra.func2. Note how, in this instance, the code in extra.lua is organized as a module. This is useful for splitting the code and variables exported by a module into separate subsections. 7 PROPERTIES Properties represent attributes of the service. Each service property is assigned a property identification number (PIN), which can be used to access it. Properties are very similar to variables exported by a module, but with some significant enhancements: • Properties can be retrieved, set, reverted, reset and saved via over-the-air messages, CLI commands and Lua APIs by the service manager, while requiring minimal support from the service itself to do so. • Any property can be used inside of message definitions by specifying its SIN and PIN; in to-mobile messages, the value contained in the corresponding field is automatically applied to the property, while in from-mobile messages the field is automatically filled with the property value. • Using the above mechanism to specify properties in a message definition, it becomes trivial to compose message formats that contain only properties; such message formats are then usable as reports by the report service. 7.1 Storage Unlike Lua variables, properties have a storage class assigned to them, which defines how the service uses them. Config properties are used to affect the service’s behavior. For example, if a service needs to perform some actions periodically, a property can be defined to contain the period value. Therefore, you can set the desired value to change how often the service runs. Config property values can be saved to nonvolatile storage, so that they remain available even after a terminal reset or even a power outage. Volatile properties, on the other hand, are used by services to convey status information, or to set temporary values. As the name volatile implies, they are never saved to nonvolatile storage. Any services that define volatile properties must define the onGetVolatile() and onSetVolatile() functions; otherwise the properties always return their default values and are not settable. The LSF provides a list of storage classes as props.Storage that maps the storage class names to their numerical values, and props.StorageStr that maps the numerical values back to the storage class names. The values are props.Storage.CONFIG, which is 0, and props.Storage.VOLATILE, which is 1. 7.2 Types Much like Lua variables, properties have a value type. The LSF provides a list of types as msgs.Types that maps the type names to their numerical values, and msgs.TypesStr that maps the numerical values back to the type names. 7.2.1 Enumeration The msgs.Types.ENUM type is used to map a set of strings to numerical values. It is useful for assigning mnemonics to all possible values of the property, so that they are easier to remember. msgs.Types.ENUM properties have the following attributes, which can be retrieved by a call to svcmgr.getPropDef(): name The name of the property that can be used instead if its PIN when accessing it type The type code for an enumeration property (msgs.Types.ENUM, 0) storage The storage class of the property values A table that maps the ENUM values (strings) to their numerical equivalent valuesStr A table that maps numerical values to their string equivalent default The default value for the property 7.2.2 Boolean The msgs.Types.BOOLEAN type has two possible values, either true or false. msgs.Types.BOOLEAN properties have the following attributes, which can be retrieved by a call to svcmgr.getPropDef ():  name  The name of the property that can be used instead if its PIN when accessing it  type  The type code for an enumeration property (msgs.Types.BOOLEAN, 1)  storage  The storage class of the property  default  The default value for the property  7.2.3 Unsigned Integer The msgs.Types.UNSIGNED type is used when the property can take any positive integral value. Note that due to a Lua limitation (integer values are always stored as signed), unsigned integers are limited to a maximum value of 2147483647 (31 bits). msgs.Types.UNSIGNED properties have the following attributes, which can be retrieved by a call to svcmgr.getPropDef(): name The name of the property that can be used instead if its PIN when accessing it type The type code for an enumeration property (msgs.Types.UNSIGNED, 2) storage The storage class of the property minVal The minimum value that this property can be set to (0 to 2147483647) maxVal The maximum value that this property can be set to (0 to 2147483647) default The default value for the property 7.2.4 Signed Integer The msgs.Types.SIGNED type is used when the property can take any positive or negative integral value. msgs.Types.SIGNED properties have the following attributes, which can be retrieved by a call to svcmgr.getPropDef(): name The name of the property that can be used instead if its PIN when accessing it type The type code for an enumeration property (msgs.Types.SIGNED, 3) storage The storage class of the property minVal The minimum value that this property can be set to (-2147483648 to 2147483647) maxVal The maximum value that this property can be set to (-2147483648 to 2147483647) default The default value for the property 7.2.5 String The msgs.Types.STRING type is used when the property can take any arbitrary string value. msgs.Types.STRING properties have the following attributes, which can be retrieved by a call to svcmgr.getPropDef(): name The name of the property that can be used instead if its PIN when accessing it type The type code for an enumeration property (msgs.Types.STRING, 4) storage The storage class of the property default The default value for the property 7.2.6 Data The msgs.Types.DATA type is used when the property value is an array of bytes. msgs.Types.DATA properties have the following attributes, which can be retrieved by a call to svcmgr.getPropDef(): name  The name of the property that can be used instead if its PIN when accessing it  type  The type code for a data property (msgs.Types.DATA, 5)  storage  The storage class of the property  default  The default value for the property  7.3 Access Properties can be accessed by name, using the properties table of a service. For instance, given a service named demo, which exposes a Boolean property named enabled, one can access the property as shown in the code below: user.demo.properties.enabled = true ... if user.demo.properties.enabled then ... end Of course, if the property is accessed from within the demo service itself, the code can be shortened as shown below: properties.enabled = true ... if properties.enabled then ... end The Service Manager module (svcmgr) also offers an alternate way to access properties, using a SIN and PIN to identify the desired property. Refer to [T405] for a description of the getProp and setProp functions. Note that when accessing volatile properties, a function call is made to either the onGetVolatile or onSetVolatile functions of the appropriate service. This is all transparent to the caller, but it is important for the service implementing these functions to not block and take as little time as possible processing the request. 7.4 Property Values 7.4.1 Enumeration When setting an enum property value, either the string name of the value or the numerical representation can be used. For instance, if a service name demo exposes an enumeration property named priority, with possible values being Low, Normal and High, the code lines below all represent valid property accesses. user.demo.properties.priority = "Low" is equivalent to user.demo.properties.priority = 0 and user.demo.properties.priority = "High" is equivalent to user.demo.properties.priority = 2 When getting an enum property value, the caller always receives the string name of the value. Using the example above, the following code block would be executed when the property is set to High, as expected. if properties.priority == "High" then ... end However, the following code block would never get executed, because the condition is guaranteed to be false. if properties.priority == 2 then ... end 7.4.2 Boolean Boolean properties use the Lua values true and false, both when setting and getting the property. 7.4.3 Unsigned Integer Unsigned properties use Lua numerical values when setting and getting the property. Values can be decimal (0 to 2147483647) or hexadecimal (0x0 to 0x7FFFFFFF). 7.4.4 Signed Integer Signed properties use Lua numerical values when setting and getting the property. Values can be decimal (.2147483648 to 2147483647) or hexadecimal (0x80000000 to 0x7FFFFFFF). 7.4.5 String String properties use Lua string values when setting and getting the property. 7.4.6 Data When setting a data property value, one would normally use a Lua array of numerical values between 0 and 255, inclusive. For instance, if a service name demo exposes a data property named coefficients, the code below could be used to set the property value. user.data.properties.coefficients = {10, 20, 30} However, the code below would not change the property value, as one of the array elements is invalid. user.data.properties.coefficients = {100, 200, 300} As a convenience, a Lua string can also be used to set a data property. user.data.properties.coefficients = "abc" When getting a data property value, the caller receives a string. This is done for efficiency reasons, as a string uses quite a bit less space than an array of the same size. The string.byte function can be used to access the individual values as needed. local temp = user.data.properties.coefficients for i = 1, #temp do print(temp:byte(i)) end ... local arrayCopy = {temp:byte(1, -1)} 8 MESSAGES Message definitions associated with a service define how that service receives and transmits data over-the-air. They divide a message into individual components, called fields, and define the order the fields appear in, and their content. 8.1 Definition This section does not describe how to define a message format, because that operation is best left to the ORBCOMM Developer Toolkit tools; rather, it describes how to programmatically access message definition data, and how that data is structured. The svcmgr.getMsgDef() function is used to retrieve the message definition for a single message, identified by its SIN, MIN and direction. The function returns a table with the following members: name  A name for the message. This is purely for cosmetic reasons, as messages are never referred to by name in code.  fields  This is an array of field definitions. Each field definition entry in the array can contain the following attributes:  name  The field name, used to programmatically refer to the field.  optional  Specifies whether the field is optional within a message; a message with a missing non optional field is deemed invalid. This attribute is itself optional; the field is assumed to not be optional if not specified.  In addition to those field attributes, more can be present based on the field's type, as defined in the following section. 8.2 Field Types Message fields, just like properties, have a value type, which defines what the field can contain. All of the property value types also apply to message fields. Because message fields must provide additional functionality, a few more types apply. 8.2.1 Array The msgs.Types.ARRAY type is used when the field is an array of records. msgs.Types.ARRAY fields add the following attributes to the definition: type The type code for an array field (msgs.Types.ARRAY, 6) size The maximum number of array entries fixed A Boolean indicating whether this is a fixed (true) or variable (false) length field; if not specified, defaults to false fields A recursive list of definitions for the fields in the array records; these fields can be of any type, including nested arrays 8.2.2 Boolean The msgs.Types.BOOLEAN type has two possible values, either true or false. msgs.Types.BOOLEAN fields add the following attributes to the definition: type The type code for an enumeration field (msgs.Types.BOOLEAN, 1) 8.2.3 Contained Message The msgs.Types.MESSAGE type is used to insert a different message inside of the main, enclosing message. For to-mobile messages, no automatic action is taken on the contained message, so it is up to the receiving service to handle it as appropriate. For from-mobile messages, it is up to the sending service to ensure that the field points to an actual message. msgs.Types.MESSAGE fields add the following attributes to the definition: type The type code for an array field (msgs.Types.MESSAGE, 7) 8.2.4 Data The msgs.Types.DATA type is used when the field value is an array of bytes. msgs.Types.DATA fields add the following attributes to the definition: type  The type code for a data field (msgs.Types.DATA, 5)  size  The maximum number of bytes  fixed  A Boolean indicating whether this is a fixed (true) or variable (false) length field; if not specified,  defaults to false  8.2.5 Dynamic Value The msgs.Types.DYNAMIC type is used as a placeholder when the type is not known ahead of time. The actual message contains information about the actual type of the field, and the value. msgs.Types.DYNAMIC fields add the following attributes to the definition: type The type code for an array field (msgs.Types.DYNAMIC, 6) 8.2.6 Enumeration The msgs.Types.ENUM type is used to map a set of strings to numerical values. It is useful for assigning mnemonics to all possible values of the field, so that they are easier to remember. msgs.Types.ENUM fields add the following attributes to the definition: type The type code for an enumeration field (msgs.Types.ENUM, 0) values A table that maps the enum values (strings) to their numerical equivalent valuesStr A table that maps numerical values to their string equivalent size The bit size of the enumeration field, up to a maximum of 16 Note that the size attribute controls how many bits are sent in the binary message. When designing a message format, care should be taken in choosing the right value. Using too small a size could result in problems if new values need to be added in the future; using too big a size wastes space in the binary message sent over-the-air. 8.2.7 Property Value The msgs.Types.PROPERTY type is used as a placeholder for a property value. When processing to-mobile messages, the value is automatically extracted from the message and applied to the specified property. When preparing from-mobile messages for transmission, the property value is automatically added to the message. msgs.Types.PROPERTY fields add the following attributes to the definition: type  The type code for an array field (msgs.Types.PROPERTY, 6)  sin  The SIN identifying the service the property value belongs to  pin  The PIN identifying the specific property value  8.2.8 Signed Integer The msgs.Types.SIGNED type is used when the field can take any positive or negative integral value. msgs.Types.SIGNED adds the following attributes to the definition: type The type code for an enumeration field (msgs.Types.SIGNED, 3) size The bit size of the signed integer field, up to a maximum of 32 8.2.9 String The msgs.Types.STRING type is used when the field can take any arbitrary string value. msgs.Types.STRING adds the following attributes to the definition: type The type code for an enumeration field (msgs.Types.STRING, 4) size The maximum string length fixed A Boolean indicating whether this is a fixed (true) or variable (false) length field; if not specified, defaults to false 8.2.10 Unsigned Integer_field The msgs.Types.UNSIGNED type is used when the field can take any positive integral value. Note that due to a Lua limitation (integer values are always stored as signed), unsigned integers are limited to a maximum value of 2147483647 (31 bits). msgs.Types.UNSIGNED adds the following attributes to the definition: type The type code for an enumeration field (msgs.Types.UNSIGNED, 2) size The bit size of the unsigned integer field, up to a maximum of 31 8.3 Access This section applies to user services. 8.3.1 Received Message When a service receives the RX_DECODED event, it is also given the message as a table with the following members: min The message's MIN fields A table containing all of the message's fields and their values The code sample below shows how to access an incoming message with two fields named f1 and f2. local handle = svc.message.register(_SIN) local msgQ = sched.createEventQ(5, handle, 'RX_DECODED') while true do local q, event, args = msgQ:.wait(-1) if q == msgQ then local msg = args print(msg.fields.f1) print(msg.fields.f2) end end 8.3.2 Sending Message When sending a message, more effort is required because there is no data structure that is used as a starting point. Rather, the service code is responsible for constructing the message from the ground up, and must ensure that not only the message's structure is respected, but that the field values are of the right type; otherwise it fails to send properly. For example, assuming we have an outgoing message definition for MIN 1 that contains a Boolean field named f1, and a string field named f2, the code sample below would send the message correctly. local handle = svc.message.register(_SIN) local fields = {f1 = true, f2 = "test"} local refNo, err = handle:send(1, fields) However, the code sample below would return an error, because the value for f1 does not have the correct type. local handle = svc.message.register(_SIN) local fields = {f1 = {true}, f2 = "test"} local refNo, err = handle:send(1, fields) And the code sample below would also return an error, because the value for f2 does not have the correct type. local handle = svc.message.register(_SIN) local fields = {f1 = true, f2 = 1} local refNo, err = handle:send(1, fields) The message structure becomes important when dealing with array fields; this is discussed in more detail in a later section. 8.4 Message Values Section 7.4 covered how to access property values of all types. Because the same types apply to message fields, the information previously presented is still relevant in this case. The following section focuses on the techniques and limitation for accessing types that are only applicable to message fields. 8.4.1 Array Array fields in messages are accessed using the normal Lua table index mechanism. As an example, assume a message that contains a single array field name coord, which in turn contains two signed integer fields, lat and long. This code sample shows how to access the message. for i = 1, #msg.fields.coord do print(msg.fields.coord[i].lat) print(msg.fields.coord[i].long) end Conversely, this code sample shows how to compose a message with the same format. local fields = sys.createTable(0, 1) fields.coord = sys.createTable(3, 0) for i = 1, 3 do fields.coord[i] = {} fields.coord[i].lat = ... fields.coord[i].long = ... end Alternatively, the code could be shortened as shown below, to allocate the entire structure at the same time. local fields = {coord = {{lat = lat1, long = long1}, {lat = lat2, long = long2}, {lat = lat3, long = long3}}} In the previous code sample, the code to initialize the coord array must have two opening curly braces: one to denote the start of the array itself, and one to denote the start of the array record. Finally, it is important to remember that array elements are tables of fields, and never simple types, so even if each array element only contains one value, it must be named. Using the previous example, and modifying it so that the coord array only contains one value, lat, would look like the example below: local fields = {coord = {{lat = lat1}, {lat = lat2}, {lat = lat3}}} and not like this local fields = {coord = {{lat1}, {lat2}, {lat3}}} or this local fields = {coord = {lat1, lat2, lat3}} 8.4.2 Dynamic Value As stated previously, dynamic values are used when the type of the value being transferred in the message is not known at definition time. Simply setting the message field to its value is problematic in this case: if we get a dynamic field with the value set to 1, is it meant to be signed or unsigned? If it's a string, is it meant to be a string, or a data field? The LSF took the approach of erring on the side of caution, and instead stores dynamic values as tables with In the case where type specifies an enum value, v contains a numeric value, because there is no context as to what the possible enumerated values are. two members:  type  The value type, as per msgs.Types  V  The actual field value  len  Length field, set to 8, 16, or 32, is required in a dynamic field when sending unsigned or signed values  As an example, assume you are receiving a message with a dynamic field named test. This code sample shows how to access the value. local t = msg.fields.test.type if t == msgs.Types.DATA then for i = 1, #msg.fields.test.v do printf("%02X ", msg.fields.test.v:byte(i)) end printf("\n") else print(tostring(msg.fields.test.v)) end Conversely, when sending a message the service code must create the table with the type and v members, as shown below: local fields = {test = {type = msgs.Types.SIGNED, v = 7, len = 8}} 8.4.3 Property Value A property field in a message is used to transmit the value of a property, as previously discussed. The definition for that field contains the SIN and PIN of the property. When receiving a message with a property field, that field is handled directly by the LSF; by the time the service receives the message, the property has been set to its new value and the field is actually removed from the message. When sending a message with a property value, however, the service has two options: • Leave the field blank, and the LSF fills in the value just prior to encoding and sending the message • Fill in a value for the property, and the LSF uses that value when encoding and sending the message, assuming that the value matches the property type As an example, assume you are trying to send a message with a property field named test. The code sample below shows two ways to compose the message: local handle = svc.message.register(_SIN) --Let the system take care of filling in the test field local refNo, err = handle:send(1, {}) --Do it ourselves; this example assumes the property is a Boolean reNo, err = handle:send(1, {test = true}) 8.4.4 Contained Msg When receiving a message with a contained message, the field value is a table with the following members: sin The SIN of the contained message min The MIN of the contained message dir The direction of the contained message, as per msgs.Direction fields The contained message fields As an example, assume you are receiving a message with a contained message field named submsg, which in turn contains a Boolean field named test. This code sample shows how to access the various fields. printf("submsg: sin=%d min=%d dir=%s\n", msg.fields.submsg.sin, msg.fields.submsg.min, msgs.DirectionStr[msg.fields.submsg.dir]) printf("test=%s\n", tostring(msg.fields.submsg.fields.test)) When adding a contained message to a message for sending, care has to be taken to add the appropriate members to the message table. When a service receives a message, it is provided with a table that has two members: min and fields. If adding that message to another container message, the value of the sin and dir members must be provided. local handle = svc.message.register(_SIN) local msgQ = sched.createEventQ(5, handle, 'RX_DECODED') while true do local q, event, args = msgQ:.wait(-1) if q == msgQ then local msg = args local fields = {submsg = msg} --The received message SIN has to be ours fields.submsg.sin = _SIN --The received message direction has to be FORWARD fields.submsg.dir = msgs.Direction.FORWARD end end 9 SCHEDULER The Lua Services Framework (LSF) Scheduler provides a co-operative thread dispatch system and inter-thread communication via broadcast events. 9.1 Threads The LSF scheduler supports concurrent execution via threads. The scheduler threads are based on Lua native co.routines. Like Lua co-routines, the scheduler's threads are cooperative: only one thread executes at a time and it continues to run until it explicitly gives up the CPU. The scheduler provides support for thread names, termination management, timers, and waiting on events. 9.1.1 Thread Management Threads are created by calling sched.spawn() that returns a handle object, which is used to manage the thread. The string name provided to sched.spawn() must be unique. This is required so that threads can later be queried by name. The thread handle can be used to query the name, status, Lua thread ID of the thread. A running thread can be terminated by either calling the terminate() method of the thread handle or calling sched.terminate() with the thread name or handle. A function that is called when the thread terminates can be associated with a thread using the addTerminationHandler() handle method. This function is invoked when a thread terminates, allowing you to perform other thread related cleanup or perhaps restart the thread. The destroy() handler method also terminates the thread if it is running, except that it does NOT call any registered termination handlers. When a thread terminates, either normally or abnormally, the status() method of the handle returns “dead”. The thread is eventually garbage collected like any Lua object if the handle goes out of scope or is set to nil. To explicitly clean up a thread the destroy() method can be called. 9.1.2 Thread Yielding To give up the CPU to allow other threads to run, a thread can yield the CPU by either waiting on an event or calling sched.delay(0) to wait a specific amount of time. A call to sched.delay(0) with a time-out of zero yields the CPU if another thread is ready. Additionally, all calls that wait on events will block/yield the CPU. 9.1.3 Restarting Threads Threads can be setup to be automatically restarted using a termination handler that destroys the original thread, and then respawns the thread. Below is example code that demonstrates a generic method to restart a thread if the enabled property of the service is true. local function terminationHandler(thread, args) thread:destroy() if properties.enabled then trace(args[1], " terminated, respawning") workerThread = sched.spawn(unpack(args)) workerThread:addTerminationHandler(terminationHandler, args) else trace(args[1], " terminated") end end local spawnArgs = {"Worker", workerFunc, 100} workerThread = sched.spawn(unpack(spawnArgs)) workerThread:addTerminationHandler(terminationHandler, spawnArgs) 9.2 Events The LSF uses events to send notifications and data between threads and from the terminal firmware. Events are broadcast entities that can be collected (or ignored) by threads. An event consists of the following components: • <source> -Indicates the source/origin of the event • <event> -event identifier • <arguments> -optional arguments associated with the event 9.2.1 Posting Events Events are broadcast by calling sched.post() with the source, event and optional arguments. If no currently created event queue matches the source and event, then the event is discarded when it is processed. The terminal firmware also posts events, so they are treated the same as events posted from the Lua environment. Event sources and event identifiers can be any Lua type, except nil. For global broadcasts, the LSF uses the service table (svc.system) as the source of its events. The firmware, which does not have any services or tables, uses strings with a leading prefix, like _TIMER. Use a unique local identifier if you want to keep the messaging of two threads private. A good practice is to use empty tables, which are unique by definition. The example below sends private commands to another thread in a module: local cmdSrc = {} local updateCmd = {} local restartCmd = {} . . . --send update command with the new values sched.post(cmdSrc, updateCmd, values) . . . local cmdQ = sched.createEventQ(5, cmdSrc) while true do local _, event, args = cmdQ:wait(-1) if event == updateCmd then --Do update else if event == restartCmd then --Do restart end end The disadvantage of using an empty table is that printing the event for debugging purposes is a bit more difficult. 9.2.2 Event Queue Creation Event queues are used to collect events. An event queue is created with a call to sched.createEventQ() that returns the created queue. The sched.createEventQ() call requires a size (maximum number of events to collect), event source id, and optional event identifier. If the event identifier itself is not specified, then all events with the specified source will be collected. Events are collected in First-in First-Out (FIFO) ordering. When the queue is full, new entries posted to the queue are ignored. Event queues can optionally be given a name by using the name() method. The same method can be used to query the name of an event queue by calling it with no arguments. 9.2.3 Waiting for Events A thread waits for events by calling the event queue wait() method with a time-out value. If the event queue is not empty, the call yields the CPU and then returns immediately with the associated event queue and values, regardless of the time-out value. If the event queue is empty, the behavior depends on the time-out value: • Positive integer time-out Thread blocks until an event is posted or the time-out occurs • -1 Thread blocks until an event is posted • Zero Thread yields the CPU and then returns nil immediately The example below defines a function that waits for a specified number of seconds using a timer and event queue. function waitSeconds(secs) local timer = sys.timer.create() timer:arm(secs * 10) local q = sched.createEventQ(1, '_TIMER', timer) q:wait(-1) end The function sched.delay(0) is implemented in a similar (but more efficient) manner. To wait on multiple event queues, the function sched.waitQ() can be used. It takes a time-out and a list of event queues to wait on. The first queue to receive (or already have) an event will be returned. Below is an example that sets up two event queues and waits on them with a time-out. msgH = svc.message.register(_SIN) local msgQ = sched.createEventQ(5, msgH, 'RX_DECODED') msgQ:name(_NAME .. ": msgQ") local sysQ = sched.createEventQ(1, svc.system, 'SHUTDOWN') sysQ:name(_NAME .. ": sysQ") while true do local q, event, args = sched.waitQ(36000, msgQ, sysQ) if q == msgQ then --Got a to-mobilemessage local args = msg print("Got message with MIN=", msg.min) elseif q == sysQ then if event == 'SHUTDOWN' then --Do shutdown cleanup end elseif not q then print("*** 1 hour TIMEOUT ***") end end 9.2.4 Event Queue The read-only source() and size() queue methods can be used to query the static configuration of an event queue. The count() method returns the current number of entries in the queue. The clear() method can be used to empty the queue, discarding all the entries. This code displays the contents of an event queue and then clears it. --Display the contents of event queue 'q' and then clear it. for i=1,q:count() do local _,event,arg = q:wait(0) print(i, ": ", event, " -", arg) end q:clear() An event queue behaves like standard Lua objects and will be garbage collected if the object goes out of scope or all global references are removed. If desired, an event queue can be explicitly destroyed by calling the destroy() method. 10 LOW POWER OPERATION To conserve power, the terminal can enter power save mode that turns off all the clocks on the hardware board except the real-time-clock (RTC). Any external digital I/O, timer alarm, or a modem signal can wake up the terminal in microseconds to a completely operational state. 10.1 Processing Mode When the Lua environment is running, the terminal can enter power save mode automatically whenever the Lua environment is idle (all threads waiting for an event). The processor can wake up from power save mode from one of the following sources: • Internal RTC Alarm (Lua timer) • External I/O configured as a digital input • RS-232 DTE connect/disconnect events • Accelerometer event • External power connect/disconnect The transition from power save mode to a fully operational state occurs in less than 200 microseconds, which allows the terminal to enter/exit this state between events transparently. 10.1.1 Global Configuration Power save mode is enabled by default and can be disabled by changing the Boolean property powerSave of the system service to false. When disabled, the processor idles between events, and leaves all other subsystems running. 10.1.2 RS 232 UART Config When the terminal enters power save mode, all peripherals are turned off, including the RS-232 UART. If the RS-232 interface is required to remain active to receive data (shell commands, protocol packets, etc.), then entering power save mode must be blocked to prevent the UART from being shut down. The serial service property rs232mainShutdownMode controls the shutdown behavior of the RS-232 UART when power save mode is enabled, as detailed in Table 6. Table 6: RS232 Main Shutdown Mode Configuration Note: The setting of the rs232mainShutdownMode property has no effect on the transceiver configuration. The transceiver must be configured and managed independently. 10.1.3 Low Power Considerations A number of factors, described in this section, must be taken into account to minimize power consumption of the terminal. 10.1.3.1 Automatic Lua Garbage Collection The firmware performs an automatic full Lua garbage collection after a period of Lua inactivity (default is 5 seconds). Depending on the terminal configuration or custom application behavior, this could account for a significant portion of the power consumption of the terminal. For example, if the terminal is configured to sample an analog input every 10 seconds, the terminal by default performs a full Lua garbage collection every 10 seconds. Because the sampling is quick (< 25 ms), but the garbage collection is fairly expensive (> 220 ms), the garbage collection activity is a dominant contributor to the power consumption. To minimize or eliminate this, the system service provides two properties to tune (or disable) the automatic garbage collection feature. The autoGCMemThreshold property controls how much memory must be in use before the garbage collection kicks in. A value of 500000 implies that the auto garbage collection only occurs if the used memory is at 500000 bytes or higher. The default is zero, which allows a garbage collection always when the Lua environment is idle. The autoGCIdleTimeout property allows the idle time-out to be tuned. A value of zero disables the automatic garbage collector. 10.1.3.2 PIN Change Filtering External I/O pins configured as digital inputs and the DTE connect/disconnect interface support configurable pin change filters. The terminal exits power save mode as soon as any state change occurs on these lines but does not post the event to the Lua environment unless the pin change filtering criteria are met. If the filter time (large sample count) is large compared to the frequency of the input events, it could delay input responses and extend the time the terminal is in an active state, thereby increasing power consumption. 10.1.3.3 Analog Sampling Rates Sampling analog ports (analog inputs, temperature, power, etc.) at frequent rates can have a large impact on power consumption. It is also important to be aware that sampling temperature requires the terminal to communicate with the modem, potentially waking it from low power mode. 10.1.3.4 RS-232 Transceiver Configuration Because the RS-232 transceiver is a large consumer of power, it must be carefully managed if external terminals are connected to the RS-232 port. If an external terminal is always connected, the RS-232 transceiver and the RS-232 UART must be manually managed to save power. 10.1.3.5 Satellite Modem Configuration The configuration and usage of the satellite modem must be taken into consideration when attempting to save power consumption. Refer to [T403] for details. 10.1.3.6 LED Control The LED power consumption value is indicated in the product hardware guide. In general, each LED is controlled by a corresponding service (idp, power, cell, and bluetooth). In some cases, the boot loader or start-up firmware may also control the LED. Each service mentioned has a ledControl property with two settings: Terminal or User. When set to Terminal (the default), the LED is controlled by the terminal firmware. API calls to driver the LED return an error in this configuration. When ledControl is set to User, the default terminal functionality is disabled, and the LED can now be controlled exclusively by user API calls. The SATCOMM LED controlled by the idp service has a ledStatusTimeout property, which controls how long the LED is driven when it is in Terminal mode. The default is 4 minutes/ The LED hardware varies depending on the device (Table 7). Table 7: LED Device Activity LED Service Description ST 2100 ST 6000 ST 6100 / ST 9100 ST 6100ME SATCOM YELLOW POWER CELL GREEN SENSOR bluetooth Sensor (Bluetooth) status X X X BLUE 10.1.3.6.1 Satcom / Satellite -Default LED Behavior Terminal and Satellite State ON Time Period Count Interval Notes (ms) (ms) (seconds) Power ON Power ON/External reset Startup Error Rapid flash: Hardware or image issue Satellite Online Once every 30 seconds Satellite Registration in Progress Two times every 30 seconds Waiting for GNSS Three times every 30 seconds Beam Search / Satellite Offline Four times every 30 seconds Internal Error 100 500 5 30 Should not occur SATCOMM: Power ON SATCOMM: Startup Error SATCOMM: Online SATCOMM: Registration in Progress SATCOMM: Waiting for GNSS SATCOMM: Offline SATCOMM: Error 10.1.3.6.2 Power -Default LED Behavior 10.1.3.6.3 Cell -Default LED Behavior Note: This LED only functions if the cellular module is powered on, even if configured to be driven by the user. Note: The operation of this LED is dependent on the type of cellular module being used in the device. Network State ON Time Period Count Interval Notes (ms) (ms) (seconds) No Service (no network or not registered) LED OFF Registered home 2G .Registered home 3G .Registered home NB1/NB2 .Registered roaming 2G .Registered roaming 3G .Registered roaming NB1/NB2 .Data 2G, 3G / Registered LTE LED ON Roaming Data 2G, 3G / Registered LTE 800 1000 1 0 No support on all modules CELL: No Service (no network or not registered) CELL: Registered Home 2G Pattern CELL: Registered Home 3G Pattern CELL: Registered Home NB1/NB2 Pattern CELL: Registered Roaming 2G Pattern CELL: Registered Roaming 3G Pattern CELL: Registered Roaming NB1/NB2 Pattern CELL: Data 2G, 3G/Registered LTE CELL: Roaming Data 2G, 3G 10.1.3.6.4 Sensor -Default LED Behavior SENSOR -Bluetooth Fast Advertising 10.1.3.7 Modem Properties The powerMode property (SIN 27, PIN 10) of the idp service is used by the IsatData Pro modem to change its behavior based on the terminal usage type and could possibly result in power savings when set appropriately. The wakeUpInterval property (SIN 27, PIN 11) controls how often the modem wakes to listen for incoming (to-mobile) messages. Setting this to a longer interval results in power savings but adds latency to message delivery. 10.1.4 Diagnostics The device keeps track of the amount of time it spends in power save mode to allow for tuning of the power saving operation and software to minimize power consumption. The info and shell commands display the power save time along with the device hardware uptime and the percentage of time in power save mode. The power save time is also reported in the terminalStatus message of the system service. The Lua API also supports querying the power save time via the sys.uptime.powersave() API call. See [T405] for details. 11 POWER SERVICE 11.1 Programmed Power off The power service supports an API call to turn off the terminal. The terminal attempts to gracefully shutdown the modem and the LSF environment before turning off the main power. CAUTION: All peripherals are turned off, including the IsatData Pro modem. There are two types of power off mechanisms: • Indefinite Power off The terminal is powered off indefinitely. There are different ways to power the terminal back on depending on the hardware. • Apply external power • Timed Power off The terminal is powered off for a specified number of minutes (minimum 60 minutes). After the time.out has expired, power is reapplied to the terminal, including the IsatData Pro modem. Modem and terminal registration messages are generated at power on with the reset reason of POWER ON. The powerOnReason (SIN 17, PIN 13) indicates that the terminal was powered on due to a Timer (3). 11.2 Power on Reset Reasons Because the terminal can be turned on via multiple mechanisms (switch, timer etc.), the software behaves differently depending on the power on reason. The powerOnReason property (SIN 17, PIN 13) reflects the reason the applications processor was turned on. 12 TIPS AND TRICKS 12.1 Memory usage Like all interpreted (and byte-code) languages, Lua takes care of most of the memory management issues for the programmer. However, there are a few issues to watch out for, which are described in this section. 12.1.1 Garbage Collection Lua relies on garbage collection to reclaim memory that is no longer used. The LSF invokes an incremental garbage collection, by invoking collectgarbage(step), upon every context switch. It also performs a full garbage collection cycle, by invoking the equivalent of collectgarbage(collect), when the Lua code has been idle for a configurable amount of time (Refer to the system service autoGCIdleTimeout property). The system service also has a property (autoGCMemThreshold) that specifies how much memory can be in use before the auto-garbage collection triggers. The default value is set to zero, which means that garbage collection always occurs if the idle time-out expires. However, on a terminal where code needs to run for prolonged periods of time or needs to run often, the full garbage collection cycle may not get a chance to run. In that situation, memory usage may keep going up until processing is done, or the service code itself invokes a full garbage collection cycle. 12.1.2 Tables Tables are one of the largest users of memory in Lua. Each index in a table uses up some memory, in addition to the memory required to store the value itself. Add in some overhead for the internal data structures required by the table itself, and the total usage grows very quickly. The dumpvar() and tdumpvar() functions, described in [T405], are very useful for figuring out how much memory tables use. By passing true as the fourth argument to these functions, a memory usage summary of the table is printed out. One way to save some memory is to try and use arrays, or tables that only use numeric indexes, as much as possible. As the following examples show, arrays use less memory than tables that use string indexes. shell> lua dumpvar({1, 2, 3, 4, 5}, "test", 10, true) test = { --table: 640648b8 (count= 5) [1] = 1; --(mem= 8) [2] = 2; --(mem= 8) [3] = 3; --(mem= 8) [4] = 4; --(mem= 8) [5] = 5; --(mem= 8) }; --(mem= 140) shell> lua dumpvar({a=1, ['b']=2, c=3, ['d']=4, e=5}, "test", 10, true) test = { --table: 64042878 (count= 0) a = 1; --(mem= 8) c = 3; --(mem= 8) b = 2; --(mem= 8) e = 5; --(mem= 8) d = 4; --(mem= 8) }; --(mem= 240) shell> lua dumpvar({a=1, 2, c=3, 4, e=5}, "test", 10, true) test = { --table: 640648b8 (count= 2) [1] = 2; --(mem= 8) [2] = 4; --(mem= 8) a = 1; --(mem= 8) c = 3; --(mem= 8) e = 5; --(mem= 8) }; --(mem= 176) Another way to save on memory is to avoid unnecessary use of tables and nested data structures. For example, rather than grouping several pieces of data into one table, one might consider taking the data out of the table; this eliminates the need to have an extra table at the top level to contain the reset of the data. It also has a side bonus in that any accesses to the data will be slightly faster. 12.2 Using Buffers In Lua, strings are immutable values, meaning they cannot be modified in-place, and characters cannot be added directly. When appending new characters to a string, a new string object is created. This is not very efficient when trying to build a string on the fly. The standard Lua solution to this problem is to use string.format() to build the string in one step. That works well in cases where there are a few items to add to a string; however, it is not very convenient to call the string.format function with more than 10 or so arguments. To work around this, the LSF offers a buffer object, which allows code to build a string on the fly, similar to how the Java StringBuffer class works. The buffer section in [T405] shows the function required to use buffers. In the first mode of operation, a buffer is created with a given maximum size, and characters are added to it. When all data has been added, the resulting string can be retrieved. --allocate a buffer local buf = sys.buffer.create(#myTable) --add all values from a table as characters for i = 1, #myTable do buf:addString(string.char(myTable[i]), 1) end --get the resulting string local str, bitLength = buf:getString() Buffers can also be used to add bits to the string, which is acting as a byte stream. --allocate a buffer for 4 bytes local buf = sys.buffer.create(4) --add data to it buf:addBits(myInteger1, 32) buf:addBits(myInteger2, 4) --retrieve the resulting string local str, bitLength = buf:getString() In the second mode of operation, a buffer is created with an initial string, and characters and/or data are retrieved from it. In this mode, data cannot be added to the buffer. --create the buffer from the string local buf = sys.buffer.create(myString) --retrieve data from it local temp1 = buf:getBits(4) local temp2 = buf:getBits(32) local temp3 = buf:getString(4) 12.3 Nonvolatile Data As discussed earlier, a service can have properties defined for it. Config properties are used to configure the service's behavior and are saved on demand. Volatile properties, on the other hand, are never saved. If a service has data that needs to be stored in nonvolatile storage, but is not configuration data, then the use of files is required. The standard Lua io library is used for this purpose. Note that buffers can be used to access binary data. The code below shows what a typical service would do: --open the file for reading and writing local fHandle = io.open(svcmgr.dataPath() .. "/myData", "r+") --get the data (in this case, 20 bytes) local data = fHandle:read(20) --set up the buffer local buf = sys.buffer.create(data) --get the individual data items local temp1 = buf:getBits(24) local temp1 = buf:getBits(25) ... Using this method, the service is in complete control of how and when data is saved. The file system performs wear leveling so data can be written quite often without needing to worry about wearing out a particular region of the flash; however, care should be taken in designing services to avoid unnecessary writes. This can include only writing data when it changes, rather than periodically writing all data, and collecting changes in a volatile buffer and writing them out on a fixed schedule if the data changes frequently.
